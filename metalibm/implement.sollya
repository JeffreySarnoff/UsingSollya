/*
 * Copyright 2008-2016 by
 *
 * Laboratoire de l'Informatique du ParallÃ©lisme,
 * UMR CNRS - ENS Lyon - UCB Lyon 1 - INRIA 5668
 *
 * and by
 *
 * Laboratoire d'Informatique de Paris 6, equipe PEQUAN,
 * UPMC Universite Paris 06 - CNRS - UMR 7606 - LIP6, Paris, France.
 *
 * Sollya metalibm main procedures for implementing functions
 * with polynomial approximation and Horner scheme evaluation
 *
 * Contributor: Christoph Quirin Lauter (ENS Lyon/ UPMC LIP6 PEQUAN)
 *              christoph.lauter@ens-lyon.org
 *
 * This file is part of the metalibm library developed by the Arenaire
 * project at Ecole Normale Superieure de Lyon and by the equipe PEQUAN
 * at Universite Pierre et Marie Curie Paris 6.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
*/

__implement_metalibmdir = bashevaluate("pwd") @ "/";
if (isbound(__metalibmdir)) then {
   __implement_metalibmdir = "" @ __metalibmdir @ "";
} else {
  __implement_metalibmdir = bashevaluate("pwd") @ "/";
};

externalproc(random, __implement_metalibmdir @ "random.so", integer -> constant);

execute(__implement_metalibmdir @ "remezwrapper.sollya");
execute(__implement_metalibmdir @ "upperbounds.sollya");
execute(__implement_metalibmdir @ "vandercoeff.sollya");
execute(__implement_metalibmdir @ "fpminimax.sollya");
execute(__implement_metalibmdir @ "galoptimisation.sollya");
execute(__implement_metalibmdir @ "symetries.sollya");
execute(__implement_metalibmdir @ "inverse.sollya");
execute(__implement_metalibmdir @ "alternateimplementpoly.sollya");

procedure implementpoly_debug_log(l = ...) {
      var oldDisplay, rawlstr, lstr, ll, i;

      oldDisplay = display;
      display = dyadic!;
      rawlstr = "" @ l;
      display = oldDisplay!;
      lstr = "";
      ll = length(rawlstr);
      if (ll >= 4) then {
         for i from 2 to ll - 1 - 2 do {
             lstr = lstr @ rawlstr[i];
         };
      };
      write("Calling legacy implementpoly!!! Call: implementpoly(", lstr, ")\n");
};

procedure implementpoly_implementation(poly, dom, bound, format, functionname, filename, proof) {
      var p, res, R;

      res = { .okay = false };
      T = { .okay = false };
      if (isbound(alternative_implementpoly)) then {
         T = alternative_implementpoly(poly, dom, bound, format, functionname, filename, proof);
      };
      if (T.okay) then {
         res = T.poly;
      } else {
         implementpoly_debug_log(poly, dom, bound, format, functionname, filename, proof);
         p = implementpoly(poly, dom, bound, format, functionname, filename, proof);
         if (p == p) then {
            res.okay = true;
            res.poly = horner(p);
         };
      };
      return res;
};

procedure base_implementpoly_honorcoeffprec(poly, dom, bound, format, functionname, filename, proof) {
      var T, res, p, pb, pbmax, oldPrec, op;

      p = roundcoefficients(poly, [| TD... |]);
      if (horner(p - poly) == 0) then {
         T = implementpoly_implementation(p, dom, bound, format, functionname, filename, proof);
         if (T.okay) then {
            if (horner(p - T.poly) == 0) then {
           res = horner(T.poly);
        } else {
           op = T.poly;
           oldPrec = prec;
           prec = 300!;
           pb = supnorm(op, p, dom, relative, 2^(-20));
           prec = oldPrec!;
           if (pb == pb) then {
             pbmax = sup(pb);
             if (abs(pbmax) <= abs(bound)/3) then {
                T = implementpoly_implementation(p, dom, abs(bound)/3, format, functionname, filename, proof);
                if (T.okay) then {
               if (horner(p - T.poly) == 0) then {
                  res = horner(T.poly);
               } else {
                      T = implementpoly_implementation(op, dom, abs(bound)/3, format, functionname, filename, proof);
                  if (T.okay) then {
                    res = horner(p);
                  } else {
                    res = error;
                  };
               };
            } else {
               res = error;
            };
                 } else {
                res = error;
             };
           } else {
             res = error;
           };
        };
         } else {
            res = error;
         };
      } else {
         res = error;
      };
      return res;
};

procedure base_implementpoly(poly, dom, bound, format, functionname, filename, proof) {
      var T, res, p, pbmax, oldPrec;

      T = implementpoly_implementation(poly, dom, bound, format, functionname, filename, proof);
      if (T.okay) then {
         if (horner(poly - T.poly) != 0) then {
            res = T.poly;
         } else {
            p = roundcoefficients(poly, [|TD...|]);
        oldPrec = prec;
        prec = 300!;
        pb = supnorm(p, poly, dom, relative, 2^(-20));
        prec = oldPrec!;
        if (pb == pb) then {
           pbmax = sup(pb);
           if (abs(pbmax) <= abs(bound)/3) then {
              T = implementpoly_implementation(p, dom, abs(bound)/3, format, functionname, filename, proof);
              if (T.okay) then {
                 res = T.poly;
              } else {
                 res = error;
              };
           } else {
              res = error;
           };
        } else {
           res = error;
        };
         };
      } else {
         res = error;
      };
      
      return res;
};

procedure actualimplementpoly6(a, b, c, d, e, f) {
      var res;

      res = base_implementpoly(a, b, c, d, e, f, ("tmp" @ getUniqueToken() @ "gappa.gappa"));
      if (!(res == res)) then {
           implementpoly_debug_log(a, b, c, d, e, f);
           res = implementpoly(a, b, c, d, e, f);
      };
      
      return res;
};

procedure actualimplementpoly8(a, b, c, d, e, f, g, h) {
      var res;

      if (g == honorcoeffprec) then {
        res = base_implementpoly_honorcoeffprec(a, b, c, d, e, f, h);
        if (!(res == res)) then {
           implementpoly_debug_log(a, b, c, d, e, f, g, h);
           res = implementpoly(a, b, c, d, e, f, g, h);
        };
      } else {
        implementpoly_debug_log(a, b, c, d, e, f, g, h);
        res = implementpoly(a, b, c, d, e, f, g, h);
      };

      return res;
};

procedure actualimplementpoly(l = ...) {
      var ll;
      var res;

      ll = length(l);
      if (ll == 6) then {
         res = actualimplementpoly6(l[0],l[1],l[2],l[3],l[4],l[5]);
      } else {
         if (ll == 8) then {
            res = actualimplementpoly8(l[0],l[1],l[2],l[3],l[4],l[5],l[6],l[7]);
         } else {
            res = error;
         };
      };
      return res;
};

procedure targetErrorToImplementpolyType(err) {
      var res;

      if (abs(err) < 1b-101) then {
         res = TD;
      } else {
        if (abs(err) < 1b-51) then {
          res = DD;
        } else {
          res = D;
        };
      };

      return res;
};

procedure myimplementpoly(l = ...) {
      var res;
      var myTarget, myVarFormat, myResFormat;
      var oldDisplay, oldPrec;

      oldPrec = prec;
      prec = 165!;

      myTarget = l[2];
      myVarFormat = l[3];
      myResFormat = targetErrorToImplementpolyType(myTarget);
      match myResFormat with
        D  : {
            match (myVarFormat) with
                  D  : { }
                  DD : {
                    myTarget = 1b-54;
                       }
                  TD : {
                    myTarget = 1b-103;
                       };
             }
            DD : {
            if (myVarFormat == TD) then {
               myTarget = 1b-103;
            };
             }
            TD : { };

      res = match (length(l)) with
        6 : (actualimplementpoly(l[0],l[1],myTarget,myVarFormat,l[4],l[5]))
        8 : (actualimplementpoly(l[0],l[1],myTarget,myVarFormat,l[4],l[5],l[6],l[7]))
        default : (error);

          prec = oldPrec!;

      return res;
};


procedure myfindzeros(func,dom) {
      var zeros, numZeros, nz, minBound, maxBound, i, len, dist, z;
      var oldPoints, valid, ya, yb;
      var opr, opo, nz;

      oldPoints = points;
      points = ((points - 1) * 2 + 1)!;

      opr = prec;
      prec = min(53, prec)!;
      opo = points;
      points = 91!;
      nz = mydirtyfindzeros(func,dom);
      points = opo!;
      prec = opr!;
      
      if (nz != [||]) then {
         numZeros = mydirtyfindzeros(func,dom);
      } else {
         numZeros = nz;
      };
      len = length(numZeros);
      zeros = [||];
      if ((len > 0) && (len < 500)) then {
              dist = ((sup(dom) - inf(dom)) * diam)/2;
          minBound = inf(dom);
          for i from 0 to len-1 do {
              if (i != len-1) then {
                maxBound = numZeros[i + 1] - dist;
              } else {
                maxBound = sup(dom);
              };
              nz = numZeros[i];
              z = [ max(minBound, nz - dist) ; min(maxBound, nz + dist) ];
              zeros = zeros :. z;
              minBound = maxBound;
          };
          valid = true;
          for z in zeros do {
              ya = mid(evaluate(func,inf(z)));
              yb = mid(evaluate(func,sup(z)));
              if (ya * yb > 0) then {
                 valid = false;
              };
          };
          if (!valid) then {
             zeros = findzeros(func,dom);
          };
          } else {
              if (len >= 500) then {
            zeros = findzeros(func,dom);
          } else {
            zeros = [||];
          };
      };

      points = oldPoints!;

      return zeros;
};


/* Quickly checks if the infinite norm of func
   in dom is less than target

   Returns false if it is not
   Returns the infinite norm if it is

*/
procedure dirtycheckinfnorm(func,dom,target) {
      var t, b, h, y, maxy;
      var oldprec;
      var res;
      var infn;

      oldprec = prec = ?;
      prec = 20!;
      t = inf(dom);
      b = sup(dom);
      h = round((b - t) / 64,12,RU);
      maxy = 0;
      while ((t <= b) && (maxy <= target)) do {
            maxy = max(maxy, inf(abs(evaluate(func, t))));
        t = round(t + h,12,RU);
      };
      if (0 in dom) then {
         t = 0;
         maxy := max(maxy, abs(func(t)));
      };
      prec = oldprec!;

      if ((maxy == maxy) && (maxy > target)) then
          res = false
      else {
           infn = mydirtyinfnorm(func,dom);
           if (infn > target) then {
              write("Warning: dirtycheckinfnorm decides false case by dirtyinfnorm\n");
              res = false;
           } else res = infn;
      };

      return res;
};


/* implementandcheck

   implements a polynomial in a domain for a given target error
   and checks whether the overall error is less than the target error

   approxerr may be false, in which case the procedure computes the infnorm

   Returns a list containing a boolean (works or not), a polynomial (the implemented one if works), an approx error and an evaluation error.

   The procedure may return false for problems with the implementation

*/
procedure implementandcheck(func,poly,dom,targeterr,targeterrimpl,approxerr,beta,variableFormat,implementationFile,gappaFile,gappaOutputFile,gappaExecutable,polynomialName,domainExcludes) {
      var res;
      var myapproxerr;
      var q;
      var implapproxerr;
      var boundsList;
      var evalerr;
      var i;
      var oldverb;
      var gappaTime;
      var oldDisplay;
      var exclDomString;

      q = poly;

      if (approxerr == false) then {
        myapproxerr = mydirtyinfnorm(poly/func-1,dom);
      } else {
        myapproxerr = approxerr;
      };
      implapproxerr = myapproxerr;
      evalerr = false;

      res = (myapproxerr < targeterr);
      if (res) then {
            q = myimplementpoly(poly,dom,targeterrimpl,variableFormat,polynomialName,implementationFile,honorcoeffprec,gappaFile);
        if (!(q == q)) then {
           write("Something strange happened. The implementpoly command did not succeed\n");
           oldverb = verbosity = ?;
           verbosity = 2!;
               q = myimplementpoly(poly,dom,targeterrimpl,variableFormat,polynomialName,implementationFile,honorcoeffprec,gappaFile);
           verbosity = oldverb!;
           q = poly;
        };
        if (horner(q) == horner(poly)) then {
           implapproxerr = myapproxerr;
        } else {
           implapproxerr = mydirtyinfnorm(q/func-1,dom);
        };
            res = (implapproxerr < targeterr);
        if (res) then {

                match (domainExcludes) with
                  { .excludeFromDomain = true, .excludeDomain = exclDom } : {
                       oldDisplay = display;
                   display = dyadic!;
                   exclDomString = "[" @ inf(exclDom) @ "," @ sup(exclDom) @ "]";
                   display = oldDisplay!;
                   write("The domain contains a zero of the function, patching Gappa file ", gappaFile, " to exclude input domain ", exclDomString, "\n");
                   bashexecute(__implement_metalibmdir @ "/patch-gappa-file "@gappaFile@" '"@exclDomString@"'");
                  }
                  default : {};

            write("boundsList = [|") > gappaOutputFile;
            gappaTime = time({
                                bashexecute(__implement_metalibmdir @ "/gappa-wrapper DIRECT " @ gappaExecutable@" '-Munconstrained' "@gappaFile@" >> "@gappaOutputFile);
                     });
            wholeGappaTime := wholeGappaTime + gappaTime;
            print("0|];") >> gappaOutputFile;
            execute(gappaOutputFile);
            bashexecute("rm " @ gappaOutputFile);
            evalerr = 0;
            for i in boundsList do if (abs(i) > evalerr) then evalerr = abs(i);
            if (evalerr == 0) then evalerr := 1/0;

            if (abs(evalerr) > 1) then {
                 write("\tRe-running Gappa\n");
                 write("boundsList = [|") > gappaOutputFile;
                 gappaTime = time({
                                     bashexecute(__implement_metalibmdir @ "/gappa-wrapper INDIRECT " @ gappaExecutable@" '-Munconstrained' "@gappaFile@" >> "@gappaOutputFile);
                          });
                 wholeGappaTime := wholeGappaTime + gappaTime;
                 print("0|];") >> gappaOutputFile;
                 execute(gappaOutputFile);
                 bashexecute("rm " @ gappaOutputFile);
                 evalerr = 0;
                 for i in boundsList do if (abs(i) > evalerr) then evalerr = abs(i);
                     if (evalerr == 0) then evalerr := 1/0;
                        };

            write("\tGappa determined evaluation error = 2^(",round(log2(evalerr),12,RU),")\n");
            if (abs(evalerr) > 1) then {
               write("\tGappa file: ", gappaFile, "\n");
            };

            res = ((implapproxerr + evalerr + implapproxerr * evalerr) <= (targeterr * beta));
        };
      };

      if (res) then res = [|true, q, implapproxerr, evalerr|] else res = [| false, q, implapproxerr, evalerr|];

      return res;
};


/* configToNumber

   Gives the number of a configuration under a permutation order

*/
procedure configToNumber(config,permut) {
      var res, k, i, tt;

      res = 0;
      for k from length(config)-1 to 0 by -1 do {
          i = config[permut[k]];
          res = res * 3;
          if (i == D) then
        tt = 0
          else
        if (i == DD) then
            tt = 1
        else
            tt = 2;
          res = res + tt;
      };

      return res;
};

/* numberToConfig

   Gives a configuration of a configuration number under a permutation order

*/
procedure numberToConfig(t,permut,numberMonomials) {
    var k, configur, j, dv, r, form;
    k = t;
    configur = [|1,...,numberMonomials|];
    j = 0;
    while (j < numberMonomials) do {
        dv := floor(k / 3);
        r := k - 3 * dv;
        if (r == 0) then
            form = D
        else
            if (r == 1) then
                form = DD
            else
                form = TD;
        configur[permut[j]] = form;
        k = dv;
        j := j + 1;
    };
    return configur;
};


procedure isHigherPrecisionConfig(config,bounds) {
      var res;
      var i, c, b;

      if (length(config) != length(bounds)) then {
         res = false;
      } else {
         res = true;
         i = 0;
         while ((i < length(bounds)) && res) do {
               c = config[i];
           b = bounds[i];
           if (((c == D) && (b != D)) || ((c == DD) && (b == TD))) then res = false;
               i := i + 1;
         };
      };
      return res;
};

procedure isLowerPrecisionConfig(config,bounds) {
      var res;
      var i, c, b;

      if (length(config) != length(bounds)) then {
         res = false;
      } else {
         res = true;
         i = 0;
         while ((i < length(bounds)) && res) do {
               c = config[i];
           b = bounds[i];
           if (((b == D) && (c != D)) || ((b == DD) && (c == TD))) then res = false;
               i := i + 1;
         };
      };
      return res;
};


procedure extraroundcoefficients(poly,monomials,configuration) {
      var confli;
      var i;

      confli = [||];
      for i from 0 to degree(poly) do confli = D.:confli;

      for i from 0 to length(monomials) - 1 do {
          confli[monomials[i]] = configuration[i];
      };

      return roundcoefficients(poly,confli);
};

procedure isOkayConfiguration(t, lb, ub, op, nc) {
      var cf;

      cf = numberToConfig(t,op,nc);

      return (isHigherPrecisionConfig(cf,lb) && isLowerPrecisionConfig(cf,ub));
};

procedure configToFormatNum(cf) {
      var fn, l;

      l = cf;
      fn = [||];
      while (l != [||]) do {
        fn = (match (head(l)) with
                    D  : (1)
                DD : (2)
                TD : (3)) .: fn;
        l = tail(l);
      };
      fn = revert(fn);
      return fn;
};

procedure formatNumToConfig(cf) {
      var fn, l;

      l = cf;
      fn = [||];
      while (l != [||]) do {
        fn = (match (head(l)) with
                    1 : (D)
                2 : (DD)
                3 : (TD)) .: fn;
        l = tail(l);
      };
      fn = revert(fn);
      return fn;
};

procedure giveNextConfigurationNumberOptimized(t, n, lb, ub, op, nc) {
      var res, cf, cfN, ubN, dCF, i, found, l, k, cfNew, tt;

      res = { .okay = false };

      cf = numberToConfig(t,op,nc);

      cfN = configToFormatNum(cf);
      ubN = configToFormatNum(ub);

      if (length(cfN) == length(ubN)) then {
         dCF = [||];
         while ((cfN != [||]) && (ubN != [||])) do {
               dCF = (head(ubN) - head(cfN)) .: dCF;
           cfN = tail(cfN);
           ubN = tail(ubN);
         };
         dCF = revert(dCF);
         if ((cfN == [||]) && (ubN == [||])) then {
            if (length(dCF) == length(op)) then {
           found = false;
           l = length(op);
           i = 0;
           while ((!found) && (i < l)) do {
             if (dCF[op[i]] >= 1) then {
                found = true;
             } else {
                i = i + 1;
             };
           };
           if (found && (i < l)) then {
              cfN = configToFormatNum(cf);
              k = op[i];
              cfN[k] = min(3, cfN[k] + 1);
              cfNew = formatNumToConfig(cfN);
              tt = configToNumber(cfNew,op);
              if ((tt > t) && (tt <= n)) then {
                 if (isOkayConfiguration(t, lb, ub, op, nc)) then {
                res.okay = true;
                res.configurationNumber = tt;
             };
              };
           };
        };
         };
      };

      return res;
};

procedure giveNextConfigurationNumber(t, n, lb, ub, op, nc) {
      var res, r;

      if (t >= n) then {
         res = t + 1;
      } else {
         if (n - t < 100) then {
            res = t + 1;
         } else {
            r = giveNextConfigurationNumberOptimized(t, n, lb, ub, op, nc);
        if (r.okay) then {
           res = r.configurationNumber;
        } else {
           res = t + 1;
        };
         };
      };
      return res;
};


/* implementconfigurations

   Based on func, pstar, lowerbounds, upperbounds and optimisationPermut
   tries to find the first polynomial in optimisationPermut order
   (with the least number of coefficients) that satisfies targeterr

   Uses fpminimax

   Returns [|true, poly, approxerr, implerr, pstar|] if a configuration has been found
   Returns [|false, bestpoly, bestapprox, bestimplerr, pstar |] if no configuration satisfies the target error
   Returns [|false, pstar, 0, 0, false, pstar|] if some other error occurs

*/
procedure implementconfigurations(func,pstar,dom,targeterr,beta,lowerbounds,upperbounds,optimisationPermut,
                              variableFormat,implementationFile,gappaFile,gappaOutputFile,gappaExecutable,polynomialName,domainExcludes) {
          var ii;
      var okay;
      var numbercoefficients;
      var res;
      var approxerr;
      var pointlist;
      var d;
      var monomials;
      var symetrical;
      var firstmonomial;
      var bestpoly, bestapprox, bestimplerr;
      var configuration;
      var implresult;
      var poly;
      var targetlog;
      var looparound, targeterrimpl;
      var dci, dcii, polyRound;

      okay = true;
      numbercoefficients = 0;
      for ii from 0 to degree(pstar) do if (coeff(pstar,ii) != 0) then numbercoefficients := numbercoefficients + 1;
      if ((length(lowerbounds) != length(upperbounds)) || (numbercoefficients != length(lowerbounds))) then {
         okay = false;
         res = [| false, pstar, 0, 0, false, pstar |];
      };

      if (okay) then {
         approxerr = mydirtyinfnorm(pstar/func-1,dom);

         monomials = [||];
         for ii from 0 to degree(pstar) do
               if (coeff(pstar,ii) != 0) then monomials = monomials:.ii;

         symetrical = true;
         ii := length(monomials) - 1;
         firstmonomial = head(monomials);
         while ((ii >= 0) && symetrical) do {
        if (floor((monomials[ii] + firstmonomial) / 2) * 2 != (monomials[ii] + firstmonomial)) then
           symetrical = false;
        ii := ii - 1;
         };
         if (symetrical) then {
            if (-inf(dom) > sup(dom)) then
           d = [1b-1075, -inf(dom)]
            else
           d = [1b-1075, sup(dom)];
         } else {
            d = dom;
         };

         if (horner(pstar/func-1) != 0) then {
            pointlist = mydirtyfindzeros(pstar/func-1,d);
             } else {
            pointlist = [| inf(d), mid(d), sup(d) |];
         };

         firstConfigNumber = configToNumber(lowerbounds,optimisationPermut);
         lastConfigNumber = configToNumber(upperbounds,optimisationPermut);
         t = firstConfigNumber;
         found = false;
         bestpoly = 0;
         bestimplerr = 1000;
         bestapproxerr = 1000;
         ii = 1;
         targetlog = round(log2(targeterr),12,RN);
         while ((!found) && (t <= lastConfigNumber)) do {
               // "Configuration t = ", t, ", firstConfigNumber = ", firstConfigNumber, ", lastConfigNumber = ", lastConfigNumber;
               configuration = numberToConfig(t,optimisationPermut,numbercoefficients);
           if (isHigherPrecisionConfig(configuration,lowerbounds) && isLowerPrecisionConfig(configuration,upperbounds)) then {
              write("Trying configuration #",ii," ",configuration,":\n");

              poly = fpminimaxwrapper(func,dom,monomials,pstar,pointlist,configuration);

              if (poly != false) then {
                        dci = dirtycheckinfnorm(poly/func-1,dom,targeterr);
                if (dci == false) then {
                   polyRound = extraroundcoefficients(pstar,monomials,configuration);
                   dcii = dirtycheckinfnorm(polyRound/func-1,dom,targeterr);
                   if (dcii != false) then {
                      write("Warning: rounded Pstar better that fpminimax polynomial\n");
                      poly = polyRound;
                      dci = dcii;
                   };
                };

                        if (dci != false) then {
                              looparound = true;
                      targeterrimpl = targeterr;
                      while (looparound && (targeterrimpl >= targeterr/16)) do {
                                implresult = implementandcheck(func,poly,dom,targeterr,targeterrimpl,dci,beta,
                                       variableFormat,implementationFile,gappaFile,gappaOutputFile,gappaExecutable,polynomialName,domainExcludes);

                        // implresult[0], implresult[3];
                            if (implresult[0]) then
                           looparound = false
                        else {
                             if ((implresult[3] == false) || (implresult[3] == 1/0)) then
                            looparound = false
                         else
                            targeterrimpl := targeterrimpl / 2;
                        };
                      };
                                      if (implresult[0]) then {
                            found = true;
                                            bestpoly = poly;
                        bestimplerr = implresult[3];
                        bestapproxerr = implresult[2];
                        write("\tfound: target = 2^(",targetlog,"), approx = 2^(",round(log2(bestapproxerr),12,RU),"), evaluat = 2^(",
                                                  round(log2(bestimplerr),12,RU),"), overall = 2^(",
                          round(log2(bestimplerr + bestapproxerr + bestimplerr * bestapproxerr),12,RU),")");
                          } else {
                            if (implresult[2] < bestapproxerr) then {
                           bestpoly = poly;
                           bestapproxerr = implresult[2];
                           bestimplerr = implresult[3];
                                            };
                            write("\tunusable: target = 2^(",targetlog,"), approx = 2^(",
                                                  round(log2(implresult[2]),12,RN),") (best approx = 2^(",
                              round(log2(bestapproxerr),12,RN),"))");
                                      };
                                } else {
                      write("\tunusable: target = 2^(",targetlog,")");
                };
              } else {
                write("\tproblem with fpminimax");
              };
              write("\n");
              ii := ii + 1;
           };
           t = giveNextConfigurationNumber(t, lastConfigNumber, lowerbounds, upperbounds, optimisationPermut, numbercoefficients);
         };
         res = [| found, bestpoly, bestapproxerr, bestimplerr, pstar |];
      };

          return res;
};


/* implements a function by polynomial approximation in an interval centered in 0

   Returns

    [| true, poly, approxerr, implerr, pstar |] if everything is fine
    [| false, 0, 0, 0, 0 |] otherwise

    No test is made whether the interval is correctly centered in 0

*/
procedure implementcentered(func, dom, target, beta, variableFormat, galoptimizedMonomials, implementationFile, gappaFile, gappaOutputFile, gappaExecutable, polynomialName, domainExcludes) {
      var res;
      var Pstar, upperbounds, lowerbounds, optimisationPermut;
      var i, monomials;
      var lowerboundsAndOptiPermut;
      var k, l;

      res = [| false, 0, 0, 0, 0 |];

      Pstar = remezwrapper(func, dom, target, 3);

      if (Pstar != false) then {

        monomials = [||];
        for i from 0 to degree(Pstar) do {
            if (coeff(Pstar,i) != 0) then monomials = monomials:.i;
        };

        upperbounds = determineupperbounds(Pstar, func, dom, target, variableFormat, implementationFile);

        lowerboundsAndOptiPermut = determinelowerbounds(Pstar, func, dom, target);


        if (lowerboundsAndOptiPermut == false) then {

                    lowerbounds = [||];
                    for i in upperbounds do {
                       if (i == D) then
                          lowerbounds = lowerbounds:.D
                           else
                          if (i == DD) then
                         lowerbounds = lowerbounds:.D
                          else
                                 lowerbounds = lowerbounds:.DD;
                        };

                        optimisationPermut = [| 0, ..., length(upperbounds)-1 |];
                } else {
                lowerbounds = lowerboundsAndOptiPermut[0];
            optimisationPermut = lowerboundsAndOptiPermut[1];

            for l from 0 to length(monomials) - 1 do {
                if (listcontains(galoptimizedMonomials,monomials[l])) then {
                   lowerbounds[l] = D;
                };
            };

                };

        if (length(lowerbounds) == length(upperbounds)) then {

        for k from 0 to length(lowerbounds) - 1 do {
            if ((upperbounds[k] == D) && (lowerbounds[k] != D)) then upperbounds[k] = lowerbounds[k];
            if ((upperbounds[k] == DD) && (lowerbounds[k] == TD)) then upperbounds[k] = lowerbounds[k];
        };

            write("Chosen monomial base: ",monomials,"\n");
            write("Lower bounds for precisions of coefficients: ",lowerbounds,"\n");
            write("Upper bounds for precisions of coefficients: ",upperbounds,"\n");
            write("Optimisation permutation: ",optimisationPermut,"\n");
            write("\n");

                res = implementconfigurations(func,Pstar,dom,target,beta,lowerbounds,upperbounds,optimisationPermut,
                                          variableFormat,implementationFile,gappaFile,gappaOutputFile,gappaExecutable, polynomialName, domainExcludes);
        };
          };

      return res;
};



procedure checkSterbenzForMidpoint(midpoint, dom) {
      var res;

      if (midpoint == 0) then {
         res = true;
      } else {
         if (0 in dom) then {
            res = (midpoint == 0);
         } else {
            if (midpoint * inf(dom) < 0) then {
           res = false;
        } else {
           /* Here midpoint has the same sign as all values in dom */
           res = (((abs(midpoint)/2 <= abs(inf(dom))) && (abs(inf(dom)) <= 2 * abs(midpoint))) &&
                  ((abs(midpoint)/2 <= abs(sup(dom))) && (abs(sup(dom)) <= 2 * abs(midpoint))));
        };
         };
      };

      return res;
};

/* implements a function by polynomial approximation in a small interval

   Returns

    [| true, centerpoint, poly, approxerr, implerr |] if everything is fine
    [| false, 0, 0, 0, 0 |] otherwise

   The function to be implemented may have at most 1 zero in the domain.
   No test for this condition is made.

*/
procedure implementsmall(func, dom, target, beta, variableFormat, implementationFile, gappaFile, gappaOutputFile, gappaExecutable, polynomialName, defdom) {
      var res;
      var zerosInInterval, zerosInIntervalRaw, zr, midpoint, zerosInIntervalTemp, zerosInIntervalRaw2;
      var smallestAbsZero;
      var Pstar;
      var okay;
      var startmidpoint;
      var shiftedFunc, shiftedDom;
      var resImpl;
      var oldprec, oldpoints, olddiam;
      var galoptim;
      var galoptimizedMonomials;
      var PstarOrig;
      var nrm;
      var sterbenzOkay;
      var domainExcludes;
      var zeros;
      var shiftedZero, originalZero, originalZeroRoundedDown, originalZeroRoundedUp;
      var originalZeroPred, originalZeroSucc, excludeDomain;

      galoptimizedMonomials = [||];
      okay = true;

      if (inf(dom) * sup(dom) > 0) then {
           zerosInInterval = [||];
           oldprec = (prec = ?);
           prec = oldprec * 3!;
           oldpoints = (points = ?);
           points = oldpoints * 6!;
           olddiam = (diam = ?);
           diam = olddiam / 1b8!;
           zerosInIntervalRaw2 = myfindzeros(func,dom);
           zerosInIntervalRaw = [||];
           for zr in zerosInIntervalRaw2 do
              zerosInIntervalRaw = zerosInIntervalRaw @(myfindzeros(func,zr));
           for zr in zerosInIntervalRaw do
              zerosInInterval = zerosInInterval @ (mydirtyfindzeros(func,zr));
           prec = oldprec!;
           points = oldpoints!;
           diam = olddiam!;
           zerosInIntervalTemp = sort(zerosInInterval);
           zeroInInterval = [||];
           for zr in zerosInIntervalTemp do zerosInInterval = zerosInInterval:.(mid(evaluate(D(x),zr)));
           if (zerosInInterval != [||]) then {
               smallestAbsZero = zerosInInterval[0];
               for zr in zerosInInterval do
                   if (~abs(func(zr)) < ~abs(func(smallestAbsZero))) then smallestAbsZero = zr;
               midpoint := D(smallestAbsZero);
           } else {
               symetrypoint = testEvenSymetry(func, dom, 1b-10, defdom);
           if (symetrypoint != false) then {
              write("Even symmetry dectected\n");
              midpoint := D(symetrypoint);
           } else {
             nrm = mydirtyinfnorm(func, dom);
                     if (abs(func(inf(dom))) < 1b-12 * nrm) then midpoint := D(inf(dom)) else {
             if (abs(func(sup(dom))) < 1b-12 * nrm) then midpoint := D(sup(dom)) else {
             if ((target < 1b-50) && (checkSterbenzForMidpoint(D(mid(dom)), dom))) then {
              PstarOrig = remezwrapper(func(x + D(mid(dom))), [round(inf(dom) - D(mid(dom)),max(prec,300),RD);round(sup(dom) - D(mid(dom)),max(prec,300),RU)], target, 3);
                  if (!(PstarOrig == false)) then {
                     Pstar = simplifysafe(horner(simplifysafe(substitute(PstarOrig,(x - D(mid(dom)))))));
                     startmidpoint := D(mid(dom));
             galoptim = galoptimisation(Pstar,func,dom,target,startmidpoint);
                     midpoint := D(galoptim[0]);
             galoptimizedMonomials = galoptim[1];
                  } else {
                     midpoint := D(mid(dom));
                  };
              } else {
                 midpoint := D(mid(dom));
              };
              }; };
           };
           };

           if (!checkSterbenzForMidpoint(midpoint, dom)) then {
              midpoint = 0;
           };

          } else {
           midpoint = 0;
          };

      if (okay && (midpoint != 0)) then {
         sterbenzOkay = (((inf(dom) * sup(dom) > 0) && (inf(dom) * midpoint > 0)) && ((abs(inf(dom)) >= abs(midpoint)/2) && (abs(sup(dom)) <= 2 * abs(midpoint))));
         if (!sterbenzOkay) then {
            write("Determined midpoint = ", midpoint, " can't be chosen due to necessity to have Sterbenz condition\n");
            midpoint = 0;
         };
      };

      if (okay) then {
         write("Chosen midpoint = ",round(midpoint,53,RN)," = ");
         printhexa(midpoint);

         shiftedFunc = horner(func(x + midpoint));
         shiftedDom = [round(inf(dom) - midpoint,max(300,prec),RD) ; round(sup(dom) - midpoint,max(300,prec),RU)];

         domainExcludes = { .excludeFromDomain = false };
         zeros = mydirtyfindzeros(shiftedFunc, shiftedDom);
         if (zeros != [||]) then {
                shiftedZero = zeros[0];
            if (shiftedZero != 0) then {
                originalZero = shiftedZero + midpoint;
            originalZeroRoundedDown = round(originalZero - 1b-1076, variableFormat, RD);
            originalZeroRoundedUp = round(originalZero + 1b-1076, variableFormat, RU);
            originalZeroPred = round(originalZeroRoundedDown - 1b-1076, variableFormat, RD);
            originalZeroSucc = round(originalZeroRoundedUp + 1b-1076, variableFormat, RU);
            excludeDomain = [originalZeroPred - midpoint; originalZeroSucc - midpoint];
            if ((0 in shiftedDom) && (0 in excludeDomain)) then {
               excludeDomain = [ min(inf(excludeDomain), inf(shiftedDom) * 1b-400);
                         max(sup(excludeDomain), sup(shiftedDom) * 1b-400) ];
            };
                    domainExcludes = { .excludeFromDomain = true; .excludeDomain = excludeDomain };
            };
         };

         write("The translated function is f = ",shiftedFunc,"\n");
         write("The translated domain is dom = ",shiftedDom,"\n");

         resImpl = implementcentered(shiftedFunc, shiftedDom, target, beta, variableFormat, galoptimizedMonomials,
                                     implementationFile, gappaFile, gappaOutputFile, gappaExecutable, polynomialName, domainExcludes);

         res = [| resImpl[0], midpoint, resImpl[1], resImpl[2], resImpl[3], resImpl[4] |];

      } else {
        res = [| false, 0, 0, 0, 0, 0 |];
      };

      return res;
};

procedure implementShifter(centerPoint, dom, variableFormat, outputFormat, polynomialName, functionName, implementationFile) {
      var res;
      var shifterCode, oldDisplay, oldPrec;
      var sterbenzOkay;

      res = { .okay = false };

      /* Check if centerPoint is a double precision number in the domain
             and if Sterbenz' lemma will be verified for the whole domain */
      if ((D(centerPoint) - centerPoint == 0) &&
              (centerPoint in dom)) then {
              sterbenzOkay = (((inf(dom) * sup(dom) > 0) && (inf(dom) * centerPoint > 0)) && ((abs(inf(dom)) >= abs(centerPoint)/2) && (abs(sup(dom)) <= 2 * abs(centerPoint))));
          if (sterbenzOkay) then {
               res.okay = true;
           oldDisplay = display;
           display = decimal!;
           oldPrec = prec;
           prec = 350!;
           shifterCode = "\n\n#define " @ functionName @ "_centerpoint " @ centerPoint;
           display = oldDisplay!;
           prec = oldPrec!;
           shifterCode = shifterCode @ "\n\nvoid "@functionName@"(";
           shifterCode = shifterCode @ (match outputFormat with
                                                  D   : ( "double *res_resh, " )
                                                  DD  : ( "double *res_resh, double *res_resm, " )
                                                  TD  : ( "double *res_resh, double *res_resm, double *res_resl, " )
                                           );
               shifterCode = shifterCode @ (match variableFormat with
                                                  D   : ( "double x" )
                                                  DD  : ( "double xh, double xm" )
                                                  TD  : ( "double xh, double xm, double xl" )
                                           );
               shifterCode = shifterCode @ ") {\n";
               shifterCode = shifterCode @ (match variableFormat with
                                                  D   : ( "double t;\n\n" )
                                                  DD  : ( "double th, tm;\ndouble temp;\n\n" )
                                                  TD  : ( "double th, tm, tl;\ndouble temp;\n\n" )
                                           );
               shifterCode = shifterCode @ (match variableFormat with
                                                  D   : ( "t = x - " @ functionName @ "_centerpoint;" )
                                                  DD  : ( "temp = xh - " @ functionName @ "_centerpoint;\nAdd12(th,tm,temp,xm);" )
                                                  TD  : ( "temp = xh - " @ functionName @ "_centerpoint;\nRenormalize3(&th,&tm,&tl,temp,xm,xl);" )
                                           );
               shifterCode = shifterCode @ "\n\n";
           shifterCode = shifterCode @ polynomialName @ "(";
           shifterCode = shifterCode @ (match outputFormat with
                                                  D   : ( "res_resh, " )
                                                  DD  : ( "res_resh, res_resm, " )
                                                  TD  : ( "res_resh, res_resm, res_resl, " )
                                           );
               shifterCode = shifterCode @ (match variableFormat with
                                                  D   : ( "t" )
                                                  DD  : ( "th, tm" )
                                                  TD  : ( "th, tm, tl" )
                                           );
               shifterCode = shifterCode @ ");\n\n";
           shifterCode = shifterCode @ "}\n";
           write(shifterCode) >> implementationFile;
          } else {
        write("Error: Sterbenz condition not fulfilled for argument center ", centerPoint, " and domain ", dom, "\n");
      };
      };

      return res;
};

/* implements a function by polynomial approximation in a small interval
   while issuing appropriate range translation code if the interval
   is not centered in zero.

   Returns a structure that

     - always contains an element okay which is true if everything is fine
       respectively false if some error happened
     - contains, if everything is fine, the following elements
          * approxerr    the approximation error
          * implerr      the implementation (round-off) error
          * centerpoint  the point the original interval got centered at
          * outputformat the D/DD/TD format the result is produced in
          * functionname the eventual name of the function after argument
                         translation
          * poly         the polynomial that has been used
          * pstar        the best approximation polynomial used for
                         floating-point approximation

   The function to be implemented may have at most 1 zero in the domain.
   No test for this condition is made.

*/
procedure implementsmallwithcentering(func, dom, target, beta, variableFormat, implementationFile, gappaFile, gappaOutputFile, gappaExecutable, polynomialName, defdom) {
      var res, resultat, outputFormat, resShifter, str;

      resultat = { .okay = false };

      write("Starting to implement f = ", func, " on dom = ", dom, " with polynomial approximation\n");

      res = implementsmall(func, dom, target, beta, variableFormat, implementationFile, gappaFile, gappaOutputFile, gappaExecutable, polynomialName, defdom);

      if (res[0]) then {
         /* Get the information returned by the implementer function working on a small interval */
         resultat.okay = true;
         resultat.approxerr = res[3];
         resultat.implerr = res[4];
         resultat.poly = res[2];
         resultat.pstar = res[5];
         resultat.centerpoint = res[1];

         /* Determine the output format of the implemented polynomial */
         str = bashevaluate("cat "@implementationFile@" | grep \"void "@polynomialName@"\" | sed -n 's/double x.*//g;p' | sed -n 's/void "@polynomialName@"(double \\*"@polynomialName@"_resh, double \\*"@polynomialName@"_resm, double \\*"@polynomialName@"_resl, /TD/g;p' | sed -n 's/void "@polynomialName@"(double \\*"@polynomialName@"_resh, double \\*"@polynomialName@"_resm, /DD/g;p' | sed -n 's/void "@polynomialName@"(double \\*"@polynomialName@"_resh, /D/g;p'");
         if (str != "") then {
            outputFormat = parse(str);
         } else {
            outputFormat = TD;
         };
         if (!(outputFormat == outputFormat)) then {
            outputFormat = TD;
         };
         resultat.outputformat = outputFormat;

         /* Generate the code that shifts the domain with the centerpoint determined beforehand */
         if (resultat.centerpoint != 0) then {
           resultat.functionname = polynomialName@ "_shifter";
           resShifter = implementShifter(resultat.centerpoint, dom, variableFormat, outputFormat, polynomialName, resultat.functionname, implementationFile);
           if (!resShifter.okay) then {
              resultat = { .okay = false };
           };
         } else {
           resultat.functionname = polynomialName;
         };
      };

      return resultat;
};

procedure splitList(l, i) {
      var res;
      var lA, lB, k, lenL;

      lenL = length(l);
      if ((i < 0) || (i >= lenL)) then {
         res.lA = l;
         res.lB = [||];
      } else {
        lA = [||];
        for k from 0 to i - 1 do {
            lA = lA :. (l[k]);
        };
        lB = [||];
        for k from i to lenL - 1 do {
            lB = lB :. (l[k]);
        };
        res.lA = lA;
        res.lB = lB;
      };

      return res;
};

procedure generateRecursiveSplitter(splitPointName, domains, functionNames, outputFormats, variableFormat, globalOutputFormat) {
      var resultat;
      var lenDomains, lenFunctionNames, lenOutputFormats, splitterCode, middleIndex, res;
      var splitPointA, splitPointB;
      var temp;
      var domainsLeft, domainsRight, functionNamesLeft, functionNamesRight, outputFormatsLeft, outputFormatsRight;
      var oldDisplay, resLeft, resRight, myDefines;

      resultat = { .okay = false };

      lenDomains = length(domains);
      lenFunctionNames = length(functionNames);
      lenOutputFormats = length(outputFormats);

      if ((lenDomains == lenFunctionNames) &&
          (lenFunctionNames == lenOutputFormats) &&
          (lenDomains != 0)) then {

          if (lenDomains == 1) then {
              resultat.okay = true;
          resultat.defines = "";
          splitterCode = functionNames[0] @ "(";
          splitterCode = splitterCode @ (match (outputFormats[0]) with
                                               D  :    ("res_resh, ")
                                                       DD :    ("res_resh, res_resm, ")
                                                       TD :    ("res_resh, res_resm, res_resl, ")
                                                );
                  splitterCode = splitterCode @ (match (variableFormat) with
                                                       D  :    ("xh")
                                                       DD :    ("xh, xm")
                                                       TD :    ("xh, xm, xl")
                                                );
                  splitterCode = splitterCode @ ");\n";
                  match (globalOutputFormat) with
                        TD : {
                                match (outputFormats[0]) with
                                      DD :  {
                                                splitterCode = splitterCode @ "*res_resl = 0.0;\n";
                                            }
                                      D  :  {
                                                splitterCode = splitterCode @ "*res_resm = 0.0;\n";
                                                splitterCode = splitterCode @ "*res_resl = 0.0;\n";
                                            }
                                      default : { };
                             }
                        DD : {
                                if (outputFormats[0] == D) then {
                                   splitterCode = splitterCode @ "*res_resm = 0.0;\n";
                                };
                             }
                        default : { };
              resultat.splitterCode = splitterCode;
          } else {
              middleIndex = floor(lenDomains / 2);
          splitPointA = inf(domains[middleIndex]);
          splitPointB = sup(domains[middleIndex - 1]);
                  if (splitPointA == splitPointB) then {
             temp = splitList(domains, middleIndex);
             domainsLeft = temp.lA;
             domainsRight = temp.lB;
             temp = splitList(functionNames, middleIndex);
             functionNamesLeft = temp.lA;
             functionNamesRight = temp.lB;
             temp = splitList(outputFormats, middleIndex);
             outputFormatsLeft = temp.lA;
             outputFormatsRight = temp.lB;
             resLeft = generateRecursiveSplitter(splitPointName @ "_0", domainsLeft, functionNamesLeft, outputFormatsLeft, variableFormat, globalOutputFormat);
             resRight = generateRecursiveSplitter(splitPointName @ "_1", domainsRight, functionNamesRight, outputFormatsRight, variableFormat, globalOutputFormat);
             if (resLeft.okay && resRight.okay) then {
                 resultat.okay = true;
             oldDisplay = display;
             display = decimal!;
             myDefines = "#define " @ splitPointName @ "_splitpoint " @ splitPointA @ "\n";
             display = oldDisplay!;
             splitterCode = "if ( xh < " @ splitPointName @ "_splitpoint ) {\n" @
                                        resLeft.splitterCode @ "} else {\n" @
                                        resRight.splitterCode @ "}\n";
             resultat.defines = resLeft.defines @ myDefines @ resRight.defines;
             resultat.splitterCode = splitterCode;
             };
          };
          };
      };

      return resultat;
};


procedure checkIfElementsInListAllEqual(l) {
      var res, c, ll, h;

      if (l == [||]) then {
         res = true;
      } else {
         res = true;
         c = head(l);
         ll = tail(l);
         while (res && (ll != [||])) do {
               h = head(ll);
           ll = tail(ll);
           if (h != c) then {
              res = false;
           };
         };
      };

      return res;
};

/* Wrapper around interpolate to follow old interface for interpole */
procedure interpole(X, Y) {
      var rX, rY, i;

      rX = [||];
      for i from length(X) - 1 to 0 by -1 do {
          rX = (round(X[i], 2 * prec, RN)) .: rX;
      };

      rY = [||];
      for i from length(Y) - 1 to 0 by -1 do {
          rY = (round(Y[i], 2 * prec, RN)) .: rY;
      };

      return horner(interpolate(rX, rY));
};


/* Computes the floating-point successor of X in double precision.
   Computes the floating-point successor of the double precision
   number nearest to X if X is not a double precision number.
*/
procedure succDouble(X) {
      return round(D(X) + 1b-1076,D,RU);
};

/* Computes the floating-point predecessor of X in double precision.
   Computes the floating-point predecessor of the double precision
   number nearest to X if X is not a double precision number.
*/
procedure predDouble(X) {
      return round(D(X) - 1b-1076,D,RD);
};

procedure checkReconstructionPolyOK(poly, domains, n) {
      var res, N, dom, infpoly, suppoly, i, j, found, okay, newpoly, imageInterval, maxdelta, maxi, maxj;
      
      res = {.okay = false};
      stop = false;
      okay = true;
      N = length(domains);
      dom =  [inf(domains[0]), sup(domains[N-1])]; /* CAREFUL */
      maxdelta = 0.0;
      maxi = -1;

      infpoly = poly(inf(dom));
      suppoly = poly(sup(dom));
      derivzeros = dirtyfindzeros(diff(poly), dom);
      i = 0; okay = true;
      while (okay && i < N) do {
          imageInterval  = dirtyEvaluateImage(poly, [succDouble(inf(domains[i])), predDouble(sup(domains[i]))]);
          okay = okay && (inf(imageInterval) >= i -n) && (sup(imageInterval) < i + 1-n);
          okay = okay && (poly(inf(domains[i])) >= i - n - 1) && (poly(sup(domains[i])) < i - n + 1); // to consider splitpoints
          i = i+1;
      };

      if (! okay) then {
         if (length(derivzeros) > 0) then {
            i = 0;
        j = 0;
        found = false;
        while (i < length(derivzeros)) do {
              j= 0;
              while ( (j < N)  && (! (derivzeros[i] in domains[j])) /*&& (! (found))*/) do {
                    j = j + 1;
                  /* "j = ", j, " domains[j] = ", domains[j];
                   found = found  || (!(poly(derivzeros[i]) in [j - n, j + 1 - n]));
               if (found && abs(j - n - 0.5 - poly(derivzeros[i])) > maxdelta) then {
                  maxdelta = abs(j - n - 0.5 - poly(derivzeros[i]));
                  maxi = i;
                  maxj = j;
               };
               j = j + 1; */
              };
              if (!(poly(derivzeros[i]) in [j - n, j + 1 - n])) then {
             if (abs(j - n + 0.5 - poly(derivzeros[i])) > maxdelta) then {
                  maxdelta = abs(j - n - 0.5 - poly(derivzeros[i]));
                  maxi = i;
                  maxj = j;
               };
              };
              i = i + 1;
        };
        if (maxdelta > 0) then {
           res = {.okay = false, .addPoint = true, .xpoint = derivzeros[maxi], .ypoint = (-1) / (inf(domains[maxj]) - sup(domains[maxj])) * (derivzeros[maxi] - sup(domains[maxj])) + maxj  + 1 };
        } else {
          res = {.okay = false, .addPoint = false};
        };
         } else {
           res = {.okay = false, .addPoint = false};
         };
      } else {
        res = {.okay = true, .addPoint = false};
      };

      return res;
};

procedure buildReconstructPoly(xpoints, ypoints, formatlist) {
      var poly, oldprec, polyWithoutRounding, n, i;

      n = xpoints[0];
      fn = ypoints[0];
      for i from 1  to length(xpoints) - 1 do {
          if (abs(xpoints[i]) < abs(n)) then {
             n = xpoints[i];
         fn = ypoints[i];
         };
      };
      for i from 0  to length(xpoints) - 1 do {
          ypoints[i] = ypoints[i] - fn;
      };
      oldprec = prec;
      prec = 600!;
      poly = roundcoefficients(interpole(xpoints, ypoints), formatlist);
      polyWithoutRounding = interpole(xpoints, ypoints);
    //  "polyWithoutRounding = ", polyWithoutRounding;
      prec = oldprec!;
      return {.poly = poly, .fn = fn};
};


procedure buildAndCheck(domains, name) {
      var i, res, buildRes, checkRes, xpoints, ypoints, N;

      res = {.okay = false, .name = name};
      N = length(domains);
      xpoints = [| |];
      if (name == "inner") then {
         for i from 1 to N - 1 do {
             xpoints = inf(domains[i]) .: xpoints;
         };
         xpoints = revert(xpoints);
         ypoints = [| 1, ..., N - 1 |];
         buildRes = buildReconstructPoly(xpoints, ypoints, [|D...|]);
         //plot((buildRes.poly + buildRes.fn).:ypoints, [inf(domains[0]), sup(domains[N - 1])]);
         //plot((buildRes.poly + buildRes.fn).:ypoints, [inf(domains[0]), sup(domains[N - 1])], postscript, "/home/kupriianova/metalibm/metalibm/reconstrunctPolyOK2");
         res = checkReconstructionPolyOK(buildRes.poly, domains, buildRes.fn);
         res.poly = buildRes.poly;
         res.direction = name;
      };
      if (name == "left") then {
        for i from 0 to N - 1 do {
             xpoints = inf(domains[i]) .: xpoints;
         };
         xpoints = revert(xpoints);
         ypoints = [| 0, ..., N - 1 |];
         buildRes = buildReconstructPoly(xpoints, ypoints, [|D...|]);
         //plot((buildRes.poly + buildRes.fn).:ypoints, [inf(domains[0]), sup(domains[N - 1])]);
         res = checkReconstructionPolyOK(buildRes.poly, domains, buildRes.fn);
         res.poly = buildRes.poly;
         res.direction = name;
      };
      if (name == "right") then {
         for i from 0 to N - 1 do {
             xpoints = sup(domains[i]) .: xpoints;
         };
         xpoints = revert(xpoints);
         ypoints = [| 1, ..., N  |];
         buildRes = buildReconstructPoly(xpoints, ypoints, [|D...|]);
         //plot((buildRes.poly + buildRes.fn).:ypoints, [inf(domains[0]), sup(domains[N - 1])]);
         //plot((buildRes.poly + buildRes.fn).:ypoints, [inf(domains[0]), sup(domains[N - 1])], postscript, "/home/kupriianova/metalibm/metalibm/reconstrunctPolyOK1");
         res = checkReconstructionPolyOK(buildRes.poly, domains, buildRes.fn);
         res.poly = buildRes.poly;
         res.direction = name;
      };
      if (name == "all") then {
         for i from 0 to N - 1 do {
             xpoints = sup(domains[i]) .: xpoints;
         };
         xpoints = revert(xpoints);
         xpoints = inf(domains[0]).:xpoints;
         ypoints = [| 0, ..., N  |];
         buildRes = buildReconstructPoly(xpoints, ypoints, [|D...|]);
         res = checkReconstructionPolyOK(buildRes.poly, domains, buildRes.fn);
         res.poly = buildRes.poly;
         res.direction = name;
      };

      return res;
};

/*  Builds a polynomial of degree not more than maxDegree for the given domains.
    The whole domain was split into subintervals, this polynomial approximates piecewise-constant function (steps) that gives the number of the subdomain.
    If it's possible to build such a polynomial result.okay is true and the reconstructed polynomial is in result.poly
*/

procedure tryGeneratePolynomialSplitterReconstructionPolynomial(domains, maxDegree) {
      var res, direction, N, tmpres, buildres, stablepoly, currdegree, xpoints, ypoints, stablepolydeg;


      direction = "inner";
      stablepoly = 0;
      stablepolydeg = 0;
      res = {.okay = false};
      N = length(domains);
      tmpres = buildAndCheck(domains, direction);

      currdegree = N - 3;
      if (tmpres.okay) then {
         stablepoly = tmpres.poly;
         res = tmpres;
      } else {
        direction = "left";
        tmpres = buildAndCheck(domains, direction);
        currdegree = N - 2;
        if (tmpres.okay) then {
           stablepoly = tmpres.poly;
           res = tmpres;
        } else {
          direction = "right";
          tmpres = buildAndCheck(domains, direction);
          currdegree = N - 1;
          if (tmpres.okay) then {
             stablepoly = tmpres.poly;
             res = tmpres;
          } else {
          // right not okay
              ypoints = [| 0, ... , N -1 |];
          xpoints = [| |];
          for i from (N - 1) to 0 by -1 do {
              xpoints = sup(domains[i]).:xpoints;
          };
            direction = "all";
        currdegree = N - 1;
        tmpres = buildAndCheck(domains, direction);
        ypoints = [| 0, ... , N |];
        if (tmpres.okay) then {
           stablepoly = tmpres.poly;
           res = tmpres;
           currdegree = N ;
        } else {
          ypoints = [| 0, ... , N |];
          xpoints = [| |];
          for i from (N - 1) to 0 by -1 do {
              xpoints = sup(domains[i]).:xpoints;
          };
          xpoints = (inf(domains[0])).:xpoints;

          while (currdegree < maxDegree && (!(tmpres.okay) && (tmpres.addPoint))) do {
            currdegree = currdegree + 1;

            xpoints = sort((tmpres.xpoint).:xpoints);
            ypoints = sort((tmpres.ypoint).:ypoints);
            buildres = buildReconstructPoly(xpoints, ypoints,  [|D...|]);

            tmpres = checkReconstructionPolyOK(buildres.poly, domains, buildres.fn);
            tmpres.poly = buildres.poly;
          };
          res = tmpres;

          if ((stablepoly != 0) && (currdegree > stablepolydeg)) then {
             res.poly = stablepoly;
          };
        }; // else
          };
        }; // else left !OK
      }; // else inner !OK
      return res;
};

/*
procedure tryGeneratePolynomialSplitterReconstructionPolynomial8(domains, maxDegree) {
      var res, N, dom, currDegree, poly, stablepoly, i, buildres, checkRes, leftpoints, rightpoints, currPoints, ypoints;

      res = {.okay  = false};
      N = length(domains);
      dom =  [inf(domains[0]), sup(domains[N-1])];
      if (maxDegree < N - 3) then {
         res = {.okay = false};
      } else {
        leftpoints = [| |];
        rightpoints = [| |];
        for i from 0 to N - 1 do {
            leftpoints = inf(domains[i]).:leftpoints;
            rightpoints = sup(domains[i]).:rightpoints;
        };
        leftpoints = revert(leftpoints);
        rightpoints = revert(rightpoints);
        currPoints = tail(leftpoints);

        //test inner poly first
        ypoints = [| 1, ..., N - 1 |];
        buildres = buildReconstructPoly(currPoints, ypoints, [|D...|]);
        currDegree = N - 3;
        poly = buildres.poly;
        //plot(poly.:ypoints + buildres.fn, dom);
        checkRes = checkReconstructionPolyOK(poly, domains, buildres.fn);
        if (checkRes.okay) then {
           stablepoly = poly;
           res = {.okay = true, .direction = "inner", .poly = stablepoly};
        } else {
            //try with leftpoly!
        currPoints = leftpoints;
        ypoints = [| 0, ... , N - 1|];
        buildres = buildReconstructPoly(currPoints, ypoints, [|D...|]);
        currDegree = N - 2;
        poly = buildres.poly;
            //plot(poly.:ypoints + buildres.fn, dom);
        checkRes = checkReconstructionPolyOK(poly, domains, buildres.fn);
        if (checkRes.okay) then {
           stablepoly = poly;
           res = {.okay = true, .direction = "left", .poly = stablepoly};
        } else {
          while (currDegree <= maxDegree && checkRes.addPoint && (!(checkRes.okay)) &&  (currDegree - N + 2 < 5)) do {
                currPoints = sort(checkRes.xpoint.:currPoints);
            ypoints = sort(checkRes.ypoint.:ypoints);
            currDegree = currDegree + 1;
            buildres = buildReconstructPoly(currPoints, ypoints, [|D...|]);
            checkRes = checkReconstructionPolyOK(buildres.poly, domains, buildres.fn);
              };
          if (checkRes.okay) then {
             stablepoly = buildres.poly;
             res = {.okay = true, .direction = "leftWithAddPoints", .poly = stablepoly};
          } else {
            //try rightpoly
            currPoints = rightpoints;
            ypoints = [|1, ..., N|];
            buildres = buildReconstructPoly(currPoints, ypoints, [|D...|]);
            currDegree = N - 2;
            poly = buildres.poly;
                //plot(poly.:ypoints + buildres.fn, dom);
            checkRes = checkReconstructionPolyOK(poly, domains, buildres.fn);

            if (checkRes.okay) then {
               stablepoly = poly;
               res = {.okay = true, .direction = "left", .poly = stablepoly};
            } else {
            while (currDegree <= maxDegree && checkRes.addPoint && (!(checkRes.okay)) &&  (currDegree - N + 2 < 5)) do {
                currPoints = sort(checkRes.xpoint.:currPoints);
            ypoints = sort(checkRes.ypoint.:ypoints);
            currDegree = currDegree + 1;
            buildres = buildReconstructPoly(currPoints, ypoints, [|D...|]);
            checkRes = checkReconstructionPolyOK(buildres.poly, domains, buildres.fn);
              };
          if (checkRes.okay) then {
             stablepoly = buildres.poly;
             res = {.okay = true, .direction = "rightWithAddPoints", .poly = stablepoly};
          } else {
            currPoints = inf(dom).:rightpoints;
            ypoints = [|0, ..., N|];
            buildres = buildReconstructPoly(currPoints, ypoints, [|D...|]);
            currDegree = N - 1;
            poly = buildres.poly;
                //plot(poly.:ypoints, dom);
            checkRes = checkReconstructionPolyOK(poly, domains, buildres.fn);
             if (checkRes.okay) then {
               stablepoly = poly;
               res = {.okay = true, .direction = "all", .poly = stablepoly};
            } else {

                while (currDegree <= maxDegree && checkRes.addPoint && (!(checkRes.okay)) &&  (currDegree - N + 2 < 5)) do {
                          currPoints = sort(checkRes.xpoint.:currPoints);
                  ypoints = sort(checkRes.ypoint.:ypoints);
                      currDegree = currDegree + 1;
                      buildres = buildReconstructPoly(currPoints, ypoints, [|D...|]);
                      checkRes = checkReconstructionPolyOK(buildres.poly, domains, buildres.fn);
                };
            if (checkRes.okay) then {
                   stablepoly = poly;
                   res = {.okay = true, .direction = "allWithPoints", .poly = stablepoly};
                };

            };
          };

          };

        };

          };
        };

      };

      return res;
};
*/

procedure tryGeneratePolynomialSplitterReconstructionPolynomial2(domains, maxDegree) {
      var res, continuesearch, poly, funcpoints, leftpoints, rightpoints, allpoints, N, oldprec, derivzeros, dom, polyOK, i, buildres, currPolyDegree;

      res = {.okay = false};
      continuesearch = true;

      N = length(domains);
      dom =  [inf(domains[0]), sup(domains[N-1])];

      if (maxDegree < N - 1) then {
         res = {.okay = false};
      } else {
        leftpoints = [| |];
        rightpoints = [| |];
        //1. Start with the leftpoly built by innerpoints: for each splitpoint take the upper value
        for domain in domains do {
          leftpoints = inf(domain).:leftpoints;
          rightpoints = sup(domain).:rightpoints;
        };
        leftpoints = revert(leftpoints);
        rightpoints = revert(rightpoints);
        funcpoints = [|1, ..., N - 1|];
        buildres = buildReconstructPoly(tail(leftpoints), funcpoints, [|D...|]);
        currPolyDegree = N - 3;
        poly = buildres.poly;

//      plot(poly.:funcpoints, dom);

        polyOK = checkReconstructionPolyOK(poly, domains, buildres.fn);
        if (polyOK.okay) then {
           res = {.okay = true, .direction = "inner", .poly = poly};
        } else {
           // inner poly was not ok, need to add some point and recompute.
           //I will try to add derivPoints
          /* derivzeros = dirtyfindzeros(diff(poly), dom);
          while (length(derivzeros) > 0 && currPolyDegree < maxDegree && (!(polyOK))) do {
                 derivzeros = dirtyfindzeros(diff(poly), dom);
             leftpoints = derivzeros[0].:leftpoints;

           };
           */

           funcpoints = [|0, ..., N - 1|];
           buildres = buildReconstructPoly(leftpoints, funcpoints, [|D...|]);
           poly = buildres.poly;
           polyOK = checkReconstructionPolyOK(poly, domains, buildres.fn);
           if (polyOK.okay) then {
              res = {.okay = true, .direction = "left", .poly = poly};
           } else {
             //Try right poly here!
         funcpoints = [|1, ..., N|];
         buildres = buildReconstructPoly(rightpoints, funcpoints, [|D...|]);
         poly = buildres.poly;
         polyOK = checkReconstructionPolyOK(poly, domains, buildres.fn);
         if (polyOK.okay) then {
            res = {.okay = true, .direction = "right", .poly = poly};
         } else {
           //Full poly. Try to add all points and check
           funcpoints = [| 0, ... , N |];
           allpoints = inf(dom).:rightpoints;
           buildres = buildReconstructPoly(allpoints, funcpoints, [|D...|]);
           poly = buildres.poly;
           polyOK = checkReconstructionPolyOK(poly/* + poly(buildres.n)*/, domains, buildres.fn);
           if (polyOK.okay) then {
              res = {.okay = true, .direction = "full", .poly = poly};
           };
         };
           };
        };
      };
      if (degree(poly) > maxDegree) then { //just to be sure
         res = {.okay = false};
      };
      return res;
};


procedure tryGeneratePolynomialSplitterReconstruction(functionName, domains, reducedFunctionNames, variableFormat, outputFormat, tempFile, maxDegree) {
      var res;
      var resPoly;

      res = { .okay = false };
      resPoly = tryGeneratePolynomialSplitterReconstructionPolynomial(domains, maxDegree);
      if (resPoly.okay) then {
         "The reconstruction polynomial is ", resPoly.poly;
      };
      return res;
};


/* implements a function by polynomial approximation in small intervals
   obtained by cutting the interval at given points

   Returns a structure that

     - always contains an element okay which is true if everything is fine
       respectively false if some error happened
     - contains, if everything is fine, the following elements
          * approxerr    the maximum approximation error
          * implerr      the maximum implementation (round-off) error
          * outputformat the D/DD/TD format the result is produced in
          * functionname the eventual name of the function after argument
                         reduction

   The function to be implemented may have at most 1 zero in each sub-domain.
   No test for this condition is made.

*/
procedure implementwithdomainsplitlist(func, dom, splitPoints, minWidth, definitionDomain, target, beta, variableFormat, implementationFile, gappaFile, gappaOutputFile, gappaExecutable, polynomialBaseName, maxDegreeReconst) {
      var resultat;
      var okay, sp;
      var mySplitPoints;
      var approxerr, implerr, outputFormats, functionNames;
      var domains, i, numberSplitPoints, myDom, mySuffix, myImplementationFile;
      var res, implementationFiles, implFile, myOutputFormat, opF, myOutputFormatNum;
      var myFunctionName, splitterCode, oldDisplay, recursiveSplitterRes, symmetrizedDom, recovered;
      var doElseCase;
      var resOpt;
      var oP;

      resultat = { .okay = false };

      /* First of all, if no splitPoints are given, the domain is not
         split and we can simply call implementsmallwithcentering
      */
      doElseCase = true;
      if (splitPoints == [||]) then {
         doElseCase = false;
         resultat = implementsmallwithcentering(func, dom, target, beta, variableFormat, implementationFile, gappaFile, gappaOutputFile, gappaExecutable, polynomialBaseName, definitionDomain);

         if (!(resultat.okay)) then {
            /* The implementation did not work out.

           We split the interval by "inventing"
           one or two split points.

        */
        if (inf(dom) * sup(dom) < 0) then {
           splitpoints = [| D(inf(dom) / 3), D(sup(dom) / 3) |];
        } else {
           splitpoints = [| D(mid(dom)) |];
        };
        doElseCase = true;
            resultat = { .okay = false };
         };
      };

      if (doElseCase) then {
      /* To start with, check if all splitPoints are doubles and
             if they are contained in the given domain
          */
      okay = true;
      for sp in splitPoints do {
          okay = okay && ((D(sp) - sp == 0) && (sp in dom));
      };
      if (okay) then {
         /* Now sort the split points by increasing order,
         adding the bounds to the list */
         mySplitPoints = sort(splitPoints @ [| inf(dom), sup(dom) |]);

         /* While we succeed in implementing the subdomains,
            cut out a new subdomain, generate function and
        file names and try implementation.
             */
         approxerr = 0;
         implerr = 0;
         outputformats = [||];
         functionNames = [||];
         domains = [||];
         implementationFiles = [||];
         numberSplitPoints = length(mySplitPoints);
         myDomains = [||];
         for i from 0 to numberSplitPoints - 2 do {
             myDomains = myDomains :. ( [ mySplitPoints[i], mySplitPoints[i + 1] ] );
         };
         i = 0;
         while ((okay) && (myDomains != [||])) do {
               myDom = head(myDomains);
           myDomains = tail(myDomains);
           write("\nStarting implementation on subdomain ",myDom,"\n");
           mySuffix = "_subdomain_" @ i ;
           myImplementationFile = implementationFile @ mySuffix;
           res = implementsmallwithcentering(func, myDom, target, beta, variableFormat, myImplementationFile, gappaFile @ mySuffix, gappaOutputFile @ mySuffix, gappaExecutable, polynomialBaseName @ mySuffix, definitionDomain);
           if (res.okay) then {
                 write("Subdomain ",myDom," done\n");
                 domains = domains :. myDom;
                 implementationFiles = implementationFiles :. myImplementationFile;
             approxerr = max(approxerr, abs(res.approxerr));
             implerr = max(implerr, abs(res.implerr));
             outputformats = outputformats :. (res.outputformat);
             functionNames = functionNames :. (res.functionname);
             i := i + 1;
           } else {
             if (abs(sup(myDom) - inf(myDom)) < minWidth) then {
                write("Error on subdomain ",myDom,", the minimal domain width is too large\n");
                okay = false;
                 } else {
                recovered = false;
                symmetrizedDom = myDom;
            if (inf(myDom) == 0) then {
               symmetrizedDom = [-sup(myDom),sup(myDom)+1b-1076];
            };
            if (sup(myDom) == 0) then {
               symmetrizedDom = [inf(myDom),-inf(myDom)+1b-1076];
            };
            if ((inf(myDom) == 0) || (sup(myDom) == 0)) then {
               if ((symmetrizedDom in definitionDomain) && ((abs(target) < 1b-51) || (abs(sup(myDom) - inf(myDom)) < 4 * minWidth))) then {
                  write("Using symmetrized domain around 0 instead of original domain to exploit symmetries of the function\n");
                  res = implementsmallwithcentering(func, symmetrizedDom, target, beta, variableFormat, myImplementationFile, gappaFile @ mySuffix, gappaOutputFile @ mySuffix, gappaExecutable, polynomialBaseName @ mySuffix, definitionDomain);
                          if (res.okay) then {
                         write("Subdomain ",myDom," done\n");
                         domains = domains :. myDom;
                         implementationFiles = implementationFiles :. myImplementationFile;
                     approxerr = max(approxerr, abs(res.approxerr));
                     implerr = max(implerr, abs(res.implerr));
                     outputformats = outputformats :. (res.outputformat);
                     functionNames = functionNames :. (res.functionname);
                     i := i + 1;
                 recovered = true;
                      };
               };
            };

            if (!recovered) then {
               write("Resplitting on subdomain ",myDom,"\n");
               oP = prec;
               prec = max(300, prec)!;
                   if (inf(myDom) * sup(myDom) < 0) then {
                  myDomains = [ inf(myDom) , D(inf(myDom) / 3) ] .: ( [ D(inf(myDom) / 3) , D(sup(myDom) / 3) ] .: ( [ D(sup(myDom) / 3) , sup(myDom) ] .: myDomains ));
               } else {
                  myDomains = [ inf(myDom) , D(mid(myDom)) ] .: ( [ D(mid(myDom)) , sup(myDom) ] .: myDomains );
               };
               prec = oP!;
            };
             };
           };
         };

         /* Now generate the argument reduction code if
            we succeeded in generating code for all
        subdomains and combine all files.
             */
         if (okay) then {
            oldDisplay = display;
        display = dyadic!;
            write("\n\n") > implementationFile;
                display = oldDisplay!;
        for implFile in implementationFiles do {
            bashexecute("cat " @ implFile @ " >> " @ implementationFile);
            bashexecute("rm " @ implFile);
        };
        write("\n\n") >> implementationFile;
        myOutputFormatNum = 1;
        for opF in outputformats do {
            myOutputFormatNum = max(myOutputFormatNum,
                                            match opF with
                                                  D  : (1)
                                                  DD : (2)
                                                  TD : (3)
                                                  default : { okay = false; return 0; });
        };
        if (okay) then {
           myOutputFormat = match myOutputFormatNum with 1 : (D) 2 : (DD) 3 : (TD);
                   myFunctionName = polynomialBaseName @ "_splitter";
           splitterCode = "\n\n";
           resOpt.okay = false;
           if (checkIfElementsInListAllEqual(outputformats) && (outputformats != [||]) && (length(domains) >= 2) && (length(domains) <= maxDegreeReconst + 1) && (variableFormat == D)) then {
              if (head(outputformats) == myOutputFormat) then {
                 resOpt = tryGeneratePolynomialSplitterReconstruction(myFunctionName, domains, functionNames, variableFormat, myOutputFormat, implementationFile @ ".splitter.temp.c", maxDegreeReconst);
              };
           };
           if (resOpt.okay) then {
              splitterCode = splitterCode @ resOpt.code @ "\n\n";
              write(splitterCode) >> implementationFile;
           } else {
               recursiveSplitterRes = generateRecursiveSplitter(myFunctionName, domains, functionNames, outputformats, variableFormat, myOutputFormat);
               if (!recursiveSplitterRes.okay) then okay = false;
               if (okay) then {
                    splitterCode = splitterCode @ recursiveSplitterRes.defines;
                            splitterCode = splitterCode @ "\n\nvoid "@myFunctionName@"(";
                        splitterCode = splitterCode @ (match myOutputFormat with
                                                             D   : ( "double *res_resh, " )
                                                                 DD  : ( "double *res_resh, double *res_resm, " )
                                                                 TD  : ( "double *res_resh, double *res_resm, double *res_resl, " )
                                                          );
                            splitterCode = splitterCode @ (match variableFormat with
                                                                 D   : ( "double xh" )
                                                                 DD  : ( "double xh, double xm" )
                                                                 TD  : ( "double xh, double xm, double xl" )
                                                          );
                            splitterCode = splitterCode @ ") {\n";
                    splitterCode = splitterCode @ recursiveSplitterRes.splitterCode;
                            splitterCode = splitterCode @ "}\n\n";
                    write(splitterCode) >> implementationFile;
                       };
                   };
           if (okay) then {
              resultat.okay = true;
              resultat.approxerr = approxerr;
              resultat.implerr = implerr;
              resultat.outputformat = myOutputFormat;
              resultat.functionname = myFunctionName;
           };
        };
         };
      };
      };

      return resultat;
};

/* Compute an ordered list of points x_i in the given domain dom, such that
   on all subdomains S_i created by these splitpoints func can be approximated
   with a relative error no greater than target with polynomials of degree no
   greater than maxDegree. All subdomains S_i are larger in width than minWidth.

   In case of failure (no such splitting exists), return a structure containing
   an element .okay that is equal to false.

   In case of success (a splitting has been found), return a structure containing
   an element .okay that is equal to true and an element .splitPoints that is
   a list of the points x_i described above.

   Attention:

   - the list of points x_i must be ordered by increasing values
   - the x_i must be representable in double precision
   - the points in the list must be unique (there is no i != j, such that x_i = x_j)
   - the points must be in the interior of the given domain

   The list of split points that is returned may be empty iff the given function func
   can be approximated with a target error target using a polynomial of degree no greater
   that maxDegree on the whole domain dom.

   This special purpose procedure does not have to care about the
   Sterbenz condition to be fullfilled for the substraction to be
   performed on each subdomain S_i for range reduction.

   The purpose and particularity of this special procedure is to split the domain
   in such a way that the degree of the polynomials used on each subdomain is
   maximal, i.e. that the subdomains are of maximum width.

   The splitting to be returned is supposed to be optimized for that specificity.

   However, the procedure is not supposed to find an optimal splitting. This means
   greedy algorithms and heuristics are allowed if they are well explained.

   As the procedure will be called on almost every instance of a metalibm run,
   it should be pretty fast, even if this means that some opportunities for
   optimizing the split points are left aside.

*/
procedure computeDomainSplittingOptimized(func, dom, maxDegree, target, minWidth) {

      var res;
      var r, a, b, c, d, found, okay, runs;

      res = {.okay = false};

      r = checkIfSufficientDegreeOptimized(func, dom, maxDegree, target);
      if (r.okay) then {
         if (r.sufficientDegree) then {
            res.okay = true;
        res.splitPoints = [||];
        res.deg = [| r.deg |];
         } else {
            if (sup(dom) - inf(dom) >= minWidth) then {
           a = inf(dom);
           b = D(mid(dom));
           c = sup(dom);
           okay = true;
           found = false;
           while (okay && (!found)) do {
             if ((abs(b - a) < minWidth) ||
                 (b <= a) ||
                 (c <= a) ||
                 (b >= c)) then {
                okay = false;
             } else {
                r = checkIfSufficientDegreeOptimized(func, [a, b], maxDegree, target);
                if (!r.okay) then {
                   okay = false;
                } else {
                   if (r.sufficientDegree) then {
                      found = true;
                   } else {
                      c = b;
                  b = D((a + b) / 2);
                   };
                };
             };
           };
           if (okay && found) then {
              /* [a; b] works, [a; c] does not work */
              okay = true;
              runs = 7;
              d = D((b + c) / 2);
              while (okay && (runs > 0)) do {
                if ((abs(d - a) < minWidth) ||
                    (d <= a) ||
                    (d <= b) ||
                    (d >= c) ||
                (b <= a) ||
                (b >= c) ||
                (b >= d)) then {
                   okay = false;
                } else {
                   runs = runs - 1;
                   r = checkIfSufficientDegreeOptimized(func, [a, d], maxDegree, target);
                   if (!r.okay) then {
                       okay = false;
                   } else {
                     if (r.sufficientDegree) then {
                    b = d;
                    d = D((b + c) / 2);
                 } else {
                    c = d;
                    d = D((b + c) / 2);
                 };
                   };
                };
              };
              if (okay) then {
                 /* [a; b] works */
             b = round(b, double, RD);
             if ((a < b) && (b < sup(dom))) then {
                r = checkIfSufficientDegreeOptimized(func, [a, b], maxDegree, target);
                if (r.okay) then {
                   if (r.sufficientDegree) then {
                      rr = computeDomainSplittingOptimized(func, [b, sup(dom)], maxDegree, target, minWidth);
                  if (rr.okay) then {
                                     res.okay = true;
                                     res.splitPoints = b .: (rr.splitPoints);
                                     res.deg = (r.deg) .: (rr.deg);
                  };
                   };
                };
             };
              };
           };
        };
         };
      };

      return res;
};


procedure computeDomainSplitting(func, dom, maxDegree, target, minWidth, sterbenzNeeded) {
      var resultat;
      var poly;
      var deg;
      var subdomains, splitpoints, aSp, bSp, sd;
      var res, recursiveSplitPoints, y, guess;
      var midpoint;
      var remezFunc, remezDom;
      var zeros, t, z;
      var oldDisplay;
      var resOpt;
      var oldPrec;

      resultat = { .okay = false };
      deg = -1;

      resOpt = { .okay = false };

      if (abs(sup(dom) - inf(dom)) - minWidth >= 0) then {

      if (((!((0 in dom) || (0 in [inf(dom) - min(1b-1023, 2 * inf(abs(dom))); sup(dom) + min(1b-1023, 2 * inf(abs(dom)))]))) &&
          (!(dom in [(mid(dom) * 100)/199;(mid(dom)*199)/100]))) && sterbenzNeeded) then {
          /* We have to split because the Sterbenz condition will
             not be fulfilled for center points on this subdomain

         We simultate the case with a dummy degree that is too huge
           */
           deg = maxDegree * 2;
      } else {

      if ((!(inf(dom) * sup(dom) < 0)) || (!sterbenzNeeded)) then {
          resOpt = computeDomainSplittingOptimized(func, dom, maxDegree, target, minWidth);
      };

      if (!resOpt.okay) then {

      remezFunc = func;
      remezDom = dom;
      if (sup(evaluate(func, [inf(dom)]) * evaluate(func, [sup(dom)])) < 0) then {
             if (0 in remezDom) then { y = evaluate(func, 0); } else { y = 1; };
         if (!((inf(y) <= 0) && (sup(y) >= 0))) then {
            /* func has a zero in dom but not in 0 */
        zeros = mydirtyfindzeros(func, dom);
        if (zeros != [||]) then {
           /* I found zeros of func in dom,
              let's look for the zero farthest
              from 0
           */
           t = zeros[0];
           for z in zeros do {
               if (abs(z) > abs(t)) then t = z;
           };
           /* Now translate the function so
              that it has a zero in 0
                   */
           remezFunc = func(x + t);
           oldPrec = prec;
           prec = max(300, prec)!;
           remezDom = dom - t;
           prec = oldPrec!;
        };
         };
      };

      if (0 in remezDom) then { y = evaluate(remezFunc, 0); } else { y = 1; };
      if ((inf(y) <= 0) && (sup(y) >= 0)) then {
         { guess = guessdegreewrapperwithbound(1,remezDom,abs(target),x/remezFunc,maxDegree+2); };
         guess = guess + 1;
      } else {
         { guess = guessdegreewrapperwithbound(1,remezDom,abs(target),1/remezFunc,maxDegree+2); };
      };

      if ((guess == guess) && (guess != false)) then {
              deg = inf(guess);
      } else {
          write("Computing a remez polynomial for ", func, " in ", dom, " with target ", target,"\n");
          poly = simpleRemezWrapper(remezFunc, remezDom, target, 3);
          if ((poly == poly) && (poly != false)) then {
             deg = degree(poly);
          };
          };

      };

      };

      if (resOpt.okay) then {
         resultat = resOpt;
      } else {
         if (deg >= 0) then {
            if (deg <= maxDegree) then {
           resultat.okay = true;
           resultat.splitPoints = [||];
        } else {
           if (inf(dom) * sup(dom) < 0) then {
              aSp = D(inf(dom)/3);
              bSp = D(sup(dom)/3);
              splitpoints = [| aSp , bSp |];
              subdomains = [| [ inf(dom) , aSp ], [ aSp, bSp ], [ bSp, sup(dom) ] |];
           } else {
              aSp = D(mid(dom));
              splitpoints = [| aSp |];
              subdomains = [| [ inf(dom), aSp ], [ aSp, sup(dom) ] |];
           };
           okay = true;
           recursiveSplitPoints = [||];
           while ((okay) && (subdomains != [||])) do {
             sd = head(subdomains);
             subdomains = tail(subdomains);
             res = computeDomainSplitting(func, sd, maxDegree, target, minWidth, sterbenzNeeded);
             if (res.okay) then {
                recursiveSplitPoints = recursiveSplitPoints @ (res.splitPoints);
             } else {
               okay = false;
             };
           };
           if (okay) then {
              resultat.okay = true;
              resultat.splitPoints = recursiveSplitPoints @ splitpoints;
           };
            };
         };

      };

      };

      return resultat;
};

procedure checkIfPropagatedErrorLessThan(func, dom, argEps, maxEps) {
      var a, b, sa, sb, st, subdom;
      var im, eps;
      var fp;
      var okay;

      fp = diff(func);

      a = inf(dom);
      b = sup(dom);
      st = (b-a)/100;

      sa = a;
      sb = sa + st;
      okay = true;
      while (okay && (sb <= b)) do {
          subdom = [round(sa, max(300, prec), RD); round(sb, max(300, prec), RU)];
          im = subdom * argEps * evaluate(fp, subdom) / evaluate(func, subdom);
          eps = sup(abs(im));
          if (eps > abs(maxEps)) then {
             okay = false;
          };
          sa = sb;
          sb = sb + st;
      };

      return okay;
};

/* implements a function by polynomial approximation in small intervals
   that are automatically computed using a maximum polynomial degree
   indication

   Returns a structure that

     - always contains an element okay which is true if everything is fine
       respectively false if some error happened
     - contains, if everything is fine, the following elements
          * approxerr    the maximum approximation error
          * implerr      the maximum implementation (round-off) error
          * outputformat the D/DD/TD format the result is produced in
          * functionname the eventual name of the function after argument
                         reduction

   The function to be implemented may have at most 1 zero in each sub-domain.
   No test for this condition is made.

*/
procedure implementwithdomainsplitting(func, dom, maxDegree, minWidth, definitionDomain, target, beta, variableFormat, implementationFile, gappaFile, gappaOutputFile, gappaExecutable, polynomialBaseName, maxDegreeReconst) {
      var resultat, res, splitPoints, myTarget, sterbenzNeeded, shiftEps, currDom, currDeg;

      /* write("implementwithdomainsplitting(",func,",", dom,",", maxDegree,",", minWidth,",", definitionDomain,",", target,",", beta,",", variableFormat,",", implementationFile,",", gappaFile,",", gappaOutputFile,",", gappaExecutable,",", polynomialBaseName,",", maxDegreeReconst, ")\n"); */

      sterbenzNeeded = true;
      myTarget = target;

      /* Check if we actually need to enforce Sterbenz condition
         on the sub-domain midpoints.
      */

      if ((variableFormat == D) &&
          (abs(target) > 1b-50) &&
          ((!(0 in dom)) &&
          (!(dom in [(mid(dom) * 100)/199;(mid(dom)*199)/100])))) then {
          /* First do a quick check if the perturbation affects the error by no more than a
             quarter of the target error
              */
          if (checkIfPropagatedErrorLessThan(func, dom, 1b-53, 1/4 * abs(target))) then {
                 sterbenzNeeded = false;
             myTarget = 1/4 * abs(target);
          } else {
              /* Bound the amount of final error added when adding one double precision
                     rounding-error upon shifting
              */
              shiftEps = abs(1b-53 * computeAmplification(func,dom,1b-53));

              /* If that shifting error and a quarter of the target
                 error combined are less than the target error, do no longer
             try to get Sterbenz condition fullfilled.
                  */
              if (shiftEps + 1/4 * abs(target) + shiftEps * 1/4 * abs(target) <= abs(target)) then {
                 sterbenzNeeded = false;
             myTarget = 1/4 * abs(target);
              };
              };
          };

      /* In certain cases, the function so well contracts the relative error
         than even if zero is in the domain we can afford an extra reduction error.
      */
      if (sterbenzNeeded) then {
         if (checkIfPropagatedErrorLessThan(func, dom, 1b-53, 1/4 * abs(target))) then {
             sterbenzNeeded = false;
         myTarget = 1/4 * abs(target);
         };
      };

      resultat = { .okay = false };

      res = computeDomainSplitting(func, dom, maxDegree, myTarget, minWidth, sterbenzNeeded);

      if (res.okay) then {
         splitPoints = sort(res.splitPoints);

         write("The domain will first be split at the following points(", length(splitPoints) + 1, "): ", splitPoints, "\n");

         res = implementwithdomainsplitlist(func, dom, splitPoints, minWidth, definitionDomain, myTarget, beta, variableFormat, implementationFile, gappaFile, gappaOutputFile, gappaExecutable, polynomialBaseName, maxDegreeReconst);

         if (res.okay) then {
            resultat = res;
         };

      } else {
        write("Could not compute a domain splitting\n");
      };

      return resultat;
};


procedure tryImplementationThroughDomainSplitting(problemdef, parametrization) {
      var result, definitionDomain;

      result = { .okay = false };

      match ( { .problemdef = problemdef,
                    .parametrization = parametrization } ) with
                { .problemdef =      { .func = default,
                                       .dom = default,
                                       .target = default,
                                       .variableFormat = default },
                  .parametrization = { .maxDegree = default,
                                       .minWidth = default,
                                       .beta = default,
                           .implementationFile = default,
                                       .gappaFile = default,
                                       .gappaOutputFile = default,
                                       .gappaExecutable = default,
                       .functionBasename = default } } : {
                                definitionDomain = problemdef.dom;
                        match (problemdef) with
                                                      { .definitionDomain = default } : { definitionDomain = problemdef.definitionDomain; }
                                                      default : { };
                            result = implementwithdomainsplitting(problemdef.func,
                                                              problemdef.dom,
                                                                                      parametrization.maxDegree,
                                                                                      parametrization.minWidth,
                                              definitionDomain,
                                                                                      problemdef.target,
                                                                                      parametrization.beta,
                                                                                      problemdef.variableFormat,
                                                                                      parametrization.implementationFile,
                                              parametrization.gappaFile,
                                              parametrization.gappaOutputFile,
                                              parametrization.gappaExecutable,
                                              parametrization.functionBasename,
                                              parametrization.maxDegreeReconstruction);
                    }
                default : { };

      return result;
};

procedure checkIfSufficientDegreeInner(func, dom, maxDegree, target, sterbenzNeeded) {
      var resultat;
      var poly;
      var deg;
      var y, guess;
      var remezFunc, remezDom;
      var zeros, t, z;

      // "checkIfSufficientDegreeInner(",func,",", dom,",", maxDegree,",", target,",", sterbenzNeeded,") started";

      resultat = { .okay = false };
      deg = -1;

      if (((!(0 in dom)) &&
          (!(dom in [(mid(dom) * 100)/199;(mid(dom)*199)/100]))) &&
          sterbenzNeeded) then {
          /* We have to split because the Sterbenz condition will
             not be fulfilled for center points on this subdomain

         We simultate the case with a dummy degree that is too huge
           */
           deg = maxDegree * 2;

      } else {

      remezFunc = func;
      remezDom = dom;
      if (sup(evaluate(func, [inf(dom)]) * evaluate(func, [sup(dom)])) < 0) then {
             if (0 in remezDom) then { y = evaluate(func, 0); } else { y = 1; };
         if (!((inf(y) <= 0) && (sup(y) >= 0))) then {
            /* func has a zero in dom but not in 0 */
        zeros = mydirtyfindzeros(func, dom);
        if (zeros != [||]) then {
           /* I found zeros of func in dom,
              let's look for the zero farthest
              from 0
           */
           t = zeros[0];
           for z in zeros do {
               if (abs(z) > abs(t)) then t = z;
           };
           /* Now translate the function so
              that it has a zero in 0
                   */
           remezFunc = func(x + t);
           oldPrec = prec;
           prec = max(300, prec)!;
           remezDom = dom - t;
           prec = oldPrec!;
        };
         };
      };

      if (0 in remezDom) then { y = evaluate(remezFunc, 0); } else { y = 1; };

      if ((inf(y) <= 0) && (sup(y) >= 0)) then {
         { guess = guessdegreewrapperwithbound(1,remezDom,abs(target),x/remezFunc,maxDegree+2); };
         guess = guess + 1;
      } else {
         { guess = guessdegreewrapperwithbound(1,remezDom,abs(target),1/remezFunc,maxDegree+2); };
      };

      if ((guess == guess) && (guess != false)) then {
              deg = inf(guess);
      } else {
          write("Computing a remez polynomial for ", func, " in ", dom, " with target ", target,"\n");
          poly = simpleRemezWrapper(remezFunc, remezDom, target, 3);
          if ((poly == poly) && (poly != false)) then {
             deg = degree(poly);
          };
          };
      };

         if (deg >= 0) then {
            if (deg <= maxDegree) then {
           resultat.okay = true;
           resultat.sufficientDegree = true;
           resultat.deg = deg;
        } else {
           resultat.okay = true;
           resultat.sufficientDegree = false;
            };
         };

      return resultat;
};

procedure checkIfSufficientDegree(func, dom, maxDegree, target) {
      return checkIfSufficientDegreeInner(func, dom, maxDegree, target, true);
};

procedure checkIfSufficientDegreeOptimized(func, dom, maxDegree, target) {
      return checkIfSufficientDegreeInner(func, dom, maxDegree, target, false);
};

procedure tryDetectSymmetry(func, dom, target) {
      var res, testfunc, zerosUpper, zerosLower, myDom, yA, yB;

      res = { .okay = false };

      myDom = [0; min(sup(dom), -inf(dom))];
      testfunc = simplifysafe((func/(func(-x))) - 1);
      yA = evaluate(testfunc + target, min(sup(dom), -inf(dom)) / 2);
      yB = evaluate(testfunc - target, min(sup(dom), -inf(dom)) / 2);
      if ((inf(yA) > 0) && (sup(yB) < 0)) then {
          zerosUpper = mydirtyfindzeros(testfunc + target, myDom);
          zerosLower = mydirtyfindzeros(testfunc - target, myDom);
          } else {
              zerosUpper = [| 0 |];
          zerosLower = [| 0 |];
      };

      if ((zerosUpper == [||]) && (zerosLower == [||])) then {
         res.okay = true;
         res.evenSymmetry = true;
      } else {
         testfunc = simplifysafe((func/(-func(-x))) - 1);
         yA = evaluate(testfunc + target, min(sup(dom), -inf(dom)) / 2);
         yB = evaluate(testfunc - target, min(sup(dom), -inf(dom)) / 2);
         if ((inf(yA) > 0) && (sup(yB) < 0)) then {
          zerosUpper = mydirtyfindzeros(testfunc + target, myDom);
          zerosLower = mydirtyfindzeros(testfunc - target, myDom);
             } else {
              zerosUpper = [| 0 |];
          zerosLower = [| 0 |];
         };

         if ((zerosUpper == [||]) && (zerosLower == [||])) then {
            res.okay = true;
            res.evenSymmetry = false;
         };
      };

      return res;
};

procedure tryImplementationThroughSymmetryDetectionAroundZero(problemdef, parametrization) {
      var result, splitPoints, needToDetectSymmetry, res, evenSymmetry, myDom, oppositeOnNegative;
      var suffix, myProblemdef, myParametrization, origDefDom, symmetryCode, dom;

      result = { .okay = false };

      match ( { .problemdef = problemdef,
                    .parametrization = parametrization } ) with
                { .problemdef =      { .func = default,
                                       .dom = default,
                                       .target = default,
                                       .variableFormat = default },
                  .parametrization = { .maxDegree = default,
                                       .minWidth = default,
                                       .beta = default,
                           .implementationFile = default,
                                       .gappaFile = default,
                                       .gappaOutputFile = default,
                                       .gappaExecutable = default,
                       .functionBasename = default } } : {

                       dom = problemdef.dom;

                       /* Start with a test if zero is actually inside the domain */
                       if (sup(problemdef.dom) * inf(problemdef.dom) < 0) then {

                       /* Continue with a test if the domain actually needs
                                          to be split in order to stay below the maximum
                      polynomial degree
                        */
                       needToDetectSymmetry = true;
                       res = checkIfSufficientDegree(problemdef.func, problemdef.dom, parametrization.maxDegree, problemdef.target);

                                       if (res.okay) then {
                                       if (res.sufficientDegree) then needToDetectSymmetry = false;
                       } else {
                           needToDetectSymmetry = false;
                       };

                       if (needToDetectSymmetry) then {

                            /* Try to detect a symmetry of func around 0 */
                        res = tryDetectSymmetry(problemdef.func, problemdef.dom, problemdef.target * 13/32);

                        if (res.okay) then {
                           /* If we detected a symmetry */
                           if (res.evenSymmetry) then {
                              write("Detected an even symmetry\n");
                           } else {
                              write("Detected an odd symmetry\n");
                           };
                           /* Now compute the reduced domain and determine
                              when we have to compute the opposite of the argument.
                           */
                                               if (-inf(dom) < sup(dom)) then {
                               myDom = [ 0, sup(dom) ];
                           oppositeOnNegative = true;
                           } else {
                               myDom = [ inf(dom), 0 ];
                           oppositeOnNegative = false;
                           };
                           evenSymmetry = res.evenSymmetry;
                           write("The subdomain after range reduction for symmetry is: ", myDom, "\n");

                           /* Now call the implementer recursively on the reduced domain */
                           suffix = "_symmetrical";
                           myProblemdef = problemdef;
                           myProblemdef.dom = myDom;
                           myProblemdef.target = problemdef.target * 13/32;
                           origDefDom = dom;
                           match (problemdef) with { .definitionDomain = default } : {
                                           if (origDefDom in problemdef.definitionDomain) then {
                                                                  origDefDom = problemdef.definitionDomain;
                                                               }; }
                                                                       default : {};
                           myProblemdef.definitionDomain = origDefDom;
                           myParametrization = parametrization;
                           myParametrization.gappaFile = parametrization.gappaFile @ suffix;
                           myParametrization.gappaOutputFile = parametrization.gappaOutputFile @ suffix;
                           myParametrization.functionBasename = parametrization.functionBasename @ suffix;
                           myParametrization.minWidth = (sup(myDom) - inf(myDom)) * (parametrization.minWidth / (sup(problemdef.dom) - inf(problemdef.dom)));
                           myParametrization.argumentReduced = true;

                           res = tryImplementation(myProblemdef, myParametrization);

                           if (res.okay) then {
                              /* The implementation worked on the subdomain

                             Now generate the reduction code.

                          */
                          symmetryCode = "";
                          symmetryCode = symmetryCode @ "\n\nvoid "@parametrization.functionBasename@"(";
                          symmetryCode = symmetryCode @ (match res.outputformat with
                                                                                   D   : ( "double *res_resh, " )
                                                                                       DD  : ( "double *res_resh, double *res_resm, " )
                                                                                       TD  : ( "double *res_resh, double *res_resm, double *res_resl, " )
                                                                                );
                                                  symmetryCode = symmetryCode @ (match problemdef.variableFormat with
                                                                                       D   : ( "double xh" )
                                                                                       DD  : ( "double xh, double xm" )
                                                                                       TD  : ( "double xh, double xm, double xl" )
                                                                                );
                                                  symmetryCode = symmetryCode @ ") {\n";
                          if (evenSymmetry) then {
                             if (oppositeOnNegative) then {
                                symmetryCode = symmetryCode @ "if (xh < 0.0) {\n";
                                                        symmetryCode = symmetryCode @ res.functionname @ "(";
                                symmetryCode = symmetryCode @ (match res.outputformat with
                                                                                         D   : ( "res_resh, " )
                                                                                             DD  : ( "res_resh, res_resm, " )
                                                                                             TD  : ( "res_resh, res_resm, res_resl, " )
                                                                                      );
                                                        symmetryCode = symmetryCode @ (match problemdef.variableFormat with
                                                                                             D   : ( "-xh" )
                                                                                             DD  : ( "-xh, -xm" )
                                                                                             TD  : ( "-xh, -xm, -xl" )
                                                                                );
                            symmetryCode = symmetryCode @ ");\n";
                                symmetryCode = symmetryCode @ "} else {\n";
                                                        symmetryCode = symmetryCode @ res.functionname @ "(";
                                symmetryCode = symmetryCode @ (match res.outputformat with
                                                                                         D   : ( "res_resh, " )
                                                                                             DD  : ( "res_resh, res_resm, " )
                                                                                             TD  : ( "res_resh, res_resm, res_resl, " )
                                                                                      );
                                                        symmetryCode = symmetryCode @ (match problemdef.variableFormat with
                                                                                             D   : ( "xh" )
                                                                                             DD  : ( "xh, xm" )
                                                                                             TD  : ( "xh, xm, xl" )
                                                                                );
                            symmetryCode = symmetryCode @ ");\n";
                            symmetryCode = symmetryCode @ "}\n";
                             } else {
                                symmetryCode = symmetryCode @ "if (xh > 0.0) {\n";
                                                        symmetryCode = symmetryCode @ res.functionname @ "(";
                                symmetryCode = symmetryCode @ (match res.outputformat with
                                                                                         D   : ( "res_resh, " )
                                                                                             DD  : ( "res_resh, res_resm, " )
                                                                                             TD  : ( "res_resh, res_resm, res_resl, " )
                                                                                      );
                                                        symmetryCode = symmetryCode @ (match problemdef.variableFormat with
                                                                                             D   : ( "-xh" )
                                                                                             DD  : ( "-xh, -xm" )
                                                                                             TD  : ( "-xh, -xm, -xl" )
                                                                                );
                            symmetryCode = symmetryCode @ ");\n";
                                symmetryCode = symmetryCode @ "} else {\n";
                                                        symmetryCode = symmetryCode @ res.functionname @ "(";
                                symmetryCode = symmetryCode @ (match res.outputformat with
                                                                                         D   : ( "res_resh, " )
                                                                                             DD  : ( "res_resh, res_resm, " )
                                                                                             TD  : ( "res_resh, res_resm, res_resl, " )
                                                                                      );
                                                        symmetryCode = symmetryCode @ (match problemdef.variableFormat with
                                                                                             D   : ( "xh" )
                                                                                             DD  : ( "xh, xm" )
                                                                                             TD  : ( "xh, xm, xl" )
                                                                                );
                            symmetryCode = symmetryCode @ ");\n";
                            symmetryCode = symmetryCode @ "}\n";
                             };
                          } else {
                             symmetryCode = symmetryCode @ (match res.outputformat with
                                                                                      D   : ( "double sym_res_resh;" )
                                                                                          DD  : ( "double sym_res_resh, sym_res_resm;" )
                                                                                          TD  : ( "double sym_res_resh, sym_res_resm, sym_res_resl;" )
                                                                                   );
                             symmetryCode = symmetryCode @ "\n";
                             if (oppositeOnNegative) then {
                                symmetryCode = symmetryCode @ "if (xh < 0.0) {\n";
                                                        symmetryCode = symmetryCode @ res.functionname @ "(";
                                symmetryCode = symmetryCode @ (match res.outputformat with
                                                                                         D   : ( "&sym_res_resh, " )
                                                                                             DD  : ( "&sym_res_resh, &sym_res_resm, " )
                                                                                             TD  : ( "&sym_res_resh, &sym_res_resm, &sym_res_resl, " )
                                                                                      );
                                                        symmetryCode = symmetryCode @ (match problemdef.variableFormat with
                                                                                             D   : ( "-xh" )
                                                                                             DD  : ( "-xh, -xm" )
                                                                                             TD  : ( "-xh, -xm, -xl" )
                                                                                );
                            symmetryCode = symmetryCode @ ");\n";
                                symmetryCode = symmetryCode @ (match res.outputformat with
                                                                                         D   : ( "*res_resh = -sym_res_resh;" )
                                                                                             DD  : ( "*res_resh = -sym_res_resh; *res_resm = -sym_res_resm;" )
                                                                                             TD  : ( "*res_resh = -sym_res_resh; *res_resm = -sym_res_resm; *res_resl = -sym_res_resl;" )
                                                                                      );
                                symmetryCode = symmetryCode @ "\n";
                                symmetryCode = symmetryCode @ "} else {\n";
                                                        symmetryCode = symmetryCode @ res.functionname @ "(";
                                symmetryCode = symmetryCode @ (match res.outputformat with
                                                                                         D   : ( "res_resh, " )
                                                                                             DD  : ( "res_resh, res_resm, " )
                                                                                             TD  : ( "res_resh, res_resm, res_resl, " )
                                                                                      );
                                                        symmetryCode = symmetryCode @ (match problemdef.variableFormat with
                                                                                             D   : ( "xh" )
                                                                                             DD  : ( "xh, xm" )
                                                                                             TD  : ( "xh, xm, xl" )
                                                                                );
                            symmetryCode = symmetryCode @ ");\n";
                            symmetryCode = symmetryCode @ "}\n";
                             } else {
                                symmetryCode = symmetryCode @ "if (xh > 0.0) {\n";
                                                        symmetryCode = symmetryCode @ res.functionname @ "(";
                                symmetryCode = symmetryCode @ (match res.outputformat with
                                                                                         D   : ( "&sym_res_resh, " )
                                                                                             DD  : ( "&sym_res_resh, &sym_res_resm, " )
                                                                                             TD  : ( "&sym_res_resh, &sym_res_resm, &sym_res_resl, " )
                                                                                      );
                                                        symmetryCode = symmetryCode @ (match problemdef.variableFormat with
                                                                                             D   : ( "-xh" )
                                                                                             DD  : ( "-xh, -xm" )
                                                                                             TD  : ( "-xh, -xm, -xl" )
                                                                                );
                            symmetryCode = symmetryCode @ ");\n";
                                symmetryCode = symmetryCode @ (match res.outputformat with
                                                                                         D   : ( "*res_resh = -sym_res_resh;" )
                                                                                             DD  : ( "*res_resh = -sym_res_resh; *res_resm = -sym_res_resm;" )
                                                                                             TD  : ( "*res_resh = -sym_res_resh; *res_resm = -sym_res_resm; *res_resl = -sym_res_resl;" )
                                                                                      );
                                symmetryCode = symmetryCode @ "\n";
                                symmetryCode = symmetryCode @ "} else {\n";
                                                        symmetryCode = symmetryCode @ res.functionname @ "(";
                                symmetryCode = symmetryCode @ (match res.outputformat with
                                                                                         D   : ( "res_resh, " )
                                                                                             DD  : ( "res_resh, res_resm, " )
                                                                                             TD  : ( "res_resh, res_resm, res_resl, " )
                                                                                      );
                                                        symmetryCode = symmetryCode @ (match problemdef.variableFormat with
                                                                                             D   : ( "xh" )
                                                                                             DD  : ( "xh, xm" )
                                                                                             TD  : ( "xh, xm, xl" )
                                                                                );
                            symmetryCode = symmetryCode @ ");\n";
                            symmetryCode = symmetryCode @ "}\n";
                             };
                          };
                          symmetryCode = symmetryCode @ "}\n";
                          write(symmetryCode) >> parametrization.implementationFile;
                          result = res;
                          result.functionname = parametrization.functionBasename;
                           };
                        };
                       };
                       };
                     }
                default : { };

      return result;
};

procedure tryDetectExponentialArgRed(func, dom, target) {
      var result, base, a, b, c, d, ratio, oldPrec, testfunc;
      var y, zerosUpper, zerosLower;

      result = { .okay = false };

      /* We have to detect if func behaves in dom
         like

         base^x for some unknown base

         We say that func behaves like base^x
         if

         base^x = func * (1 + eps) with abs(eps) <= target.

         We start by computing a possible base
         as

         base = exp((log(f(c+d)/f(c))/d))

         with

           - d = b - a                  if b - a < 5
             c = a

           - d = 5                      otherwise
                 c = max(a, (a+b)/2 - 2.5)

             where dom = [a;b]

         We can stop trying if f(c+d)/f(c) is
         negative.
      */
      a = inf(dom);
      b = sup(dom);
      if ((0 in dom) && (max(-a,b) > 5))then {
         if (-a > b) then {
            c = -5;
        d = 5;
         } else {
            c = 0;
        d = 5;
         };
      } else {
          if (b - a < 5) then {
             d = b - a;
             c = a;
          } else {
                 d = 5;
                 c = max(a, (a + b)/2 - 2.5);
              };
      };
      if (0 in func([c])) then {
         ratio = -1;
      } else {
         ratio = func(c + d) / func(c);
      };

      if (~ratio > 0) then {
         /* Here, f(c + d) / f(c) is positive

            So we can compute a presumed base
        as

        base = exp(log(ratio)/d)

        where ratio = f(c + d) / f(c)

        We need to perform this evaluation
        with an accuracy of at least the
        double of the prevailing precision
        as the rest of the argument reduction
        code must receive a pretty accurate
        base.

         */
         oldPrec = prec;
         prec = max(2 * prec, ceil(-log2(abs(target))) * 3)!;
         base := exp(log(ratio) / d);
         prec = oldPrec!;

         /* Now we have to check if base^x effectively approximates func with
            an accuracy of target
         */
         testfunc = simplifysafe((base^x)/func - 1);
         y = evaluate(testfunc, [mid(dom)]);
         if (y in [-target, target]) then {
          zerosUpper = mydirtyfindzeros(testfunc + target, dom);
          zerosLower = mydirtyfindzeros(testfunc - target, dom);

          if ((zerosUpper == [||]) && (zerosLower == [||])) then {
              if (base != 1) then {
                              result.okay = true;
                          result.exponentialFunc = base^x;
                      result.exponentialBase = base;
              };
              };
             };
      };
      return result;
};

procedure tryGenerateExponentialArgumentReduction(base, dom, functionName, polynomialFunctionName, outputformat, polynomialVariableFormat, variableFormat, argRedTarget, reconstructTableTarget, tableWidth) {
      var result, code, table, okay, variableDeclarations, reductionCode, reconstructionCode;
      var oldDisplay, tableFormat, i, tblEntry, tblEntryExact, logBaseOfTwoFormat, logBaseOfTwoExact;

      result = { .okay = false };
      okay = true;

      table = "\n";
      oldDisplay = display;
      display = decimal!;
      if (tableWidth > 0) then {
            if (3/8 * reconstructTableTarget < 1b-107) then tableFormat = TD
                else if (3/8 * reconstructTableTarget < 1b-53) then tableFormat = DD
        else tableFormat = D;
        table = table @ "static const double " @ functionName @ "_twoPower_Index_Hi[" @ (~(2^tableWidth)) @ "] = {\n";
        for i from 0 to 2^tableWidth - 1 do {
            tblEntryExact = 2^(i * 2^(-tableWidth));
            tblEntry = simplifysafe(D(tblEntryExact));
            table = table @ " " @ tblEntry;
            if (i != 2^tableWidth - 1) then table = table @ ",";
            table = table @ "\n";
        };
        table = table @ "};\n\n";
        if ((tableFormat == DD) || (tableFormat == TD)) then {
               table = table @ "static const double " @ functionName @ "_twoPower_Index_Mi[" @ (~(2^tableWidth)) @ "] = {\n";
           for i from 0 to 2^tableWidth - 1 do {
               tblEntryExact = 2^(i * 2^(-tableWidth));
               tblEntry = simplifysafe(D(tblEntryExact - D(tblEntryExact)));
               table = table @ " " @ tblEntry;
               if (i != 2^tableWidth - 1) then table = table @ ",";
               table = table @ "\n";
           };
           table = table @ "};\n\n";
        };
            if (tableFormat == TD) then {
               table = table @ "static const double " @ functionName @ "_twoPower_Index_Lo[" @ (~(2^tableWidth)) @ "] = {\n";
           for i from 0 to 2^tableWidth - 1 do {
               tblEntryExact = 2^(i * 2^(-tableWidth));
               tblEntry = simplifysafe(D(tblEntryExact - (D(tblEntryExact) + D(tblEntryExact - D(tblEntryExact)))));
               table = table @ " " @ tblEntry;
               if (i != 2^tableWidth - 1) then table = table @ ",";
               table = table @ "\n";
           };
           table = table @ "};\n\n";
        };
          };

      table = table @ "#define " @ functionName @ "_argred_log2_of_base_times_two_to_w " @ (simplifysafe(D(log2(base) * 2^tableWidth))) @ "\n";

      if (argRedTarget * 2^(-tableWidth - 2) < 1b-106) then logBaseOfTwoFormat = TD
      else if (argRedTarget * 2^(-tableWidth - 2) < 1b-53) then logBaseOfTwoFormat = DD
      else logBaseOfTwoFormat = D;

      logBaseOfTwoExact = -2^(-tableWidth) * log(2)/log(base);
      table = table @ "#define " @ functionName @ "_argred_minus_logbase_of_2_times_two_to_minus_w_hi " @ (simplifysafe(D(logBaseOfTwoExact))) @ "\n";
      if ((logBaseOfTwoFormat == DD) || (logBaseOfTwoFormat == TD)) then {
         table = table @ "#define " @ functionName @ "_argred_minus_logbase_of_2_times_two_to_minus_w_mi " @ (simplifysafe(D(logBaseOfTwoExact - D(logBaseOfTwoExact)))) @ "\n";
      };
      if (logBaseOfTwoFormat == TD) then {
         table = table @ "#define " @ functionName @ "_argred_minus_logbase_of_2_times_two_to_minus_w_lo " @ (simplifysafe(D(logBaseOfTwoExact - (D(logBaseOfTwoExact) + D(logBaseOfTwoExact - D(logBaseOfTwoExact)))))) @ "\n";
      };

      table = table @ "#define " @ functionName @ "_argred_shifter 6755399441055744.0\n";
      table = table @ "#define " @ functionName @ "_argred_w " @ tableWidth @ "\n";
      table = table @ "#define " @ functionName @ "_argred_idx_mask " @ (simplifysafe(2^tableWidth - 1)) @ "ull\n";
      table = table @ "#define " @ functionName @ "_argred_lower_32_bits 0xffffffffull\n";
      display=oldDisplay!;

      variableDeclarations = "\n";
      reductionCode = "\n";
      reconstructionCode = "\n";

      variableDeclarations = variableDeclarations @ "double t;\n";
      reductionCode = reductionCode @ "t = xh * " @ functionName @ "_argred_log2_of_base_times_two_to_w;\n";
      variableDeclarations = variableDeclarations @ "double shifted_t;\n";
      reductionCode = reductionCode @ "shifted_t = t + " @ functionName @ "_argred_shifter;\n";
      variableDeclarations = variableDeclarations @ "double mAsDouble;\n";
      reductionCode = reductionCode @ "mAsDouble = shifted_t - " @ functionName @ "_argred_shifter;\n";
      variableDeclarations = variableDeclarations @ "db_number argRedCaster;\n";
      variableDeclarations = variableDeclarations @ "int mAsInt;\n";
      reductionCode = reductionCode @ "argRedCaster.d = shifted_t;\n";
      reductionCode = reductionCode @ "mAsInt = (int) (argRedCaster.l & " @ functionName @ "_argred_lower_32_bits);\n";
      variableDeclarations = variableDeclarations @ "int E;\n";
      reductionCode = reductionCode @ "E = mAsInt >> " @ functionName @ "_argred_w;\n";
      variableDeclarations = variableDeclarations @ "int E1;\n";
      reductionCode = reductionCode @ "E1 = E >> 1;\n";
      variableDeclarations = variableDeclarations @ "int E2;\n";
      reductionCode = reductionCode @ "E2 = E - E1;\n";
      variableDeclarations = variableDeclarations @ "int idx;\n";
      reductionCode = reductionCode @ "idx = mAsInt & " @ functionName @ "_argred_idx_mask;\n";

      match (logBaseOfTwoFormat) with
        D  : {
                variableDeclarations = variableDeclarations @ "double rescaled_m_hi;\n";
                    reductionCode = reductionCode @ "rescaled_m_hi = mAsDouble * " @ functionName @ "_argred_minus_logbase_of_2_times_two_to_minus_w_hi;\n";
             }
        DD : {
                variableDeclarations = variableDeclarations @ "double rescaled_m_hi;\n";
                variableDeclarations = variableDeclarations @ "double rescaled_m_mi;\n";
                    reductionCode = reductionCode @ "Mul122(&rescaled_m_hi, &rescaled_m_mi, mAsDouble, " @ functionName @ "_argred_minus_logbase_of_2_times_two_to_minus_w_hi, " @ functionName @ "_argred_minus_logbase_of_2_times_two_to_minus_w_mi);\n";
                 }
        TD : {
                variableDeclarations = variableDeclarations @ "double rescaled_m_hi;\n";
                variableDeclarations = variableDeclarations @ "double rescaled_m_mi;\n";
                variableDeclarations = variableDeclarations @ "double rescaled_m_lo;\n";
                    reductionCode = reductionCode @ "Mul133(&rescaled_m_hi, &rescaled_m_mi, &rescaled_m_lo, mAsDouble, " @ functionName @ "_argred_minus_logbase_of_2_times_two_to_minus_w_hi, " @ functionName @ "_argred_minus_logbase_of_2_times_two_to_minus_w_mi, " @ functionName @ "_argred_minus_logbase_of_2_times_two_to_minus_w_lo);\n";
                 };

      match (logBaseOfTwoFormat) with
        D  : {
                  match (variableFormat) with
                D  : {
                         match (polynomialVariableFormat) with
                           D  : {
                                                    reductionCode = reductionCode @ "zh = xh + rescaled_m_hi;\n";
                                }
                           DD : {
                                                    reductionCode = reductionCode @ "zh = xh + rescaled_m_hi;\n";
                                                    reductionCode = reductionCode @ "zm = 0.0;\n";
                                }
                           TD : {
                                                    reductionCode = reductionCode @ "zh = xh + rescaled_m_hi;\n";
                                                    reductionCode = reductionCode @ "zm = 0.0;\n";
                                                    reductionCode = reductionCode @ "zl = 0.0;\n";
                                };
                     }
                DD : {
                         match (polynomialVariableFormat) with
                           D  : {
                                                    reductionCode = reductionCode @ "zh = (xh + rescaled_m_hi) + xm;\n";
                                }
                           DD : {
                                    variableDeclarations = variableDeclarations @ "double tempArgRed;\n";
                                                    reductionCode = reductionCode @ "tempArgRed = xh + rescaled_m_hi;\n";
                                                    reductionCode = reductionCode @ "Add12Cond(zh,zm,tempArgRed,xm);\n";
                                }
                           TD : {
                                    variableDeclarations = variableDeclarations @ "double tempArgRed;\n";
                                                    reductionCode = reductionCode @ "tempArgRed = xh + rescaled_m_hi;\n";
                                                    reductionCode = reductionCode @ "Add12Cond(zh,zm,tempArgRed,xm);\n";
                                                        reductionCode = reductionCode @ "zl = 0.0;\n";
                                };
                     }
                TD : {
                         match (polynomialVariableFormat) with
                           D  : {
                                                    reductionCode = reductionCode @ "zh = (xh + rescaled_m_hi) + (xm + xl);\n";
                                }
                           DD : {
                                    variableDeclarations = variableDeclarations @ "double tempArgRed1;\n";
                                    variableDeclarations = variableDeclarations @ "double tempArgRed2;\n";
                                                    reductionCode = reductionCode @ "tempArgRed1 = xh + rescaled_m_hi;\n";
                                                    reductionCode = reductionCode @ "tempArgRed2 = xm + xl;\n";
                                                    reductionCode = reductionCode @ "Add12Cond(zh,zm,tempArgRed1,tempArgRed2);\n";
                                }
                           TD : {
                                    variableDeclarations = variableDeclarations @ "double tempArgRed;\n";
                                    variableDeclarations = variableDeclarations @ "double tempArgRed_hi;\n";
                                    variableDeclarations = variableDeclarations @ "double tempArgRed_mi;\n";
                                                    reductionCode = reductionCode @ "tempArgRed = xh + rescaled_m_hi;\n";
                                                    reductionCode = reductionCode @ "Add12Cond(tempArgRed_hi,tempArgRed_mi,tempArgRed,xm);\n";
                                                        reductionCode = reductionCode @ "Renormalize3(&zh,&zm,&zl,tempArgRed_hi,tempArgRed_mi,xl);\n";
                                };
                     };
             }
        DD : {
                  match (variableFormat) with
                D  : {
                         match (polynomialVariableFormat) with
                           D  : {
                                                    reductionCode = reductionCode @ "zh = (xh + rescaled_m_hi) + rescaled_m_mi;\n";
                                }
                           DD : {
                                    variableDeclarations = variableDeclarations @ "double tempArgRed;\n";
                                                    reductionCode = reductionCode @ "tempArgRed = xh + rescaled_m_hi;\n";
                                reductionCode = reductionCode @ "Add12Cond(zh,zm,tempArgRed,rescaled_m_mi);\n";
                                }
                           TD : {
                                    variableDeclarations = variableDeclarations @ "double tempArgRed;\n";
                                                    reductionCode = reductionCode @ "tempArgRed = xh + rescaled_m_hi;\n";
                                reductionCode = reductionCode @ "Add12Cond(zh,zm,tempArgRed,rescaled_m_mi);\n";
                                reductionCode = reductionCode @ "zl = 0.0;\n";
                                };
                     }
                DD : {
                         match (polynomialVariableFormat) with
                           D  : {
                                                    reductionCode = reductionCode @ "tempArgRed = ((xh + rescaled_m_hi) + xm) + rescaled_m_mi;\n";
                                }
                           DD : {
                                    reductionCode = reductionCode @ "Add22(&zh,&zm,xh,xm,rescaled_m_hi,rescaled_m_mi);\n";
                                }
                           TD : {
                                    variableDeclarations = variableDeclarations @ "double tempArgRed;\n";
                            variableDeclarations = variableDeclarations @ "double tempArgRed2_hi;\n";
                            variableDeclarations = variableDeclarations @ "double tempArgRed2_lo;\n";
                                                    reductionCode = reductionCode @ "tempArgRed = xh + rescaled_m_hi;\n";
                            reductionCode = reductionCode @ "Add12Cond(tempArgRed2_hi,tempArgRed2_lo,xm,rescaled_m_hi);\n";
                            reductionCode = reductionCode @ "Renormalize3(&zh,&zm,&zl,tempArgRed,tempArgRed2_hi,tempArgRed2_lo);\n";
                                };
                     }
                TD : {
                         match (polynomialVariableFormat) with
                           D  : {
                                    reductionCode = reductionCode @ "tempArgRed = (((xh + rescaled_m_hi) + xm) + rescaled_m_mi) + xl;\n";
                                }
                           DD : {
                                    variableDeclarations = variableDeclarations @ "double tempArgRed;\n";
                            variableDeclarations = variableDeclarations @ "double tempArgRed2_hi;\n";
                            variableDeclarations = variableDeclarations @ "double tempArgRed2_mi;\n";
                            variableDeclarations = variableDeclarations @ "double tempArgRed2_lo;\n";
                            variableDeclarations = variableDeclarations @ "double tempArgRed3_lo;\n";
                                                    reductionCode = reductionCode @ "tempArgRed = xh + rescaled_m_hi;\n";
                            reductionCode = reductionCode @ "Renormalize3(&tempArgRed2_hi,&tempArgRed2_mi,&tempArgRed2_lo,xm,rescaled_m_mi,xl);\n";
                            reductionCode = reductionCode @ "Renormalize3(&zh,&zm,&tempArgRed3_lo,tempArgRed,tempArgRed2_hi,tempArgRed2_mi);\n";
                                }
                           TD : {
                                variableDeclarations = variableDeclarations @ "double tempArgRed;\n";
                            variableDeclarations = variableDeclarations @ "double tempArgRed2_hi;\n";
                            variableDeclarations = variableDeclarations @ "double tempArgRed2_mi;\n";
                            variableDeclarations = variableDeclarations @ "double tempArgRed2_lo;\n";
                            variableDeclarations = variableDeclarations @ "double tempArgRed3_hi;\n";
                            variableDeclarations = variableDeclarations @ "double tempArgRed3_mi;\n";
                            variableDeclarations = variableDeclarations @ "double tempArgRed3_lo;\n";
                            variableDeclarations = variableDeclarations @ "double tempArgRed4;\n";
                                                    reductionCode = reductionCode @ "tempArgRed = xh + rescaled_m_hi;\n";
                            reductionCode = reductionCode @ "Renormalize3(&tempArgRed2_hi,&tempArgRed2_mi,&tempArgRed2_lo,xm,rescaled_m_mi,xl);\n";
                            reductionCode = reductionCode @ "Renormalize3(&tempArgRed3_hi,&tempArgRed3_mi,&tempArgRed3_lo,tempArgRed,tempArgRed2_hi,tempArgRed2_mi);\n";
                            reductionCode = reductionCode @ "tempArgRed4 = tempArgRed3_lo + tempArgRed2_lo;\n";
                            reductionCode = reductionCode @ "Renormalize3(&zh,&zm,&zl,tempArgRed3_hi,tempArgRed3_mi,tempArgRed4);\n";
                                };
                     };
                 }
        TD : {
                  match (variableFormat) with
                D  : {
                         match (polynomialVariableFormat) with
                           D  : {
                                                    reductionCode = reductionCode @ "zh = ((xh + rescaled_m_hi) + rescaled_m_mi) + rescaled_m_lo;\n";
                                }
                           DD : {
                            variableDeclarations = variableDeclarations @ "double tempArgRed;\n";
                            variableDeclarations = variableDeclarations @ "double tempArgRed2;\n";
                                                    reductionCode = reductionCode @ "tempArgRed = xh + rescaled_m_hi;\n";
                            reductionCode = reductionCode @ "Renormalize3(&zh,&zm,&tempArgRed2,tempArgRed,rescaled_m_mi,rescaled_m_lo);\n";
                                }
                           TD : {
                            variableDeclarations = variableDeclarations @ "double tempArgRed;\n";
                                                    reductionCode = reductionCode @ "tempArgRed = xh + rescaled_m_hi;\n";
                            reductionCode = reductionCode @ "Renormalize3(&zh,&zm,&zl,tempArgRed,rescaled_m_mi,rescaled_m_lo);\n";
                                };
                     }
                DD : {
                         match (polynomialVariableFormat) with
                           D  : {
                                                    reductionCode = reductionCode @ "zh = (((xh + rescaled_m_hi) + xm) + rescaled_m_mi) + rescaled_m_lo;\n";
                                }
                           DD : {
                                variableDeclarations = variableDeclarations @ "double tempArgRed;\n";
                            variableDeclarations = variableDeclarations @ "double tempArgRed2_hi;\n";
                            variableDeclarations = variableDeclarations @ "double tempArgRed2_mi;\n";
                            variableDeclarations = variableDeclarations @ "double tempArgRed2_lo;\n";
                            variableDeclarations = variableDeclarations @ "double tempArgRed3_hi;\n";
                            variableDeclarations = variableDeclarations @ "double tempArgRed3_mi;\n";
                            variableDeclarations = variableDeclarations @ "double tempArgRed3_lo;\n";
                            variableDeclarations = variableDeclarations @ "double tempArgRed4;\n";
                            variableDeclarations = variableDeclarations @ "double tempArgRed5;\n";
                                                    reductionCode = reductionCode @ "tempArgRed = xh + rescaled_m_hi;\n";
                            reductionCode = reductionCode @ "Renormalize3(&tempArgRed2_hi,&tempArgRed2_mi,&tempArgRed2_lo,xm,rescaled_m_mi,rescaled_m_lo);\n";
                            reductionCode = reductionCode @ "Renormalize3(&tempArgRed3_hi,&tempArgRed3_mi,&tempArgRed3_lo,tempArgRed,tempArgRed2_hi,tempArgRed2_mi);\n";
                            reductionCode = reductionCode @ "tempArgRed4 = tempArgRed3_lo + tempArgRed2_lo;\n";
                            reductionCode = reductionCode @ "Renormalize3(&zh,&zm,&tempArgRed5,tempArgRed3_hi,tempArgRed3_mi,tempArgRed4);\n";
                                }
                           TD : {
                                variableDeclarations = variableDeclarations @ "double tempArgRed;\n";
                            variableDeclarations = variableDeclarations @ "double tempArgRed2_hi;\n";
                            variableDeclarations = variableDeclarations @ "double tempArgRed2_mi;\n";
                            variableDeclarations = variableDeclarations @ "double tempArgRed2_lo;\n";
                            variableDeclarations = variableDeclarations @ "double tempArgRed3_hi;\n";
                            variableDeclarations = variableDeclarations @ "double tempArgRed3_mi;\n";
                            variableDeclarations = variableDeclarations @ "double tempArgRed3_lo;\n";
                            variableDeclarations = variableDeclarations @ "double tempArgRed4;\n";
                                                    reductionCode = reductionCode @ "tempArgRed = xh + rescaled_m_hi;\n";
                            reductionCode = reductionCode @ "Renormalize3(&tempArgRed2_hi,&tempArgRed2_mi,&tempArgRed2_lo,xm,rescaled_m_mi,rescaled_m_lo);\n";
                            reductionCode = reductionCode @ "Renormalize3(&tempArgRed3_hi,&tempArgRed3_mi,&tempArgRed3_lo,tempArgRed,tempArgRed2_hi,tempArgRed2_mi);\n";
                            reductionCode = reductionCode @ "tempArgRed4 = tempArgRed3_lo + tempArgRed2_lo;\n";
                            reductionCode = reductionCode @ "Renormalize3(&zh,&zm,&zl,tempArgRed3_hi,tempArgRed3_mi,tempArgRed4);\n";
                                };
                     }
                TD : {
                         match (polynomialVariableFormat) with
                           D  : {
                                                    reductionCode = reductionCode @ "zh = ((((xh + rescaled_m_hi) + xm) + rescaled_m_mi) + xl) + rescaled_m_lo;\n";
                                }
                           DD : {
                            variableDeclarations = variableDeclarations @ "double tempArgRed_hi;\n";
                            variableDeclarations = variableDeclarations @ "double tempArgRed_mi;\n";
                            variableDeclarations = variableDeclarations @ "double tempArgRed_lo;\n";
                            variableDeclarations = variableDeclarations @ "double tempArgRed2;\n";
                            reductionCode = reductionCode @ "Add33(&tempArgRed_hi,&tempArgRed_mi,&tempArgRed_lo,xh,xm,xl,rescaled_m_hi,rescaled_m_mi,rescaled_m_lo);\n";
                            reductionCode = reductionCode @ "Renormalize3(&zh,&zm,&tempArgRed2,tempArgRed_hi,tempArgRed_mi,tempArgRed_lo);\n";
                                }
                           TD : {
                            variableDeclarations = variableDeclarations @ "double tempArgRed_hi;\n";
                            variableDeclarations = variableDeclarations @ "double tempArgRed_mi;\n";
                            variableDeclarations = variableDeclarations @ "double tempArgRed_lo;\n";
                            reductionCode = reductionCode @ "Add33(&tempArgRed_hi,&tempArgRed_mi,&tempArgRed_lo,xh,xm,xl,rescaled_m_hi,rescaled_m_mi,rescaled_m_lo);\n";
                            reductionCode = reductionCode @ "Renormalize3(&zh,&zm,&zl,tempArgRed_hi,tempArgRed_mi,tempArgRed_lo);\n";
                                };
                     };
                 };

      if (tableWidth > 0) then {
          match (outputformat) with
                D  : {
            match (tableFormat) with
                  D  : {
                    variableDeclarations = variableDeclarations @ "double table_hi;\n";
                    variableDeclarations = variableDeclarations @ "double tableTimesPoly_hi;\n";
                    reconstructionCode = reconstructionCode @ "table_hi = " @ functionName @ "_twoPower_Index_Hi[idx];\n";
                    reconstructionCode = reconstructionCode @ "tableTimesPoly_hi = table_hi * poly_resh;\n";
                       }
                  DD : {
                        variableDeclarations = variableDeclarations @ "double table_hi;\n";
                        variableDeclarations = variableDeclarations @ "double table_mi;\n";
                    variableDeclarations = variableDeclarations @ "double tableTimesPoly_hi;\n";
                    variableDeclarations = variableDeclarations @ "double tempReconstr_hi;\n";
                    variableDeclarations = variableDeclarations @ "double tempReconstr_lo;\n";
                    variableDeclarations = variableDeclarations @ "double tempReconstr2;\n";
                    reconstructionCode = reconstructionCode @ "table_hi = " @ functionName @ "_twoPower_Index_Hi[idx];\n";
                    reconstructionCode = reconstructionCode @ "table_mi = " @ functionName @ "_twoPower_Index_Mi[idx];\n";
                    reconstructionCode = reconstructionCode @ "Mul12(&tempReconstr_hi,&tempReconstr_lo,table_hi,poly_resh);\n";
                    reconstructionCode = reconstructionCode @ "tempReconstr2 = table_mi * poly_resh;\n";
                    reconstructionCode = reconstructionCode @ "tableTimesPoly_hi = tempReconstr_hi + (tempReconstr_lo + tempReconstr2);\n";
                       }
                      TD : {
                        variableDeclarations = variableDeclarations @ "double table_hi;\n";
                        variableDeclarations = variableDeclarations @ "double table_mi;\n";
                        variableDeclarations = variableDeclarations @ "double table_lo;\n";
                    variableDeclarations = variableDeclarations @ "double tableTimesPoly_hi;\n";
                    variableDeclarations = variableDeclarations @ "double tempReconstr_hi;\n";
                    variableDeclarations = variableDeclarations @ "double tempReconstr_lo;\n";
                    variableDeclarations = variableDeclarations @ "double tempReconstr2_hi;\n";
                    variableDeclarations = variableDeclarations @ "double tempReconstr2_lo;\n";
                    variableDeclarations = variableDeclarations @ "double tempReconstr3_hi;\n";
                    variableDeclarations = variableDeclarations @ "double tempReconstr3_lo;\n";
                    variableDeclarations = variableDeclarations @ "double tempReconstr4;\n";
                    reconstructionCode = reconstructionCode @ "table_hi = " @ functionName @ "_twoPower_Index_Hi[idx];\n";
                    reconstructionCode = reconstructionCode @ "table_mi = " @ functionName @ "_twoPower_Index_Mi[idx];\n";
                    reconstructionCode = reconstructionCode @ "table_lo = " @ functionName @ "_twoPower_Index_Lo[idx];\n";
                    reconstructionCode = reconstructionCode @ "Mul12(&tempReconstr_hi,&tempReconstr_lo,table_hi,poly_resh);\n";
                    reconstructionCode = reconstructionCode @ "Mul12(&tempReconstr2_hi,&tempReconstr2_lo,table_mi,poly_resh);\n";
                    reconstructionCode = reconstructionCode @ "Add12Cond(tempReconstr3_hi,tempReconstr3_lo,tempReconstr_lo,tempReconstr2_hi);\n";
                    reconstructionCode = reconstructionCode @ "tempReconstr4 = table_lo * poly_resh;\n";
                    reconstructionCode = reconstructionCode @ "tableTimesPoly_hi = (((tempReconstr4 + tempReconstr2_lo) + tempReconstr3_lo) + tempReconstr3_hi) + tempReconstr_hi;\n";
                       };
             }
                DD : {
                match (tableFormat) with
                  D  : {
                        variableDeclarations = variableDeclarations @ "double table_hi;\n";
                    variableDeclarations = variableDeclarations @ "double tableTimesPoly_hi;\n";
                    variableDeclarations = variableDeclarations @ "double tableTimesPoly_mi;\n";
                    reconstructionCode = reconstructionCode @ "table_hi = " @ functionName @ "_twoPower_Index_Hi[idx];\n";
                    reconstructionCode = reconstructionCode @ "Mul122(&tableTimesPoly_hi,&tableTimesPoly_mi,table_hi,poly_resh,poly_resm);\n";
                       }
                  DD : {
                        variableDeclarations = variableDeclarations @ "double table_hi;\n";
                        variableDeclarations = variableDeclarations @ "double table_mi;\n";
                    variableDeclarations = variableDeclarations @ "double tableTimesPoly_hi;\n";
                    variableDeclarations = variableDeclarations @ "double tableTimesPoly_mi;\n";
                    reconstructionCode = reconstructionCode @ "table_hi = " @ functionName @ "_twoPower_Index_Hi[idx];\n";
                    reconstructionCode = reconstructionCode @ "table_mi = " @ functionName @ "_twoPower_Index_Mi[idx];\n";
                    reconstructionCode = reconstructionCode @ "Mul22(&tableTimesPoly_hi,&tableTimesPoly_mi,table_hi,table_mi,poly_resh,poly_resm);\n";
                       }
                      TD : {
                        variableDeclarations = variableDeclarations @ "double table_hi;\n";
                        variableDeclarations = variableDeclarations @ "double table_mi;\n";
                        variableDeclarations = variableDeclarations @ "double table_lo;\n";
                    variableDeclarations = variableDeclarations @ "double tableTimesPoly_hi;\n";
                    variableDeclarations = variableDeclarations @ "double tableTimesPoly_mi;\n";
                    variableDeclarations = variableDeclarations @ "double tempReconstr_hi;\n";
                    variableDeclarations = variableDeclarations @ "double tempReconstr_mi;\n";
                    variableDeclarations = variableDeclarations @ "double tempReconstr_lo;\n";
                    variableDeclarations = variableDeclarations @ "double tempReconstr2;\n";
                    reconstructionCode = reconstructionCode @ "table_hi = " @ functionName @ "_twoPower_Index_Hi[idx];\n";
                    reconstructionCode = reconstructionCode @ "table_mi = " @ functionName @ "_twoPower_Index_Mi[idx];\n";
                    reconstructionCode = reconstructionCode @ "table_lo = " @ functionName @ "_twoPower_Index_Lo[idx];\n";
                    reconstructionCode = reconstructionCode @ "Mul233(&tempReconstr_hi,&tempReconstr_mi,&tempReconstr_lo,poly_resh,poly_resm,table_hi,table_mi,table_lo);\n";
                    reconstructionCode = reconstructionCode @ "Renormalize3(&zh,&zm,&tempReconstr2,tempReconstr_hi,tempReconstr_mi,tempReconstr_lo);\n";
                       };
                     }
                TD : {
            match (tableFormat) with
                  D  : {
                        variableDeclarations = variableDeclarations @ "double table_hi;\n";
                    variableDeclarations = variableDeclarations @ "double tableTimesPoly_hi;\n";
                    variableDeclarations = variableDeclarations @ "double tableTimesPoly_mi;\n";
                    variableDeclarations = variableDeclarations @ "double tableTimesPoly_lo;\n";
                    reconstructionCode = reconstructionCode @ "table_hi = " @ functionName @ "_twoPower_Index_Hi[idx];\n";
                    reconstructionCode = reconstructionCode @ "Mul133(&tableTimesPoly_hi,&tableTimesPoly_mi,&tableTimesPoly_lo,table_hi,poly_resh,poly_resm,poly_resl);\n";
                       }
                  DD : {
                        variableDeclarations = variableDeclarations @ "double table_hi;\n";
                        variableDeclarations = variableDeclarations @ "double table_mi;\n";
                    variableDeclarations = variableDeclarations @ "double tableTimesPoly_hi;\n";
                    variableDeclarations = variableDeclarations @ "double tableTimesPoly_mi;\n";
                    variableDeclarations = variableDeclarations @ "double tableTimesPoly_lo;\n";
                    reconstructionCode = reconstructionCode @ "table_hi = " @ functionName @ "_twoPower_Index_Hi[idx];\n";
                    reconstructionCode = reconstructionCode @ "table_mi = " @ functionName @ "_twoPower_Index_Mi[idx];\n";
                    reconstructionCode = reconstructionCode @ "Mul233(&tableTimesPoly_hi,&tableTimesPoly_mi,&tableTimesPoly_lo,table_hi,table_mi,poly_resh,poly_resm,poly_resl);\n";
                       }
                      TD : {
                        variableDeclarations = variableDeclarations @ "double table_hi;\n";
                        variableDeclarations = variableDeclarations @ "double table_mi;\n";
                        variableDeclarations = variableDeclarations @ "double table_lo;\n";
                    variableDeclarations = variableDeclarations @ "double tableTimesPoly_hi;\n";
                    variableDeclarations = variableDeclarations @ "double tableTimesPoly_mi;\n";
                    variableDeclarations = variableDeclarations @ "double tableTimesPoly_lo;\n";
                    reconstructionCode = reconstructionCode @ "table_hi = " @ functionName @ "_twoPower_Index_Hi[idx];\n";
                    reconstructionCode = reconstructionCode @ "table_mi = " @ functionName @ "_twoPower_Index_Mi[idx];\n";
                    reconstructionCode = reconstructionCode @ "table_lo = " @ functionName @ "_twoPower_Index_Lo[idx];\n";
                    reconstructionCode = reconstructionCode @ "Mul33(&tableTimesPoly_hi,&tableTimesPoly_mi,&tableTimesPoly_lo,table_hi,table_mi,table_lo,poly_resh,poly_resm,poly_resl);\n";
                       };
                     };
          };

      variableDeclarations = variableDeclarations @ "db_number twoE1;\n";
      reconstructionCode = reconstructionCode @ "twoE1.l = E1 + 1023ll;\n";
      reconstructionCode = reconstructionCode @ "twoE1.l <<= 52;\n";
      variableDeclarations = variableDeclarations @ "db_number twoE2;\n";
      reconstructionCode = reconstructionCode @ "twoE2.l = E2 + 1023ll;\n";
      reconstructionCode = reconstructionCode @ "twoE2.l <<= 52;\n";

      if (tableWidth > 0) then {
          match (outputformat) with
                D  : {
                 variableDeclarations = variableDeclarations @ "double twoE1tablePoly_hi;\n";
             reconstructionCode = reconstructionCode @ "twoE1tablePoly_hi = twoE1.d * tableTimesPoly_hi;\n";
             reconstructionCode = reconstructionCode @ "*res_resh = twoE2.d * twoE1tablePoly_hi;\n";
             }
        DD : {
                 variableDeclarations = variableDeclarations @ "double twoE1tablePoly_hi;\n";
                 variableDeclarations = variableDeclarations @ "double twoE1tablePoly_mi;\n";
             reconstructionCode = reconstructionCode @ "twoE1tablePoly_hi = twoE1.d * tableTimesPoly_hi;\n";
             reconstructionCode = reconstructionCode @ "twoE1tablePoly_mi = twoE1.d * tableTimesPoly_mi;\n";
             reconstructionCode = reconstructionCode @ "*res_resh = twoE2.d * twoE1tablePoly_hi;\n";
             reconstructionCode = reconstructionCode @ "*res_resm = twoE2.d * twoE1tablePoly_mi;\n";
             }
        TD : {
                 variableDeclarations = variableDeclarations @ "double twoE1tablePoly_hi;\n";
                 variableDeclarations = variableDeclarations @ "double twoE1tablePoly_mi;\n";
                 variableDeclarations = variableDeclarations @ "double twoE1tablePoly_lo;\n";
             reconstructionCode = reconstructionCode @ "twoE1tablePoly_hi = twoE1.d * tableTimesPoly_hi;\n";
             reconstructionCode = reconstructionCode @ "twoE1tablePoly_mi = twoE1.d * tableTimesPoly_mi;\n";
             reconstructionCode = reconstructionCode @ "twoE1tablePoly_lo = twoE1.d * tableTimesPoly_lo;\n";
             reconstructionCode = reconstructionCode @ "*res_resh = twoE2.d * twoE1tablePoly_hi;\n";
             reconstructionCode = reconstructionCode @ "*res_resm = twoE2.d * twoE1tablePoly_mi;\n";
             reconstructionCode = reconstructionCode @ "*res_resl = twoE2.d * twoE1tablePoly_lo;\n";
             };
          } else {
          match (outputformat) with
                D  : {
                 variableDeclarations = variableDeclarations @ "double twoE1Poly_hi;\n";
             reconstructionCode = reconstructionCode @ "twoE1Poly_hi = twoE1.d * poly_resh;\n";
             reconstructionCode = reconstructionCode @ "*res_resh = twoE2.d * twoE1Poly_hi;\n";
             }
        DD : {
                 variableDeclarations = variableDeclarations @ "double twoE1Poly_hi;\n";
                 variableDeclarations = variableDeclarations @ "double twoE1Poly_mi;\n";
             reconstructionCode = reconstructionCode @ "twoE1Poly_hi = twoE1.d * poly_resh;\n";
             reconstructionCode = reconstructionCode @ "twoE1Poly_mi = twoE1.d * poly_resm;\n";
             reconstructionCode = reconstructionCode @ "*res_resh = twoE2.d * twoE1Poly_hi;\n";
             reconstructionCode = reconstructionCode @ "*res_resm = twoE2.d * twoE1Poly_mi;\n";
             }
        TD : {
                 variableDeclarations = variableDeclarations @ "double twoE1Poly_hi;\n";
                 variableDeclarations = variableDeclarations @ "double twoE1Poly_mi;\n";
                 variableDeclarations = variableDeclarations @ "double twoE1Poly_lo;\n";
             reconstructionCode = reconstructionCode @ "twoE1Poly_hi = twoE1.d * poly_resh;\n";
             reconstructionCode = reconstructionCode @ "twoE1Poly_mi = twoE1.d * poly_resm;\n";
             reconstructionCode = reconstructionCode @ "twoE1Poly_lo = twoE1.d * poly_resl;\n";
             reconstructionCode = reconstructionCode @ "*res_resh = twoE2.d * twoE1Poly_hi;\n";
             reconstructionCode = reconstructionCode @ "*res_resm = twoE2.d * twoE1Poly_mi;\n";
             reconstructionCode = reconstructionCode @ "*res_resl = twoE2.d * twoE1Poly_lo;\n";
             };
      };

      code = "\n";
      code = code @ "void " @ functionName @ "(";
      code = code @ (match outputformat with
                               D   : ( "double *res_resh, " )
                               DD  : ( "double *res_resh, double *res_resm, " )
                               TD  : ( "double *res_resh, double *res_resm, double *res_resl, " )
                        );
          code = code @ (match variableFormat with
                               D   : ( "double xh" )
                               DD  : ( "double xh, double xm" )
                               TD  : ( "double xh, double xm, double xl" )
                        );
          code = code @ ") {\n";
          code = code @ (match polynomialVariableFormat with
                               D   : ( "double zh;" )
                               DD  : ( "double zh, zm;" )
                               TD  : ( "double zh, zm, zl;" )
                        );
          code = code @ "\n";
          code = code @ (match outputformat with
                               D   : ( "double poly_resh;" )
                               DD  : ( "double poly_resh, poly_resm;" )
                               TD  : ( "double poly_resh, poly_resm, poly_resl;" )
                        );
          code = code @ "\n";
      code = code @ variableDeclarations @ "\n";
      code = code @ reductionCode @ "\n";
          code = code @ polynomialFunctionName @ "(";
          code = code @ (match outputformat with
                               D   : ( "&poly_resh, " )
                               DD  : ( "&poly_resh, &poly_resm, " )
                               TD  : ( "&poly_resh, &poly_resm, &poly_resl, " )
                        );
          code = code @ (match polynomialVariableFormat with
                               D   : ( "zh" )
                               DD  : ( "zh, zm" )
                               TD  : ( "zh, zm, zl" )
                        );
          code = code @ ");\n";
      code = code @ reconstructionCode @ "\n";
          code = code @ "}\n";

      if (okay) then {
         result.code = table @ code;
         result.okay = true;
      };

      return result;
};

procedure tryImplementationThroughArgumentReductionExponential(problemdef, parametrization) {
      var result, needArgumentReduction, res, myTableWidth, base, myDom, reducedFunc;
      var doNotPerformExponentialArgRed, argRedTarget, myVariableFormat, myProblemdef, myParametrization;
      var suffix, origDefDom, resArgRed;
      var oP;

      result = { .okay = false };

      match ( { .problemdef = problemdef,
                    .parametrization = parametrization } ) with
                { .problemdef =      { .func = default,
                                       .dom = default,
                                       .target = default,
                                       .variableFormat = default },
                  .parametrization = { .maxDegree = default,
                                       .minWidth = default,
                                       .beta = default,
                           .implementationFile = default,
                                       .gappaFile = default,
                                       .gappaOutputFile = default,
                                       .gappaExecutable = default,
                       .functionBasename = default,
                       .tableIndexWidth = default } } : {

                       /* Test if we may perform this type of argument
                          reduction
                       */
                       doNotPerformExponentialArgRed = false;
                       match (parametrization) with
                             { .doNotPerformExponentialArgRed = true } : { doNotPerformExponentialArgRed = true; }
                         default : { };

                       if (!doNotPerformExponentialArgRed) then {
                           /* Start with a test if the domain actually needs
                                              argument reduction in order to stay below the maximum
                          polynomial degree
                           */
                           needArgumentReduction = true;
                           res = checkIfSufficientDegree(problemdef.func, problemdef.dom, parametrization.maxDegree, problemdef.target);

                                           if (res.okay) then {
                                           if (res.sufficientDegree) then needArgumentReduction = false;
                           } else {
                               needArgumentReduction = false;
                           };

                           if (needArgumentReduction) then {
                              /* Here, we need to detect if we can use
                             the exponential argument reduction
                             for the given function
                          */

                          res = tryDetectExponentialArgRed(problemdef.func, problemdef.dom, problemdef.target * 1/8);

                          if (res.okay) then {
                             /* Here we can use the argument reduction for (res.exponentialBase)^x = res.exponentialFunc

                                We start by computing the range of the reduced argument.

                            We have

                            base^x = 2^k * a^(x - k * log(2)/log(base))

                            where k is computed as

                            k = 2^(-w) * nearestint(x * log2(base) * 2^w)

                            where w is the table index width.

                            Hence the reduced argument z = x - k * log(2)/log(base)
                            varies in the domain

                            myDom = [ -2^(-w-1) * log(2)/log(base) ; 2^(-w-1) * log(2)/log(base) ]
                             */
                             base = res.exponentialBase;
                             reducedFunc = res.exponentialFunc;
                                         write("Detected possible argument reduction as base^x, where base is approximately: ", round(base,24,RN), "\n");
                             myTableWidth = parametrization.tableIndexWidth;
                             if (myTableWidth < 0) then myTableWidth = 0;

                         oP = prec;
                         prec = max(300, prec)!;
                             myDom = [ -2^(-myTableWidth-1) * log(2)/log(base);
                                        2^(-myTableWidth-1) * log(2)/log(base)];
                             prec = oP!;

                             write("The reduced argument domain is ", myDom, "\n");

                                 /* Now we have to check if the "argument reduction"
                                actually reduces the size of the argument range.
                            If not, base is too small for our table size
                            and we'd better apply some other technique.
                                 */
                             if (sup(myDom) - inf(myDom) < sup(problemdef.dom) - inf(problemdef.dom)) then {
                                /* Now we can try to implement our reduced function.
                               We have to add a marker to the parametrization
                               in order not to re-perform an argument reduction
                               of the same type.

                               To do so, we have to determine the precision
                               needed for the reduced argument.

                               It is pretty easy to show that the amplified
                                                       forward error of the argument reduction eps2
                               can be expressed as

                               eps2 = base^(eps1 * z) - 1

                               where z is the reduced argument and eps1 is
                               the relative error on the reduced argument.
                               In order to keep eps2 at 1/8 * target, eps1
                               must hence be bounded by

                               abs(eps1) <= min( abs(log(1 - 1/8 * target) / log(base^inf(myDom))),
                                                 abs(log(1 - 1/8 * target) / log(base^sup(myDom))),
                                                 abs(log(1 + 1/8 * target) / log(base^inf(myDom))),
                                                 abs(log(1 + 1/8 * target) / log(base^sup(myDom))) )
                            */
                            argRedTarget = min( abs(log(1 - 1/8 * (problemdef.target)) / log(base^inf(myDom))),
                                                abs(log(1 - 1/8 * (problemdef.target)) / log(base^sup(myDom))),
                                                abs(log(1 + 1/8 * (problemdef.target)) / log(base^inf(myDom))),
                                                abs(log(1 + 1/8 * (problemdef.target)) / log(base^sup(myDom))) );

                                write("The maximum error allowed for argument reduction is 2^(", round(log2(argRedTarget),12,RN), ")\n");
                            if (argRedTarget < 1b-102) then myVariableFormat = TD
                            else if (argRedTarget < 1b-51) then myVariableFormat = DD
                            else myVariableFormat = D;
                            if (problemdef.variableFormat == TD) then myVariableFormat = TD
                            else if (problemdef.variableFormat == DD) then myVariableFormat = DD;
                            write("This means the reduced argument will be represented on a ", myVariableFormat, "\n");

                            myProblemdef.func = reducedFunc;
                            myProblemdef.dom = myDom;
                            myProblemdef.target = 1/8 * (problemdef.target);
                            myProblemdef.variableFormat = myVariableFormat;
                            suffix = "_exp_arg_red";
                                origDefDom = problemdef.dom;
                                match (problemdef) with { .definitionDomain = default } : {
                                                             if (origDefDom in problemdef.definitionDomain) then {
                                                                                    origDefDom = problemdef.definitionDomain;
                                                                                 }; }
                                                                            default : {};
                                myProblemdef.definitionDomain = origDefDom;
                                myParametrization = parametrization;
                                myParametrization.gappaFile = parametrization.gappaFile @ suffix;
                                myParametrization.gappaOutputFile = parametrization.gappaOutputFile @ suffix;
                                myParametrization.functionBasename = parametrization.functionBasename @ suffix;
                            myParametrization.doNotPerformExponentialArgRed = true;
                            myParametrization.minWidth = (sup(myDom) - inf(myDom)) * (parametrization.minWidth / (sup(problemdef.dom) - inf(problemdef.dom)));
                                myParametrization.argumentReduced = true;

                                res = tryImplementation(myProblemdef, myParametrization);

                            if (res.okay) then {
                               write("Implementation of the approximation on the reduced domain worked, generating argument reduction and tables\n");
                               resArgRed = tryGenerateExponentialArgumentReduction(base, problemdef.dom, parametrization.functionBasename,
                                                                                   res.functionname, res.outputformat, myVariableFormat, problemdef.variableFormat,
                                                       argRedTarget, 1/8 * (problemdef.target), myTableWidth);

                               if (resArgRed.okay) then {
                                  write("Argument reduction code correctly generated\n");
                                  write(resArgRed.code) >> parametrization.implementationFile;
                              result.okay = true;
                                                      result.approxerr = res.approxerr;
                              result.implerr = res.implerr;
                              result.outputformat = res.outputformat;
                                  result.functionname = parametrization.functionBasename;
                               } else {
                                                          write("No argument reduction code could be generated\n");
                               };
                            };
                             };
                          };
                           };
                         };
                     }
                default : { };

      return result;
};

procedure dirtyEvaluateImageInner(func,dom) {
      var fDiff, zeros, z, fmin, fmax, y;
      var yInt, res;
      var oldPoints, oldPrec;

      yInt = evaluate(func,dom);

      if ((inf(yInt) == inf(yInt)) &&
          (sup(yInt) == sup(yInt)) &&
          (sup(abs(yInt)) != infty)) then {
          fDiff = diff(func);
          oldPoints = points;
          oldPrec = prec;
          zeros = (mydirtyfindzeros(fDiff,dom)) :. (sup(dom));
          points = oldPoints!;
          prec = oldPrec!;
          fmin = inf(evaluate(func,inf(dom)));
          fmax = sup(evaluate(func,inf(dom)));
          for z in zeros do {
              y = evaluate(func,z);
              if (inf(y) < fmin) then fmin = inf(y);
              if (sup(y) > fmax) then fmax = sup(y);
          };
          res = [ fmin; fmax ];
          } else {
          res = yInt;
      };

      return res;
};

procedure intervalHull(I,J) {
      return [ min(inf(I), inf(J)); max(sup(I), sup(J)) ];
};

procedure dirtyEvaluateImage(func,dom) {
      var res;

      if (inf(dom) == sup(dom)) then {
         res = evaluate(func,dom);
      } else {

      if ((0 in dom) && (dom != [0])) then {
           if (inf(dom) <= -1b-1074) then {
               if (sup(dom) >= 1b-1074) then {
                       res = intervalHull(intervalHull(
                                                           dirtyEvaluateImageInner(func,[inf(dom);-1b-1074]),
                                                   dirtyEvaluateImageInner(func,[0])),
                                      dirtyEvaluateImageInner(func,[1b-1074;sup(dom)]));
                   } else {
                       res = intervalHull(dirtyEvaluateImageInner(func,[inf(dom);-1b-1074]),
                                      dirtyEvaluateImageInner(func,[0]));
           };
           } else {
               if (sup(dom) >= 1b-1074) then {
                       res = intervalHull(dirtyEvaluateImageInner(func,[1b-1074; sup(dom)]),
                                      dirtyEvaluateImageInner(func,[0]));

                   } else {
                   res = dirtyEvaluateImageInner(func,[0]);
           };
           };
      } else {
        res = dirtyEvaluateImageInner(func,dom);
      };
      };

      return res;
};

procedure dirtyEvaluateImageImproved(func,dom) {
      var res;
      var ran;
      var snorm;
      var a, b;
      
      snorm = mydirtyinfnorm(func, dom);
      ran = dirtyEvaluateImage(func, dom);  

      a = max(-snorm, inf(ran));
      b = min(snorm, sup(ran));

      if (a <= b) then {
        res = [ a; b ];
      } else {
        res = ran;
      };

      return res;
};

procedure tryDetectExponentialBehaviorArgRed(func, dom, maxReducRatio, target) {
      var result, base, a, b, c, d, ratio, oldPrec, testfunc;
      var yOrig, yReduc, widthOrig, withReduc, reducRatio;
      var testfuncjustone;

      result = { .okay = false };

      /* We have to detect if func behaves in dom
         like

         base^x for some unknown base

         We say that func behaves like base^x
         if

         base^x = func * (1 + eps) with abs(eps) <= target.

         We start by computing a possible base
         as

         base = exp((log(f(c+d)/f(c))/d))

         with

           - d = b - a                  if b - a < 5
             c = a

           - d = 5                      otherwise
                 c = max(a, (a+b)/2 - 2.5)

             where dom = [a;b]

         We can stop trying if f(c+d)/f(c) is
         negative.
      */
      a = inf(dom);
      b = sup(dom);
      if ((0 in dom) && (max(-a,b) > 5))then {
         if (-a > b) then {
            c = -5;
        d = 5;
         } else {
            c = 0;
        d = 5;
         };
      } else {
          if (b - a < 5) then {
             d = b - a;
             c = a;
          } else {
                 d = 5;
                 c = max(a, (a + b)/2 - 2.5);
              };
      };
      if (0 in func([c])) then {
         ratio = -1;
      } else {
         ratio = func(c + d) / func(c);
      };

      if (~ratio > 0) then {
         /* Here, f(c + d) / f(c) is positive

            So we can compute a presumed base
        as

        base = exp(log(ratio)/d)

        where ratio = f(c + d) / f(c)

        We need to perform this evaluation
        with an accuracy of at least the
        double of the prevailing precision
        as the rest of the argument reduction
        code must receive a pretty accurate
        base.

         */
         oldPrec = prec;
         prec = max(2 * prec, ceil(-log2(abs(target))) * 3)!;
         base := exp(log(ratio) / d);
         prec = oldPrec!;

         /* Now check if dividing the given function by
            base^x reduces the output domain for the factor g(x):

        f(x) = base^x * g(x).
             */
         testfunc = simplifysafe(func/(base^x));
         yOrig = dirtyEvaluateImage(func,dom);
         yReduc = dirtyEvaluateImage(testfunc,dom);
         widthOrig = sup(yOrig) - inf(yOrig);
         widthReduc = sup(yReduc) - inf(yReduc);
         reducRatio = widthReduc / widthOrig;

         if (reducRatio <= maxReducRatio) then {
            /* Now check if the divided function is not
           just 1 or something really close.
           If this were the case, we do not
           really have an argument reduction
           as we can always multiply by 1 without
           any change in the problem set.
        */
        testfuncjustone = false;
        if (sup(abs(yReduc - 1)) <= 2^(-(prec/2))) then {
           testfuncjustone = true;
        };

        if (!testfuncjustone) then {
                result.okay = true;
            result.g = base^x;
            result.h = testfunc;
            result.ratio = reducRatio;
        };
         };
      };
      return result;
};

procedure tryDetectLogarithmicBehaviorArgRed(func, dom, maxReducRatio, target) {
      var result, testfunc;
      var yOrig, yReduc, widthOrig, withReduc, reducRatio;
      var testfuncjustone;

      result = { .okay = false };

      /* Dividing by a logarithm is only possible if the
         domain only contains (strictly) positive numbers.
      */
      if (inf(dom) > 0) then {

         /* Just check if dividing the given function by
            log(x) reduces the output domain for the factor g(x):

        f(x) = log2(x) * g(x).
             */
         testfunc = simplifysafe(func/log2(x));
         yOrig = dirtyEvaluateImage(func,dom);
         yReduc = dirtyEvaluateImage(testfunc,dom);
         widthOrig = sup(yOrig) - inf(yOrig);
         widthReduc = sup(yReduc) - inf(yReduc);
         reducRatio = widthReduc / widthOrig;

         if ((reducRatio == reducRatio) && (abs(reducRatio) != infty) && (reducRatio <= maxReducRatio)) then {
            /* Now check if the divided function is not
           just 1 or something really close.
           If this were the case, we do not
           really have an argument reduction
           as we can always multiply by 1 without
           any change in the problem set.
        */
        testfuncjustone = false;
        if (sup(abs(yReduc - 1)) <= 2^(-(prec/2))) then {
           testfuncjustone = true;
        };

        if (!testfuncjustone) then {
                result.okay = true;
            result.g = log2(x);
            result.h = testfunc;
            result.ratio = reducRatio;
        };
         };
      };
      return result;
};

procedure tryDetectPoweringBehaviorArgRed(func, dom, maxReducRatio, target) {
      var result, a, b, c, sign, testfunc;
      var yOrig, yReduc, widthOrig, withReduc, reducRatio;
      var testfuncjustone;
      var yReducA, yReducB;

      result = { .okay = false };

      /* We have to detect if func behaves in dom
         like

         x^c for some constant c

         We start by computing a possible constant c
         as

         c = log(abs(f(b)/f(a)))/log(abs(b/a))

         where a, b are chosen as follows:

         * if sup(dom) == 0, a = 2/3 * inf(dom), b = 1/3 * inf(dom)
         * otherwise:
              - if inf(dom) == 0, a = 1/3 * sup(dom), b = 2/3 * sup(dom)
          - otherwise:
                   + if inf(dom) != -sup(dom), a = inf(dom), b = sup(dom)
                   + otherwise: a = inf(dom)/2, b = sup(dom)

      */
      if (sup(dom) == 0) then {
         a = 2/3 * inf(dom);
         b = 1/3 * inf(dom);
      } else {
         if (inf(dom) == 0) then {
            a = 1/3 * sup(dom);
        b = 2/3 * sup(dom);
         } else {
            if (inf(dom) != -sup(dom)) then {
          a = inf(dom);
          b = sup(dom);
        } else {
          a = inf(dom)/2;
          b = sup(dom);
        };
         };
      };

      if ((a != 0) && (~func(a) != 0)) then {
          oldPrec = prec;
          prec = max(2 * prec, ceil(-log2(abs(target))) * 4)!;
          c = log(abs(func(b)/func(a)))/log(abs(b/a));
          if ((~abs(c)) - 1b-1000 < 0) then {
             c = 0;
          } else {
             c := c;
          };
          c = round(c,floor(prec/2),RN);
          prec = oldPrec!;

          if ((c == c) && (abs(c) != infty) && (c > 0) && (c != 2) && (c != 1) && (!((0 in dom) && (c != floor(c))))) then {
             /* Now we have to check if sign * x^c effectively approximates func with

            We still have to determine sign: we just take the sign of func(a) * a.

             */

         if ((~func(a)) * a < 0) then sign = -1 else sign = 1;
             testfunc = simplifysafe(func/(sign * x^c));

         yOrig = dirtyEvaluateImage(func,dom);
         if (0 in dom) then {
            if (func(0) == 0) then {
               if (inf(dom) == 0) then {
                  yReduc = dirtyEvaluateImage(testfunc,[1b-1075; sup(dom)]);
               } else {
                  if (sup(dom) == 0) then {
                     yReduc = dirtyEvaluateImage(testfunc,[inf(dom); -1b-1075]);
              } else {
                     yReducA = dirtyEvaluateImage(testfunc,[inf(dom);-1b-1075]);
                     yReducB = dirtyEvaluateImage(testfunc,[1b-1075;sup(dom)]);
                     yReduc = [ min(inf(yReducA), inf(yReducB)) ; max(sup(yReducA), sup(yReducB)) ];
              };
               };
            } else {
              yReduc = dirtyEvaluateImage(testfunc,dom);
            };
         } else {
                  yReduc = dirtyEvaluateImage(testfunc,dom);
         };

             widthOrig = sup(yOrig) - inf(yOrig);
             widthReduc = sup(yReduc) - inf(yReduc);
             reducRatio = widthReduc / widthOrig;

             if ((reducRatio == reducRatio) && (abs(reducRatio) != infty) && (reducRatio <= maxReducRatio)) then {
                /* Now check if the divided function is not
               just 1 or something really close.
               If this were the case, we do not
               really have an argument reduction
               as we can always multiply by 1 without
               any change in the problem set.
            */
            testfuncjustone = false;
            if (sup(abs(yReduc - 1)) <= 2^(-(prec/2))) then {
               testfuncjustone = true;
            };

            if (!testfuncjustone) then {
                    result.okay = true;
                result.g = (sign * x^c);
                result.h = testfunc;
                result.ratio = reducRatio;
            };
             };
          };
      };

      return result;
};

procedure tryDetectParamountBehaviorArgRed(func, dom, maxReducRatio, target) {
      var detectors, result, res, detector, okay;
      var best;

      detectors = [|
                         tryDetectExponentialBehaviorArgRed,
                     tryDetectLogarithmicBehaviorArgRed,
             tryDetectPoweringBehaviorArgRed
              |];

      result = { .okay = false };
      okay = false;

      for detector in detectors do {

        res = detector(func, dom, maxReducRatio, target);

        if (res.okay) then {
           if (okay) then {
             if (abs(res.ratio) < abs(best.ratio)) then {
                best = res;
             };
           } else {
             best = res;
           };
           okay = true;
        };
      };

      if (okay) then {
         result = best;
      };

      return result;
};

procedure tryImplementationThroughArgumentReductionWithParamountBehavior(problemdef, parametrization) {
      var result, needArgumentReduction, res, myTableWidth, base, myDom, reducedFunc;
      var argRedTarget, myVariableFormat, myProblemdef, myParametrization;
      var suffix, origDefDom, resArgRed, doNotPerformParamountBehaviorArgRed, g, h, res2, myOutputFormat;
      var implementationcode;

      result = { .okay = false };

      match ( { .problemdef = problemdef,
                    .parametrization = parametrization } ) with
                { .problemdef =      { .func = default,
                                       .dom = default,
                                       .target = default,
                                       .variableFormat = default },
                  .parametrization = { .maxDegree = default,
                                       .minWidth = default,
                                       .beta = default,
                           .implementationFile = default,
                                       .gappaFile = default,
                                       .gappaOutputFile = default,
                                       .gappaExecutable = default,
                       .functionBasename = default,
                       .tableIndexWidth = default,
                       .minimalReductionRatio = default } } : {

                       /* Test if we may perform this type of argument
                          reduction
                       */
                       doNotPerformParamountBehaviorArgRed = false;
                       match (parametrization) with
                         { .doNotPerformParamountBehaviorArgRed = true } : { doNotPerformParamountBehaviorArgRed = true; }
                         default : { };

                       if (!doNotPerformParamountBehaviorArgRed) then {
                           /* Start with a test if the domain actually needs
                                              argument reduction in order to stay below the maximum
                          polynomial degree
                           */
                           needArgumentReduction = true;
                           res = checkIfSufficientDegree(problemdef.func, problemdef.dom, parametrization.maxDegree, problemdef.target);

                                           if (res.okay) then {
                                           if (res.sufficientDegree) then needArgumentReduction = false;
                           } else {
                               needArgumentReduction = false;
                           };

                           if (needArgumentReduction) then {
                              /* Here, we need to detect if we can use
                             the exponential argument reduction
                             for the given function
                          */

                          res = tryDetectParamountBehaviorArgRed(problemdef.func, problemdef.dom, (1 / parametrization.minimalReductionRatio), problemdef.target);

                          if (res.okay) then {
                             write("Argument reduction detection detected that the function can be split into f = g * h with\n");
                         write("    g(x) = ", res.g, " and\n");
                         write("    h(x) = ", res.h, "\n");
                         g = res.g;
                         h = res.h;

                         write("Trying to implement g\n");
                         myProblemdef.func = g;
                         myProblemdef.dom = problemdef.dom;
                         myProblemdef.target = 1/8 * (problemdef.target);
                         myProblemdef.variableFormat = problemdef.variableFormat;
                         suffix = "_paramount_behav_split_g";
                             origDefDom = problemdef.dom;
                             match (problemdef) with { .definitionDomain = default } : {
                                                          if (origDefDom in problemdef.definitionDomain) then {
                                                                                 origDefDom = problemdef.definitionDomain;
                                                                              }; }
                                                                         default : {};
                             myProblemdef.definitionDomain = origDefDom;
                             myParametrization = parametrization;
                             myParametrization.gappaFile = parametrization.gappaFile @ suffix;
                             myParametrization.gappaOutputFile = parametrization.gappaOutputFile @ suffix;
                             myParametrization.functionBasename = parametrization.functionBasename @ suffix;
                         myParametrization.doNotPerformParamountBehaviorArgRed = true;

                             res = tryImplementation(myProblemdef, myParametrization);

                         if (res.okay) then {
                            write("Subfunction g correctly implemented\n");

                            write("Trying to implement h\n");
                            myProblemdef.func = h;
                            myProblemdef.dom = problemdef.dom;
                            myProblemdef.target = 1/8 * (problemdef.target);
                            myProblemdef.variableFormat = problemdef.variableFormat;
                            suffix = "_paramount_behav_split_h";
                                origDefDom = problemdef.dom;
                                match (problemdef) with { .definitionDomain = default } : {
                                                             if (origDefDom in problemdef.definitionDomain) then {
                                                                                    origDefDom = problemdef.definitionDomain;
                                                                                 }; }
                                                                            default : {};
                                myProblemdef.definitionDomain = origDefDom;
                                myParametrization = parametrization;
                                myParametrization.gappaFile = parametrization.gappaFile @ suffix;
                                myParametrization.gappaOutputFile = parametrization.gappaOutputFile @ suffix;
                                myParametrization.functionBasename = parametrization.functionBasename @ suffix;
                            /* myParametrization.doNotPerformParamountBehaviorArgRed = true; */
                            myParametrization.implementationFile = parametrization.implementationFile @ "_subfunction_h";

                                res2 = tryImplementation(myProblemdef, myParametrization);

                            if (res2.okay) then {
                               write("Subfunction h correctly implemented\n");

                               bashexecute("cat " @ parametrization.implementationFile @ "_subfunction_h >> " @ parametrization.implementationFile);
                               bashexecute("rm " @ parametrization.implementationFile @ "_subfunction_h");
                               myOutputFormat = res.outputformat;
                               match (res2.outputformat) with
                                     D  : { }
                                 DD : { if (myOutputFormat == D) then myOutputFormat = DD; }
                                 TD : { myOutputFormat = TD; };
                               implementationcode = "\n";
                               implementationcode = implementationcode @ "void " @ parametrization.functionBasename @ "(";
                               implementationcode = implementationcode @ (match myOutputFormat with
                                                                D  : ( "double *res_resh, " )
                                                    DD : ( "double *res_resh, double *res_resm, " )
                                                    TD : ( "double *res_resh, double *res_resm, double *res_resl, " ));
                               implementationcode = implementationcode @ (match problemdef.variableFormat with
                                                                D  : ( "double xh" )
                                                    DD : ( "double xh, double xm" )
                                                    TD : ( "double xh, double xm, double xl"));
                                       implementationcode = implementationcode @ ") {\n";
                               match (res.outputformat) with
                                     D  : {
                                    implementationcode = implementationcode @ "double res_g_resh;\n";
                                      }
                                     DD : {
                                    implementationcode = implementationcode @ "double res_g_resh;\n";
                                    implementationcode = implementationcode @ "double res_g_resm;\n";
                                      }
                                     TD : {
                                    implementationcode = implementationcode @ "double res_g_resh;\n";
                                    implementationcode = implementationcode @ "double res_g_resm;\n";
                                    implementationcode = implementationcode @ "double res_g_resl;\n";
                                      };
                               match (res2.outputformat) with
                                     D  : {
                                    implementationcode = implementationcode @ "double res_h_resh;\n";
                                      }
                                     DD : {
                                    implementationcode = implementationcode @ "double res_h_resh;\n";
                                    implementationcode = implementationcode @ "double res_h_resm;\n";
                                      }
                                     TD : {
                                    implementationcode = implementationcode @ "double res_h_resh;\n";
                                    implementationcode = implementationcode @ "double res_h_resm;\n";
                                    implementationcode = implementationcode @ "double res_h_resl;\n";
                                      };
                               implementationcode = implementationcode @ "\n";
                               implementationcode = implementationcode @ res.functionname @ "(";
                               implementationcode = implementationcode @ (match (res.outputformat) with
                                                                D  : ( "&res_g_resh, " )
                                                    DD : ( "&res_g_resh, &res_g_resm, " )
                                                    TD : ( "&res_g_resh, &res_g_resm, &res_g_resl, "));
                               implementationcode = implementationcode @ (match (problemdef.variableFormat) with
                                                                D  : ( "xh" )
                                                    DD : ( "xh, xm" )
                                                    TD : ( "xh, xm, xl" ));
                               implementationcode = implementationcode @ ");\n";
                                                       implementationcode = implementationcode @ res2.functionname @ "(";
                               implementationcode = implementationcode @ (match (res2.outputformat) with
                                                                D  : ( "&res_h_resh, " )
                                                    DD : ( "&res_h_resh, &res_h_resm, " )
                                                    TD : ( "&res_h_resh, &res_h_resm, &res_h_resl, "));
                               implementationcode = implementationcode @ (match (problemdef.variableFormat) with
                                                                D  : ( "xh" )
                                                    DD : ( "xh, xm" )
                                                    TD : ( "xh, xm, xl" ));
                               implementationcode = implementationcode @ ");\n";
                               match (myOutputFormat) with
                                     D  : {
                                    implementationcode = implementationcode @ "*res_resh = res_g_resh * res_h_resh;\n";
                                                                  }
                                     DD : {
                                    match (res.outputformat) with
                                          D  : {
                                            implementationcode = implementationcode @ "Mul122(res_resh,res_resm,res_g_resh,res_h_resh,res_h_resm);\n";
                                               }
                                              DD : {
                                            match (res2.outputformat) with
                                                  D  : {
                                                            implementationcode = implementationcode @ "Mul122(res_resh,res_resm,res_h_resh,res_g_resh,res_g_resm);\n";
                                                   }
                                                      DD : {
                                                            implementationcode = implementationcode @ "Mul22(res_resh,res_resm,res_g_resh,res_g_resm,res_h_resh,res_h_resm);\n";
                                                   };
                                               };
                                      }
                                 TD : {
                                    match (res.outputformat) with
                                          D  : {
                                                implementationcode = implementationcode @ "Mul133(res_resh,res_resm,res_resl,res_g_resh,res_h_resh,res_h_resm,res_h_resl);\n";
                                               }
                                          DD : {
                                                implementationcode = implementationcode @ "Mul233(res_resh,res_resm,res_resl,res_g_resh,res_g_resm,res_h_resh,res_h_resm,res_h_resl);\n";
                                               }
                                          TD : {
                                            match (res2.outputformat) with
                                                  D  : {
                                                            implementationcode = implementationcode @ "Mul133(res_resh,res_resm,res_resl,res_h_resh,res_g_resh,res_g_resm,res_g_resl);\n";
                                                       }
                                                  DD : {
                                                            implementationcode = implementationcode @ "Mul233(res_resh,res_resm,res_resl,res_h_resh,res_h_resm,res_g_resh,res_g_resm,res_g_resl);\n";
                                                       }
                                                  TD : {
                                                            implementationcode = implementationcode @ "Mul33(res_resh,res_resm,res_resl,res_h_resh,res_h_resm,res_h_resl,res_g_resh,res_g_resm,res_g_resl);\n";
                                                       };
                                               };
                                      };
                               implementationcode = implementationcode @ "}\n";
                               write(implementationcode) >> parametrization.implementationFile;
                               result = res;
                               result.outputformat = myOutputFormat;
                               result.functionname = parametrization.functionBasename;
                            } else {
                              write("Could not implement subfunction h\n");
                            };
                         } else {
                           write("Could not implement subfunction g\n");
                         };
                          };
                           };
                         };
                     }
                default : { };

      return result;
};

procedure tryImplementationConstant(problemdef, parametrization) {
      var result, func, dom, target, ya, yb, yc, myConst, testfunc, oldPrec;
      var y, zerosUpper, zerosLower, myConstHi, myConstMi, myConstLo, myConstFormat;
      var implementation, oldDisplay;

      result = { .okay = false };

      match ( { .problemdef = problemdef,
                    .parametrization = parametrization } ) with
                { .problemdef =      { .func = default,
                                       .dom = default,
                                       .target = default,
                                       .variableFormat = default },
                  .parametrization = { .beta = default,
                           .implementationFile = default,
                                       .gappaFile = default,
                                       .gappaOutputFile = default,
                                       .gappaExecutable = default,
                       .functionBasename = default
                     } } : {
                       func = problemdef.func;
                       dom = problemdef.dom;
                       target = problemdef.target;
                       oldPrec = prec;
                       prec = max(prec, -floor(log2(target)) * 2)!;
                       ya = mid(evaluate(func,inf(dom)));
                       yb = mid(evaluate(func,sup(dom)));
                       yc = mid(evaluate(func,mid(dom)));
                       myConst := (ya + yb + yc) / 3;
                       prec = oldPrec!;
                       if ((abs(ya - yb) <= abs(ya * 1/4 * target)) &&
                           (abs(ya - yc) <= abs(ya * 1/4 * target)) &&
                       (abs(yb - yc) <= abs(yb * 1/4 * target))) then {
                      testfunc = simplifysafe((myConst/func) - 1);
                                      y = evaluate(testfunc, [mid(dom)]);
                                      if (y in [-1/4 * target, 1/4 * target]) then {
                                     zerosUpper = mydirtyfindzeros(testfunc + 1/4 * target, dom);
                                     zerosLower = mydirtyfindzeros(testfunc - 1/4 * target, dom);

                                     if ((zerosUpper == [||]) && (zerosLower == [||])) then {
                            write("Trying to replace the given function by the constant ", myConst, "\n");
                        myConstHi = simplifysafe(D(myConst));
                        myConstMi = simplifysafe(D(myConst - myConstHi));
                        myConstLo = simplifysafe(D(myConst - (myConstHi + myConstMi)));
                        if (abs(1/4 * target) < 1b-107) then {
                           myConstFormat = TD;
                           if (myConstLo == 0) then {
                              myConstFormat = DD;
                              if (myConstMi == 0) then {
                                 myConstFormat = D;
                              };
                           };
                        } else {
                          if (abs(1/4 * target) < 1b-53) then {
                            myConstFormat = DD;
                            if (myConstMi == 0) then {
                               myConstFormat = D;
                            };
                          } else {
                            myConstFormat = D;
                          };
                        };

                        implementation = "\n";
                        oldDisplay = display;
                        display = decimal!;
                        match myConstFormat with
                              D  : {
                                implementation = implementation @ "#define " @ parametrization.functionBasename @ "_const_hi " @ myConstHi @ "\n";
                                   }
                              DD : {
                                implementation = implementation @ "#define " @ parametrization.functionBasename @ "_const_hi " @ myConstHi @ "\n";
                                implementation = implementation @ "#define " @ parametrization.functionBasename @ "_const_mi " @ myConstMi @ "\n";
                                   }
                              TD : {
                                implementation = implementation @ "#define " @ parametrization.functionBasename @ "_const_hi " @ myConstHi @ "\n";
                                implementation = implementation @ "#define " @ parametrization.functionBasename @ "_const_mi " @ myConstMi @ "\n";
                                implementation = implementation @ "#define " @ parametrization.functionBasename @ "_const_lo " @ myConstLo @ "\n";
                                   };
                        implementation = implementation @ "\n";
                        display = oldDisplay!;
                        implementation = implementation @ "void " @ parametrization.functionBasename @ "(";
                        match myConstFormat with
                              D  : {
                                     implementation = implementation @ "double *res_resh, ";
                               }
                              DD : {
                                     implementation = implementation @ "double *res_resh, double *res_resm, ";
                               }
                              TD : {
                                     implementation = implementation @ "double *res_resh, double *res_resm, double *res_resl, ";
                               };
                        match problemdef.variableFormat with
                              D  : {
                                 implementation = implementation @ "double xh";
                               }
                              DD : {
                                 implementation = implementation @ "double xh, double xm";
                               }
                              TD : {
                                 implementation = implementation @ "double xh, double xm, double xl";
                               };
                            implementation = implementation @ ") {\n";
                        match myConstFormat with
                              D  : {
                                     implementation = implementation @ "*res_resh = " @ parametrization.functionBasename @ "_const_hi;\n";
                               }
                              DD : {
                                     implementation = implementation @ "*res_resh = " @ parametrization.functionBasename @ "_const_hi;\n";
                                     implementation = implementation @ "*res_resm = " @ parametrization.functionBasename @ "_const_mi;\n";
                               }
                              TD : {
                                     implementation = implementation @ "*res_resh = " @ parametrization.functionBasename @ "_const_hi;\n";
                                     implementation = implementation @ "*res_resm = " @ parametrization.functionBasename @ "_const_mi;\n";
                                     implementation = implementation @ "*res_resl = " @ parametrization.functionBasename @ "_const_lo;\n";
                               };
                            implementation = implementation @ "}\n\n";
                        write(implementation) > parametrization.implementationFile;
                        result.okay = true;
                        myFinalConst = match myConstFormat with
                                         D  : (myConstHi)
                                     DD : (myConstHi + myConstMi)
                                     TD : (myConstHi + myConstMi + myConstLo);
                        result.approxerr = mydirtyinfnorm(myFinalConst/func - 1,dom);
                        result.implerr = 0;
                            result.outputformat = myConstFormat;
                            result.functionname = parametrization.functionBasename;
                             };
                          };
                       };
                     }
                default : { };

      return result;
};

procedure computeAmplification(func,dom,maxeps) {
      var fp, fs, condf, theta, res;

      fp = diff(func);
      fs = diff(fp);
      cond = simplifysafe(x * (fp/func));
      theta = simplifysafe((x^2)/func);

      res = dirtyEvaluateImage(cond,dom) +
            [-abs(maxeps);abs(maxeps)] * dirtyEvaluateImage(theta,dom) * dirtyEvaluateImage(fs,[inf(dom) * (1 - abs(maxeps));sup(dom) * (1 + abs(maxeps))]);

          // "func = ", func, ", dom = ", dom, ", maxeps = ", maxeps, ", alpha = ", sup(abs(res));

      return sup(abs(res));
};

/* Computes the maximum error res in the argument X = x * (1 + res) of func
   such that func(X) = func(x) * (1 + eps) with abs(eps) <= maxeps.

   This function works only if func(x) = exp(x).

*/
procedure computeNeededAccuracyOfArgumentSpecialCaseExponential(func, dom, maxeps) {
      var res, subdoms, d, domcut, subdomsPrime, reseps, teps;

      res = { .okay = false };

      if (func == exp(x)) then {
         subdoms = [| dom |];
         domcut = true;
         while (domcut) do {
               domcut = false;
           subdomsPrime = [||];
           for d in subdoms do {
               if (0 in d) then {
                  subdomsPrime = [inf(d); 0] .: [0; sup(d)] .: subdomsPrime;
              domcut = true;
               } else {
                  if (sup(d) > 1) then {
                 if (inf(d) > 1) then {
                    subdomsPrime = d .: subdomsPrime;
                 } else {
                    subdomsPrime = [inf(d); 1] .: [1; sup(d)] .: subdomsPrime;
                 };
              } else {
                             if (inf(d) < -1) then {
                   if (sup(d) < -1) then {
                                 subdomsPrime = d .: subdomsPrime;
                   } else {
                                 subdomsPrime = [inf(d); -1] .: [-1; sup(d)] .: subdomsPrime;
                   };
                 } else {
                   subdomsPrime = d .: subdomsPrime;
                 };
              };
               };
           };
           subdoms = subdomsPrime;
         };


         reseps = 1;
         for d in subdoms do {
             if (mid(d) > 0) then {
            if (sup(d) > 0) then {
              teps = min(abs(log1p(-maxeps)/sup(d)), abs(log1p(maxeps)/sup(d)));
            } else {
              teps = 1;
            };
         } else {
            if (inf(d) < 0) then {
              teps = min(abs(log1p(-maxeps)/inf(d)), abs(log1p(maxeps)/inf(d)));
            } else {
              teps = 1;
            };
         };
         if (abs(teps) > 1) then teps = 1;
         reseps = min(reseps, abs(teps));
         };

         res = { .okay = true, .res = reseps };
      };

      return res;
};

/* Computes the maximum error res in the argument X = x * (1 + res) of func
   such that func(X) = func(x) * (1 + eps) with abs(eps) <= maxeps.

   This function works only if func(x) = a^x, with a a positive real.

*/
procedure computeNeededAccuracyOfArgumentSpecialCaseGeneralExponential(func, dom, maxeps) {
      var res;

      res = { .okay = false };

      match (func) with
           a^x     : {
                             if (a > 0) then {
                            res = computeNeededAccuracyOfArgumentSpecialCaseExponential(exp(x), dom * log(a), maxeps);
                             };
                     }
               default : {
                     };

      return res;
};

/* Computes the maximum error res in the argument X = x * (1 + res) of func
   such that func(X) = func(x) * (1 + eps) with abs(eps) <= maxeps.

   This function works on special cases only.
*/
procedure computeNeededAccuracyOfArgumentSpecialCases(func, dom, maxeps) {
      var res, r, found, cNAOASC;
      var computeNeededAccuracyOfArgumentSpecialCasesList;

      computeNeededAccuracyOfArgumentSpecialCasesList = [|
                computeNeededAccuracyOfArgumentSpecialCaseExponential,
                computeNeededAccuracyOfArgumentSpecialCaseGeneralExponential
      |];

      res = { .okay = false };

      while ((!res.okay) && (computeNeededAccuracyOfArgumentSpecialCasesList != [||])) do {
        cNAOASC = head(computeNeededAccuracyOfArgumentSpecialCasesList);
        res = cNAOASC(func, dom, maxeps);
        computeNeededAccuracyOfArgumentSpecialCasesList = tail(computeNeededAccuracyOfArgumentSpecialCasesList);
      };

      return res;
};

/* Computes the maximum error res in the argument X = x * (1 + res) of func
   such that func(X) = func(x) * (1 + eps) with abs(eps) <= maxeps.
*/
procedure computeNeededAccuracyOfArgument(func, dom, maxeps) {
      var res, okay, alpha, newres;
      var specialRes;

      specialRes = computeNeededAccuracyOfArgumentSpecialCases(func, dom, maxeps);

      if (specialRes.okay) then {
         res = specialRes.res;
      } else {

          res = 1b-1;
          okay = false;

          while (!okay) do {
            alpha = abs(computeAmplification(func, dom, res));
            newres = abs(maxeps) * 1/alpha;
            if (newres > 1b-1) then newres = 1b-1;
            if ((newres >= 1/2 * res) || (newres == 0)) then {
              if (newres == 0) then res = 1b-165;
              okay = true;
            } else {
              res = newres;
            };
          };

          if (res > 0) then {
              okay = false;
              while (!okay) do {
                alpha = abs(computeAmplification(func, dom, res));
                if (alpha * res > abs(maxeps)) then {
                   okay = true;
                } else {
                   res = 2 * res;
                   if (res > 1) then okay = true;
                };
              };
              res = 1/2 * res;
              };

          alpha = abs(computeAmplification(func, dom, res));
          if (alpha * res > abs(maxeps)) then {
             res = 0;
          };

      };

      return res;
};

procedure computeNeededAccuracyOfArgumentTrisect(func, dom, maxeps, minWidth) {
      var res, w, a, b;

      res = computeNeededAccuracyOfArgument(func, dom, maxeps);

      a = inf(dom);
      b = sup(dom);
      w = b - a;

      if ((res == 0) && (w > minWidth)) then {

          res = min( computeNeededAccuracyOfArgumentTrisect(func, [a; round(a + 1/3 * w,max(300,prec),RU)], maxeps, minWidth),
                     computeNeededAccuracyOfArgumentTrisect(func, [round(a + 1/3 * w, max(300, prec), RD); round(a + 2/3 * w, max(300, prec), RU)], maxeps, minWidth),
             computeNeededAccuracyOfArgumentTrisect(func, [round(a + 2/3 * w, max(300, prec), RD); b], maxeps, minWidth));

      };

      return res;
};

procedure computeNeededAccuracyOfArgumentWorkHard(func, dom, maxeps) {
      var res;

      res = computeNeededAccuracyOfArgumentTrisect(func, dom, maxeps, (sup(dom) - inf(dom)) / 2187);

      return res;
};

procedure tryImplementationThroughSquaring(problemdef, parametrization) {
      var result, splitPoints, needToDetectSymmetry, res;
      var g, func, myDom, epsRed, redArgFormat, myProblemdef, myParametrization;
      var variableDeclarations, reductionCode, implementationCode;
      var oP;

      result = { .okay = false };

      match ( { .problemdef = problemdef,
                    .parametrization = parametrization } ) with
                { .problemdef =      { .func = default,
                                       .dom = default,
                                       .target = default,
                                       .variableFormat = default },
                  .parametrization = { .maxDegree = default,
                                       .minWidth = default,
                                       .beta = default,
                           .implementationFile = default,
                                       .gappaFile = default,
                                       .gappaOutputFile = default,
                                       .gappaExecutable = default,
                       .functionBasename = default } } : {

                       /* Start with a test if zero is actually inside the domain
                          and if width of reduced domain smaller than 1/4 of the width of
                      the original domain.
                       */
                       if ((sup(problemdef.dom) * inf(problemdef.dom) < 0) &&
                           (((max(inf(problemdef.dom),sup(problemdef.dom)))^2) <= (1/4 * (sup(problemdef.dom) - inf(problemdef.dom))))) then {

                       /* Continue with a test if the domain actually needs
                                          to be split in order to stay below the maximum
                      polynomial degree
                        */
                       needToDetectSymmetry = true;
                       res = checkIfSufficientDegree(problemdef.func, problemdef.dom, parametrization.maxDegree, problemdef.target);

                                       if (res.okay) then {
                                       if (res.sufficientDegree) then needToDetectSymmetry = false;
                       } else {
                           needToDetectSymmetry = false;
                       };

                       if (needToDetectSymmetry) then {

                            /* Try to detect a symmetry of func around 0 */
                        res = tryDetectSymmetry(problemdef.func, problemdef.dom, problemdef.target * 1/8);

                        if (res.okay) then {
                           /* If we detected a symmetry, check if it
                              is an even symmetry
                           */
                           if (res.evenSymmetry) then {
                              /* Here, we have detected an even symmetry

                             We continue by computing the amplification
                             alpha of a reduction error eps by the function

                             g(x) = f(sqrt(x))

                             This indicates us the following:

                             g(x^2 * (1 + eps)) =
                               = g(x^2) * (1 + alpha * eps)
                               = f(sqrt(x^2)) * (1 + alpha * eps)
                               = f(x) * (1 + alpha * eps)

                          */
                          func = problemdef.func;
                          g = simplifysafe(func(sqrt(x)));
                          oP = prec;
                          prec = max(300, prec)!;
                          myDom = [0;(max(inf(problemdef.dom),sup(problemdef.dom)))^2];
                          prec = oP!;
                          alpha = computeAmplification(g,[1b-1074;(max(inf(problemdef.dom),sup(problemdef.dom)))^2],1b-53);
                          write("The amplification factor of the even function is approximately ", round(alpha,12,RN), " = 2^(", round(log2(alpha),12,RN),")\n");

                          /* Now determine a bound epsRed on the error of the reduced argument */
                          match (problemdef.variableFormat) with
                            D  : {
                                if (1b-53 * alpha < 1/8 * problemdef.target) then {
                                   epsRed = 1b-53;
                                   redArgFormat = D;
                                } else {
                                   epsRed = 0;
                                   redArgFormat = DD;
                                };
                                 }
                            DD : {
                                if (1b-102 * alpha < 1/8 * problemdef.target) then {
                                   epsRed = 1b-102;
                                   redArgFormat = DD;
                                } else {
                                   epsRed = 1b-150;
                                   redArgFormat = TD;
                                };
                                 }
                            TD : {
                                epsRed = 1b-150;
                                redArgFormat = TD;
                                 };

                          /* Now check if we can do the target error with that argument
                             reduction
                          */
                          if (epsRed * alpha < 1/8 * problemdef.target) then {
                             write("Trying to implement the function with a squaring of the argument on the first place\n");
                             write("The \"reduced\" argument will be represented on a ", redArgFormat, "\n");
                             write("The reduced function is ", g, "\n");
                             write("It will be implemented on ", myDom, "\n");

                             myProblemdef.func = g;
                             myProblemdef.dom = myDom;
                             myProblemdef.target = 1/8 * (problemdef.target);
                             myProblemdef.variableFormat = redArgFormat;
                             suffix = "_squaring";
                                 myProblemdef.definitionDomain = myDom;
                                 myParametrization = parametrization;
                                 myParametrization.gappaFile = parametrization.gappaFile @ suffix;
                                 myParametrization.gappaOutputFile = parametrization.gappaOutputFile @ suffix;
                                 myParametrization.functionBasename = parametrization.functionBasename @ suffix;
                             myParametrization.minWidth = (sup(myDom) - inf(myDom)) * 1/2;

                             res = tryImplementation(myProblemdef, myParametrization);

                             if (res.okay) then {
                               write("The subfunction has been correctly implemented\n");

                               /* Now generate the reduction code */
                               variableDeclarations = "\n";
                               reductionCode = "\n";

                               match (redArgFormat) with
                                     D  : {
                                    variableDeclarations = variableDeclarations @ "double zh;\n";
                                  }
                                     DD : {
                                    variableDeclarations = variableDeclarations @ "double zh;\n";
                                    variableDeclarations = variableDeclarations @ "double zm;\n";
                                  }
                                     TD : {
                                    variableDeclarations = variableDeclarations @ "double zh;\n";
                                    variableDeclarations = variableDeclarations @ "double zm;\n";
                                    variableDeclarations = variableDeclarations @ "double zl;\n";
                                  };

                               match (redArgFormat) with
                                     D  : {
                                    reductionCode = reductionCode @ "zh = xh * xh;\n";
                                      }
                                     DD : {
                                    match (problemdef.variableFormat) with
                                          D  : {
                                            reductionCode = reductionCode @ "Mul12(&zh,&zm,xh,xh);\n";
                                               }
                                          DD : {
                                            reductionCode = reductionCode @ "Mul22(&zh,&zm,xh,xm,xh,xm);\n";
                                               };
                                      }
                                     TD : {
                                            match (problemdef.variableFormat) with
                                          DD : {
                                            reductionCode = reductionCode @ "Mul23(&zh,&zm,&zl,xh,xm,xh,xm);\n";
                                               }
                                          TD : {
                                            reductionCode = reductionCode @ "Mul33(&zh,&zm,&zl,xh,xm,xl,xh,xm,xl);\n";
                                               };

                                      };

                               reductionCode = reductionCode @ (res.functionname) @ "(";
                               reductionCode = reductionCode @ (match (res.outputformat) with
                                                        D  : ( "res_resh, " )
                                            DD : ( "res_resh, res_resm, " )
                                            TD : ( "res_resh, res_resm, res_resl, " ));
                               reductionCode = reductionCode @ (match (redArgFormat) with
                                                              D  : ( "zh" )
                                                  DD : ( "zh, zm" )
                                                  TD : ( "zh, zm, zl" ));
                               reductionCode = reductionCode @ ");\n";

                               implementationCode = "\n";
                               implementationCode = implementationCode @ "void " @ parametrization.functionBasename @ "(";
                               implementationCode = implementationCode @ (match (res.outputformat) with
                                                                D  : ( "double *res_resh, " )
                                                    DD : ( "double *res_resh, double *res_resm, " )
                                                    TD : ( "double *res_resh, double *res_resm, double *res_resl, " ));
                               implementationCode = implementationCode @ (match (problemdef.variableFormat) with
                                                                D  : ( "double xh" )
                                                    DD : ( "double xh, double xm" )
                                                    TD : ( "double xh, double xm, double xl" ));
                               implementationCode = implementationCode @ ") {\n";
                               implementationCode = implementationCode @ variableDeclarations @ "\n" @ reductionCode @ "\n}\n";

                               write(implementationCode) >> parametrization.implementationFile;
                               result.approxerr = res.approxerr;
                               result.implerr = (1 + abs(res.implerr)) * (1 + abs(epsRed * alpha)) * (1 + abs(1/8 * problemdef.target)) - 1;
                                   result.outputformat = res.outputformat;
                                   result.functionname = parametrization.functionBasename;
                               result.okay = true;
                             } else {
                               write("Could not implement the subfunction\n");
                             };
                          };
                           };
                        };
                       };
                       };
                     }
                default : { };

      return result;
};

procedure tryDetectLogarithmArgRed(func, dom, target) {
      var result, base, a, b, c, d, ratio, oldPrec, testfunc;
      var y, zerosUpper, zerosLower;

      result = { .okay = false };

      /* We have to detect if func behaves in dom
         like

         log(x)/log(base)

         We say that func behaves like log(x)/log(base)
         if

         log(x)/log(base) = func * (1 + eps) with abs(eps) <= target.

         We start by computing a possible base
         as

         base = exp()

             where dom = [a;b]

         We can stop trying if the interval contains zero
         or any negative number.

      */
      a = inf(dom);
      b = sup(dom);
      if (a > 0) then {
          oldPrec = prec;
          prec = max(2 * prec, ceil(-log2(abs(target))) * 4)!;
          base := exp((log(b) - log(a))/(func(b) - func(a)));
          prec = oldPrec!;

          /* Now we have to check if log(x)/log(base) effectively approximates func with
             an accuracy of target
          */
          testfunc = simplifysafe((log(x)/log(base))/func - 1);
          y = evaluate(testfunc, mid(dom));
          if (y in [-target, target]) then {
              zerosUpper = mydirtyfindzeros(testfunc + target, dom);
          zerosLower = mydirtyfindzeros(testfunc - target, dom);

          if ((zerosUpper == [||]) && (zerosLower == [||])) then {
              if (base != 1) then {
                              result.okay = true;
                          result.logarithmicFunc = simplifysafe(log(x)/log(base));
                      result.logarithmBase = base;
              };
              };
              };
      };
      return result;
};

procedure tryImplementationThroughArgumentReductionLogarithm(problemdef, parametrization) {
      var result, needArgumentReduction, res, base, func, w, minM, maxM, meanM, r;
      var doNotPerformLogarithmArgRed, reciprocalTable, oldDisplay, logTableHi, logTableMi, logTableLo;
      var minZ, maxZ, logR, logRHi, logRMi, logRLo, reducedDom, alpha, g, minAbsLogM;
      var reductionMultiplicationError, multiplicationOnDouble, reductionErrBound;
      var reducedArgumentFormat, poundDefines, variableDeclarations, reductionCode, reconstructionCode;
      var outputFormat, rcprLog2, rcprLog2Hi, rcprLog2Mi, rcprLog2Lo, implementationCode;
      var oldPrec;

      result = { .okay = false };

      match ( { .problemdef = problemdef,
                    .parametrization = parametrization } ) with
                { .problemdef =      { .func = default,
                                       .dom = default,
                                       .target = default,
                                       .variableFormat = default },
                  .parametrization = { .maxDegree = default,
                                       .minWidth = default,
                                       .beta = default,
                           .implementationFile = default,
                                       .gappaFile = default,
                                       .gappaOutputFile = default,
                                       .gappaExecutable = default,
                       .functionBasename = default,
                       .tableIndexWidth = default } } : {

                       /* Test if we may perform this type of argument
                          reduction
                       */
                       doNotPerformLogarithmArgRed = false;
                       match (parametrization) with
                             { .doNotPerformLogarithmArgRed = true } : { doNotPerformLogarithmArgRed = true; }
                         default : { };

                       /* Check also if the table index width is large enough for the
                          argument reduction used for logarithms
                       */
                       if ((!doNotPerformLogarithmArgRed) && (parametrization.tableIndexWidth > 2)) then {
                           /* Start with a test if the domain actually needs
                                              argument reduction in order to stay below the maximum
                          polynomial degree
                           */
                           needArgumentReduction = true;
                           res = checkIfSufficientDegree(problemdef.func, problemdef.dom, parametrization.maxDegree, problemdef.target);

                                           if (res.okay) then {
                                           if (res.sufficientDegree) then needArgumentReduction = false;
                           } else {
                               needArgumentReduction = false;
                           };

                           if (needArgumentReduction) then {
                              /* Here, we need to detect if we can use
                             the logarithm argument reduction
                             for the given function
                          */

                          res = tryDetectLogarithmArgRed(problemdef.func, problemdef.dom, problemdef.target * 1/8);

                          if (res.okay) then {
                             write("Detected that the given function can be replaced with a logarithm with a base that approximately is ", round(res.logarithmBase,53,RN), "\n");
                         func = res.logarithmicFunc;
                         base = res.logarithmBase;

                         /* We know that we can implement the given function as

                            func(x) = log2(x)/log2(base) = log2(2^E * m)/log2(base) =
                                    = (E + log2(m))/log2(base) =
                                = E * 1/log2(base) + log(m)/log(base) =
                                = E * 1/log2(base) + log(m * r * 1/r)/log(base)
                                = E * 1/log2(base) + (log(m * r) + log(1/r))/log(base)
                                = E * 1/log2(base) + log(1/r)/log(base) + log(m * r - 1 + 1)/log(base)
                                = E * 1/log2(base) + log(1/r)/log(base) + log1p(m * r - 1)/log(base)
                                = E * 1/log2(base) + log(1/r)/log(base) + log1p(z)/log(base)

                                with z = m * r - 1

                            The values r and log(1/r)/log(base) are read in tables, indexed
                            with the first w mantissa bits of m. Here, w is the table width.
                            If the index is above some value (approx. sqrt(2)) the exponent
                            of m gets adjusted so that m finally always stays in
                            1/sqrt < m < sqrt(2).
                            The value r approximates 1/m up to w bits (approximately,
                            the precise value of the error gets computed below).
                            We round the values of r to w+2 bits, which makes
                            error analysis easier.

                            With a loop, we go now over all indices to the table for
                            r and determine:
                              * the value of r
                              * the minimum and maximum value of m for that index
                              * the minimum and maximum z = m * r - 1 for that index
                         */
                         w = parametrization.tableIndexWidth;

                         maxindex.determined = false;
                         maxindex.index = 0;
                         minZ = 5;
                         maxZ = -5;
                         minAbsLogM = 5;
                         reciprocalTable = "static const double " @ (parametrization.functionBasename) @ "_rcpr_tbl[" @ (~(2^w + 1)) @ "] = {\n";
                         logTableHi = "static const double " @ (parametrization.functionBasename) @ "_log_rcpr_tbl_hi[" @ (~(2^w + 1)) @ "] = {\n";
                         logTableMi = "static const double " @ (parametrization.functionBasename) @ "_log_rcpr_tbl_mi[" @ (~(2^w + 1)) @ "] = {\n";
                         logTableLo = "static const double " @ (parametrization.functionBasename) @ "_log_rcpr_tbl_lo[" @ (~(2^w + 1)) @ "] = {\n";
                         oldDisplay = display;
                         display = decimal!;
                         for i from 0 to 2^w do {
                             minM = 1 + (i - 0.5) * 2^(-w);
                             maxM = 1 + (i + 0.5) * 2^(-w);
                             meanM = (minM + maxM) / 2;
                             minM = max(minM, 1);
                             maxM = min(maxM, 2);
                             r = round(~(1/meanM),w+2,RN);
                             if (meanM >= sqrt(2)) then {
                                rAdjusted = r * 2;
                            if (!maxindex.determined) then {
                               maxindex.determined = true;
                               maxindex.index = i;
                            };
                             } else {
                               rAdjusted = r;
                             };
                             minZ = min(minZ, minM * r - 1, maxM * r - 1);
                             maxZ = max(maxZ, minM * r - 1, maxM * r - 1);
                             reciprocalTable = reciprocalTable @ "   " @ r;
                             if (i != 2^w) then {
                                reciprocalTable = reciprocalTable @ ",";
                             };
                             reciprocalTable = reciprocalTable @ "\n";
                             logR = -log(rAdjusted) / log(base);
                             logRHi = D(logR);
                             logRMi = D(logR - logRHi);
                             logRLo = D(logR - (logRHi + logRMi));
                             logTableHi = logTableHi @ "   " @ logRHi;
                             logTableMi = logTableMi @ "   " @ logRMi;
                             logTableLo = logTableLo @ "   " @ logRLo;
                             if (i != 2^w) then {
                                logTableHi = logTableHi @ ",";
                                logTableMi = logTableMi @ ",";
                                logTableLo = logTableLo @ ",";
                             };
                             logTableHi = logTableHi @ "\n";
                             logTableMi = logTableMi @ "\n";
                             logTableLo = logTableLo @ "\n";

                             if (abs(r) != 2^(nearestint(log2(abs(r))))) then {
                                minAbsLogM = min(minAbsLogM, inf(abs(log([minM;maxM])/log(base))));
                             };
                         };
                         reciprocalTable = reciprocalTable @ "};\n";
                         logTableHi = logTableHi @ "};\n";
                         logTableMi = logTableMi @ "};\n";
                         logTableLo = logTableLo @ "};\n";
                             display = oldDisplay!;
                         reducedDom = [minZ;maxZ];

                         /* Now check if the width of the domain
                            after argument reduction is really
                            smaller than the one of the original
                            domain.
                         */
                         if (sup(reducedDom) - inf(reducedDom) < sup(problemdef.dom) - inf(problemdef.dom)) then {
                            /* Now compute an upper bound on the amplification factor alpha by which a relative
                               error on the reduced argument is amplified by the reduced function
                               log(1 + x)/log(base). This yields the target error on the argument reduction.
                            */
                            g = simplifysafe(log1p(x)/log(base));
                            alpha = computeAmplification(g,reducedDom,1b-53);
                            reductionTargetError = problemdef.target * 1/8 * 1/abs(alpha);

                            /* The argument reduction z = m * r - 1 is subject to cancellation
                               at the substraction of 1, as m * r is approximately 1 due
                               to r ~ 1/m.

                               There are two cases for the multiplication:

                               (i)  The multiplication is always exact as it is performed with
                                    a Fast2Mul. So the only error comes from the subtraction
                                or the truncation of the reduced argument to a D, DD or TD.

                               (ii) The multiplication is performed on double precision only.
                                    In the case when r is not an integer power of 2, there
                                is some relative multiplication error that gets amplified
                                by the cancellation at the subtraction.

                                We have (for E = 0 -- the other cases are simpler):

                                log(x) = log(2^E * m) = E + log(1/r) + log(m * r - 1 + 1) =
                                       = log(1/r) + log(m * r - 1 + 1)

                                    and hence

                                log(m * r * (1 + eps) - 1 + 1) = log(m) * (1 + 1/log(m) * log(1 + eps))

                                Here, log(1 + eps) behaves like eps and 1/log(m) like an amplification
                                factor.

                                So, we determine the overall error 1/log(m) * log(1 + eps) for
                            abs(eps) <= 1b-53 and abs(1/log(m)) = 1/minAbsLogM.

                            If this error is less than 1/8 * problemdef.target, we can perform
                            the multiplication on a double, otherwise we have to perform it
                            with a Fast2Mul.

                            */
                            reductionMultiplicationError = 1/minAbsLogM * sup(abs(log1p([-1b-53;1b-53])/log(base)));

                            if (reductionMultiplicationError <= problemdef.target * 1/8) then {
                               multiplicationOnDouble = true;
                               reductionErrBound = reductionMultiplicationError;
                               reducedArgumentFormat = D;
                            } else {
                               multiplicationOnDouble = false;
                               if (abs(reductionTargetError) < 1b-102) then {
                                 reducedArgumentFormat = TD;
                               } else {
                                 if (abs(reductionTargetError) < 1b-52) then {
                                reducedArgumentFormat = DD;
                                reductionErrBound = 1b-102 * computeAmplification(g,reducedDom,1b-102);
                             } else {
                                reducedArgumentFormat = D;
                                reductionErrBound = 1b-53 * computeAmplification(g,reducedDom,1b-53);
                             };
                               };
                            };
                            if ((!multiplicationOnDouble) && (problemdef.variableFormat == D)) then {
                               reducedArgumentFormat = DD;
                               reductionErrBound = 0;
                            };

                            /* Now generate the code for the argument reduction */
                            poundDefines = "\n";
                            variableDeclarations = "\n";
                            reductionCode = "\n";
                            reconstructionCode = "\n";

                            /* Decompose x = 2^E * m, compute the index to the tables and if the
                               variable format is wider than double precision, compute
                               a scaling to the middle and lower components
                            */
                            variableDeclarations = variableDeclarations @ "db_number argRedCaster;\n";
                            variableDeclarations = variableDeclarations @ "int E;\n";
                            variableDeclarations = variableDeclarations @ "int index;\n";
                            reductionCode = reductionCode @ "argRedCaster.d = xh;\n";
                            if (inf(abs(problemdef.dom)) < 0x0010000000000000) then {
                              reductionCode = reductionCode @ "E = 0;\n";
                              reductionCode = reductionCode @ "if (argRedCaster.l < 0x0010000000000000) {\n";
                              reductionCode = reductionCode @ "argRedCaster.d *= 9007199254740992.0;\n";
                              reductionCode = reductionCode @ "E -= 53;\n";
                              reductionCode = reductionCode @ "}\n";
                              reductionCode = reductionCode @ "E += (int) ((argRedCaster.l >> 52) - 1023ll);\n";
                            } else {
                              reductionCode = reductionCode @ "E = (int) ((argRedCaster.l >> 52) - 1023ll);\n";
                            };
                            if (problemdef.variableFormat != D) then {
                               variableDeclarations = variableDeclarations @ "db_number scaleCaster;\n";
                               variableDeclarations = variableDeclarations @ "double scale;\n";
                               if (inf(abs(problemdef.dom)) < 0x0010000000000000) then {
                                   reductionCode = reductionCode @ "scaleCaster.l = 1023 - (E >= -1023 ? E : -1023);\n";
                               } else {
                                   reductionCode = reductionCode @ "scaleCaster.l = 1023 - E;\n";
                                                       };
                               reductionCode = reductionCode @ "scaleCaster.l <<= 52;\n";
                               reductionCode = reductionCode @ "scale = scaleCaster.d;\n";
                            };
                            reductionCode = reductionCode @ "index = (int) ((argRedCaster.l & 0x000fffffffffffffull) >> (52 - " @ (parametrization.functionBasename) @ "_tablewidth - 1));\n";
                            oldDisplay = display;
                            display = decimal!;
                            poundDefines = poundDefines @ "#define " @ (parametrization.functionBasename) @ "_tablewidth " @ w @ "\n";
                            poundDefines = poundDefines @ "#define " @ (parametrization.functionBasename) @ "_maxindex " @ (maxindex.index) @ "\n";
                            display = oldDisplay!;
                            reductionCode = reductionCode @ "index = (index + 1) >> 1;\n";
                            reductionCode = reductionCode @ "if (index >= " @ (parametrization.functionBasename) @ "_maxindex) E++;\n";
                            variableDeclarations = variableDeclarations @ "double ed;\n";
                            reductionCode = reductionCode @ "ed = (double) E;\n";
                            reductionCode = reductionCode @ "argRedCaster.l = (argRedCaster.l & 0x800fffffffffffffull) | 0x3ff0000000000000ull;\n";
                            variableDeclarations = variableDeclarations @ "double m;\n";
                            reductionCode = reductionCode @ "m = argRedCaster.d;\n";

                            /* Read r in reciprocal table */
                            variableDeclarations = variableDeclarations @ "double r;\n";
                            reductionCode = reductionCode @ "r = " @ (parametrization.functionBasename) @ "_rcpr_tbl[index];\n";

                            /* Generate z = m * r - 1 for the different precisions */
                            if (multiplicationOnDouble) then {
                               variableDeclarations = variableDeclarations @ "double zh;\n";
                               match (problemdef.variableFormat) with
                                     D  : {
                                              reductionCode = reductionCode @ "zh = m * r - 1.0;\n";
                                      }
                                     DD : {
                                              reductionCode = reductionCode @ "zh = (m * r - 1.0) + ((scale * xm) * r);\n";
                                      }
                                     TD : {
                                      variableDeclarations = variableDeclarations @ "double rxmh, rxml, sxm;\n";
                                                                      reductionCode = reductionCode @ "sxm = scale * xm;\n";
                                      reductionCode = reductionCode @ "Mul12(&rxmh, &rxml, r, sxm);\n";
                                      reductionCode = reductionCode @ "zh = ((m * r - 1.0) + rxmh) + (rxml + scale * xl);\n";
                                      };
                            } else {
                              match reducedArgumentFormat with
                                    D  : {
                                                  variableDeclarations = variableDeclarations @ "double zh;\n";
                                      variableDeclarations = variableDeclarations @ "double mrh, mrl;\n";
                                      reductionCode = reductionCode @ "Mul12(&mrh,&mrl,m,r);\n";
                                      match (problemdef.variableFormat) with
                                            D  : {
                                             reductionCode = reductionCode @ "zh = (mrh - 1.0) + mrl;\n";
                                             }
                                            DD : {
                                                 variableDeclarations = variableDeclarations @ "double sxm;\n";
                                             variableDeclarations = variableDeclarations @ "double rxmh, rxml;\n";
                                                                                     reductionCode = reductionCode @ "sxm = scale * xm;\n";
                                                                                     reductionCode = reductionCode @ "Mul12(&rxmh,&rxml,r,sxm);\n";
                                             reductionCode = reductionCode @ "zh = (((mrh - 1.0) + mrl) + rxmh) + rxml;\n";
                                             }
                                            TD : {
                                             variableDeclarations = variableDeclarations @ "double sxm;\n";
                                             variableDeclarations = variableDeclarations @ "double sxl;\n";
                                             variableDeclarations = variableDeclarations @ "double rxmh, rxml;\n";
                                             variableDeclarations = variableDeclarations @ "double rxlh, rxll;\n";
                                             variableDeclarations = variableDeclarations @ "double temph, templ;\n";
                                                                                     reductionCode = reductionCode @ "sxm = scale * xm;\n";
                                                                                     reductionCode = reductionCode @ "sxl = scale * xl;\n";
                                                                                     reductionCode = reductionCode @ "Mul12(&rxmh,&rxml,r,sxm);\n";
                                                                                     reductionCode = reductionCode @ "Mul12(&rxlh,&rxll,r,sxl);\n";
                                                                                     reductionCode = reductionCode @ "Add12Cond(temph,templ,rxml,rxlh);\n";
                                             reductionCode = reductionCode @ "zh = ((((mrh - 1.0) + mrl) + rxmh) + temph) + templ;\n";
                                             };
                                     }
                                    DD : {
                                                  variableDeclarations = variableDeclarations @ "double zh;\n";
                                                  variableDeclarations = variableDeclarations @ "double zm;\n";
                                      variableDeclarations = variableDeclarations @ "double mrh, mrl;\n";
                                      reductionCode = reductionCode @ "Mul12(&mrh,&mrl,m,r);\n";
                                      match (problemdef.variableFormat) with
                                            D  : {
                                             variableDeclarations = variableDeclarations @ "double temp;\n";
                                                 reductionCode = reductionCode @ "temp = mrh - 1.0;\n";
                                             reductionCode = reductionCode @ "Add12(zh,zm,temp,mrl);\n";
                                             }
                                            DD : {
                                             variableDeclarations = variableDeclarations @ "double sxm;\n";
                                             variableDeclarations = variableDeclarations @ "double temp;\n";
                                             variableDeclarations = variableDeclarations @ "double rxmh, rxml;\n";
                                             variableDeclarations = variableDeclarations @ "double temp2h, temp2l;\n";
                                             variableDeclarations = variableDeclarations @ "double temp3;\n";
                                                                                     reductionCode = reductionCode @ "sxm = scale * xm;\n";
                                                                                     reductionCode = reductionCode @ "Mul12(&rxmh,&rxml,r,sxm);\n";
                                             reductionCode = reductionCode @ "temp = mrh - 1.0;\n";
                                             reductionCode = reductionCode @ "Add12(temp2h,temp2l,temp,mrl);\n";
                                             reductionCode = reductionCode @ "temp3 = temp2l + sxm;\n";
                                             reductionCode = reductionCode @ "Add12(zh,zm,temp2h,temp3);\n";
                                             }
                                            TD : {
                                             variableDeclarations = variableDeclarations @ "double sxm;\n";
                                             variableDeclarations = variableDeclarations @ "double sxl;\n";
                                             variableDeclarations = variableDeclarations @ "double temp;\n";
                                             variableDeclarations = variableDeclarations @ "double rxmh, rxml;\n";
                                             variableDeclarations = variableDeclarations @ "double rxlh, rxll;\n";
                                                                                     reductionCode = reductionCode @ "sxm = scale * xm;\n";
                                                                                     reductionCode = reductionCode @ "sxl = scale * xl;\n";
                                                                                     reductionCode = reductionCode @ "Mul12(&rxmh,&rxml,r,sxm);\n";
                                                                                     reductionCode = reductionCode @ "Mul12(&rxlh,&rxll,r,sxm);\n";
                                             reductionCode = reductionCode @ "temp = mrh - 1.0;\n";
                                             variableDeclarations = variableDeclarations @ "double temp1h, temp1l;\n";
                                             variableDeclarations = variableDeclarations @ "double temp2h, temp2l;\n";
                                             variableDeclarations = variableDeclarations @ "double temp3h, temp3l;\n";
                                             variableDeclarations = variableDeclarations @ "double temp4h, temp4l;\n";
                                             variableDeclarations = variableDeclarations @ "double templo;\n";
                                             reductionCode = reductionCode @ "Add12(temp1h,temp1l,temp,mrl);\n";
                                             reductionCode = reductionCode @ "Add12Cond(temp2h,temp2l,temp1l,rxmh);\n";
                                             reductionCode = reductionCode @ "Add12(temp3h,temp3l,temp1h,temp2h);\n";
                                             reductionCode = reductionCode @ "Add12Cond(temp4h,temp4l,rxml,rxlh);\n";
                                             reductionCode = reductionCode @ "templo = temp3l + (temp2l + (temp4h + (temp4l + rxll)));\n";
                                             reductionCode = reductionCode @ "Add12(zh,zm,temp3h,templo);\n";
                                             };
                                     }
                                    TD : {
                                                  variableDeclarations = variableDeclarations @ "double zh;\n";
                                                  variableDeclarations = variableDeclarations @ "double zm;\n";
                                      variableDeclarations = variableDeclarations @ "double zl;\n";
                                      variableDeclarations = variableDeclarations @ "double mrh, mrl;\n";
                                      reductionCode = reductionCode @ "Mul12(&mrh,&mrl,m,r);\n";
                                      match (problemdef.variableFormat) with
                                            D  : {
                                             variableDeclarations = variableDeclarations @ "double temp;\n";
                                                 reductionCode = reductionCode @ "temp = mrh - 1.0;\n";
                                             reductionCode = reductionCode @ "Add12(zh,zm,temp,mrl);\n";
                                             reductionCode = reductionCode @ "zl = 0.0;\n";
                                             }
                                            DD : {
                                             variableDeclarations = variableDeclarations @ "double sxm;\n";
                                             variableDeclarations = variableDeclarations @ "double temp;\n";
                                             variableDeclarations = variableDeclarations @ "double rxmh, rxml;\n";
                                             variableDeclarations = variableDeclarations @ "double temp2h, temp2m, temp2l;\n";
                                             variableDeclarations = variableDeclarations @ "double temp3;\n";
                                                                                     reductionCode = reductionCode @ "sxm = scale * xm;\n";
                                                                                     reductionCode = reductionCode @ "Mul12(&rxmh,&rxml,r,sxm);\n";
                                             reductionCode = reductionCode @ "temp = mrh - 1.0;\n";
                                             reductionCode = reductionCode @ "Renormalize3(&temp2h,&temp2m,&temp2l,temp,mrl,rxmh);\n";
                                             reductionCode = reductionCode @ "temp3 = temp2l + rxml;\n";
                                             reductionCode = reductionCode @ "Renormalize3(&zh,&zm,&zl,temp2h,temp2m,temp3);\n";
                                             }
                                            TD : {
                                             variableDeclarations = variableDeclarations @ "double sxm;\n";
                                             variableDeclarations = variableDeclarations @ "double sxl;\n";
                                             variableDeclarations = variableDeclarations @ "double temp;\n";
                                             variableDeclarations = variableDeclarations @ "double rxmh, rxml;\n";
                                             variableDeclarations = variableDeclarations @ "double rxlh, rxll;\n";
                                             variableDeclarations = variableDeclarations @ "double temp1h, temp1l;\n";
                                             variableDeclarations = variableDeclarations @ "double temp2h, temp2m, temp2l;\n";
                                                                                     reductionCode = reductionCode @ "sxm = scale * xm;\n";
                                                                                     reductionCode = reductionCode @ "sxl = scale * xl;\n";
                                                                                     reductionCode = reductionCode @ "Mul12(&rxmh,&rxml,r,sxm);\n";
                                                                                     reductionCode = reductionCode @ "Mul12(&rxlh,&rxll,r,sxm);\n";
                                             reductionCode = reductionCode @ "temp = mrh - 1.0;\n";
                                             reductionCode = reductionCode @ "Add12Cond(temp1h,temp1l,rxml,rxlh);\n";
                                             reductionCode = reductionCode @ "Renormalize3(&temp2h,&temp2m,&temp2l,temp,mrl,rxmh);\n";
                                             reductionCode = reductionCode @ "temp3 = temp2l + (temp1h + (temp1l + rxll));\n";
                                             reductionCode = reductionCode @ "Renormalize3(&zh,&zm,&zl,temp2h,temp2m,temp3);\n";
                                             };
                                     };
                            };

                            /* Now produce the code for the reduced function log(1 + z)/log(base) */
                            myProblemdef.func = g;
                            myProblemdef.dom = reducedDom;
                            myProblemdef.target = 1/8 * (problemdef.target);
                            myProblemdef.variableFormat = reducedArgumentFormat;
                            suffix = "_log_arg_red";
                            oldPrec = prec;
                            prec = max(300, prec);
                                origDefDom = problemdef.dom - 1;
                            prec = oldPrec;
                                match (problemdef) with { .definitionDomain = default } : {
                                                             if (origDefDom in problemdef.definitionDomain) then {
                                                                                    origDefDom = problemdef.definitionDomain;
                                                                                 }; }
                                                                            default : {};
                                myProblemdef.definitionDomain = origDefDom;
                                myParametrization = parametrization;
                                myParametrization.gappaFile = parametrization.gappaFile @ suffix;
                                myParametrization.gappaOutputFile = parametrization.gappaOutputFile @ suffix;
                                myParametrization.functionBasename = parametrization.functionBasename @ suffix;
                            myParametrization.doNotPerformLogarithmArgRed = true;
                            myParametrization.minWidth = (sup(reducedDom) - inf(reducedDom)) * (parametrization.minWidth / (sup(problemdef.dom) - inf(problemdef.dom)));
                                myParametrization.argumentReduced = true;

                                res = tryImplementation(myProblemdef, myParametrization);

                            if (res.okay) then {
                                /* The implementation of the reduced function has succeeded.
                               Now produce the code for the reconstruction
                            */
                                outputFormat = res.outputformat;
                            oldDisplay = display;
                            display = decimal!;
                            rcprLog2 = 1/log2(base);
                            rcprLog2Hi = D(rcprLog2);
                            rcprLog2Mi = D(rcprLog2 - rcprLog2Hi);
                            rcprLog2Lo = D(rcprLog2 - (rcprLog2Hi + rcprLog2Mi));
                            match outputFormat with
                                  D  : {
                                    poundDefines = poundDefines @ "#define " @ (parametrization.functionBasename) @ "_rcpr_log_two_of_base_hi " @ rcprLog2Hi @ "\n";
                                    poundDefines = poundDefines @ "\n" @ logTableHi @ "\n";
                                    variableDeclarations = variableDeclarations @ "double polyHi;\n";
                                    variableDeclarations = variableDeclarations @ "double tableHi;\n";
                                    variableDeclarations = variableDeclarations @ "double scaledExpoHi;\n";
                                    variableDeclarations = variableDeclarations @ "double logMHi;\n";
                                    reconstructionCode = reconstructionCode @ "tableHi = " @ (parametrization.functionBasename) @ "_log_rcpr_tbl_hi[index];\n";
                                    reconstructionCode = reconstructionCode @ "scaledExpoHi = ed * " @ (parametrization.functionBasename) @ "_rcpr_log_two_of_base_hi;\n";
                                    reconstructionCode = reconstructionCode @ "logMHi = tableHi + polyHi;\n";
                                    reconstructionCode = reconstructionCode @ "*res_resh = scaledExpoHi + logMHi;\n";
                                       }
                                  DD : {
                                    poundDefines = poundDefines @ "#define " @ (parametrization.functionBasename) @ "_rcpr_log_two_of_base_hi " @ rcprLog2Hi @ "\n";
                                    poundDefines = poundDefines @ "#define " @ (parametrization.functionBasename) @ "_rcpr_log_two_of_base_mi " @ rcprLog2Mi @ "\n";
                                    poundDefines = poundDefines @ "\n" @ logTableHi @ "\n";
                                    poundDefines = poundDefines @ "\n" @ logTableMi @ "\n";
                                    variableDeclarations = variableDeclarations @ "double polyHi;\n";
                                    variableDeclarations = variableDeclarations @ "double polyMi;\n";
                                    variableDeclarations = variableDeclarations @ "double tableHi;\n";
                                    variableDeclarations = variableDeclarations @ "double tableMi;\n";
                                    variableDeclarations = variableDeclarations @ "double scaledExpoHi;\n";
                                    variableDeclarations = variableDeclarations @ "double scaledExpoMi;\n";
                                    variableDeclarations = variableDeclarations @ "double logMHi;\n";
                                    variableDeclarations = variableDeclarations @ "double logMMi;\n";
                                    reconstructionCode = reconstructionCode @ "tableHi = " @ (parametrization.functionBasename) @ "_log_rcpr_tbl_hi[index];\n";
                                    reconstructionCode = reconstructionCode @ "tableMi = " @ (parametrization.functionBasename) @ "_log_rcpr_tbl_mi[index];\n";
                                    reconstructionCode = reconstructionCode @ "Mul122(&scaledExpoHi,&scaledExpoMi,ed," @ (parametrization.functionBasename) @ "_rcpr_log_two_of_base_hi," @ (parametrization.functionBasename) @ "_rcpr_log_two_of_base_mi);\n";
                                    reconstructionCode = reconstructionCode @ "Add22(&logMHi,&logMMi,tableHi,tableMi,polyHi,polyMi);\n";
                                    reconstructionCode = reconstructionCode @ "Add22(res_resh,res_resm,scaledExpoHi,scaledExpoMi,logMHi,logMMi);\n";
                                       }
                                  TD : {
                                    poundDefines = poundDefines @ "#define " @ (parametrization.functionBasename) @ "_rcpr_log_two_of_base_hi " @ rcprLog2Hi @ "\n";
                                    poundDefines = poundDefines @ "#define " @ (parametrization.functionBasename) @ "_rcpr_log_two_of_base_mi " @ rcprLog2Mi @ "\n";
                                    poundDefines = poundDefines @ "#define " @ (parametrization.functionBasename) @ "_rcpr_log_two_of_base_lo " @ rcprLog2Lo @ "\n";
                                    poundDefines = poundDefines @ "\n" @ logTableHi @ "\n";
                                    poundDefines = poundDefines @ "\n" @ logTableMi @ "\n";
                                    poundDefines = poundDefines @ "\n" @ logTableLo @ "\n";
                                    variableDeclarations = variableDeclarations @ "double polyHi;\n";
                                    variableDeclarations = variableDeclarations @ "double polyMi;\n";
                                    variableDeclarations = variableDeclarations @ "double polyLo;\n";
                                    variableDeclarations = variableDeclarations @ "double tableHi;\n";
                                    variableDeclarations = variableDeclarations @ "double tableMi;\n";
                                    variableDeclarations = variableDeclarations @ "double tableLo;\n";
                                    variableDeclarations = variableDeclarations @ "double scaledExpoHi;\n";
                                    variableDeclarations = variableDeclarations @ "double scaledExpoMi;\n";
                                    variableDeclarations = variableDeclarations @ "double scaledExpoLo;\n";
                                    variableDeclarations = variableDeclarations @ "double logMHi;\n";
                                    variableDeclarations = variableDeclarations @ "double logMMi;\n";
                                    variableDeclarations = variableDeclarations @ "double logMLo;\n";
                                    reconstructionCode = reconstructionCode @ "tableHi = " @ (parametrization.functionBasename) @ "_log_rcpr_tbl_hi[index];\n";
                                    reconstructionCode = reconstructionCode @ "tableMi = " @ (parametrization.functionBasename) @ "_log_rcpr_tbl_mi[index];\n";
                                    reconstructionCode = reconstructionCode @ "tableLo = " @ (parametrization.functionBasename) @ "_log_rcpr_tbl_lo[index];\n";
                                    reconstructionCode = reconstructionCode @ "Mul133(&scaledExpoHi,&scaledExpoMi,&scaledExpoLo,ed," @ (parametrization.functionBasename) @ "_rcpr_log_two_of_base_hi," @ (parametrization.functionBasename) @ "_rcpr_log_two_of_base_mi," @ (parametrization.functionBasename) @ "_rcpr_log_two_of_base_lo);\n";
                                    reconstructionCode = reconstructionCode @ "Add33(&logMHi,&logMMi,&logMLo,tableHi,tableMi,tableLo,polyHi,polyMi,polyLo);\n";
                                    reconstructionCode = reconstructionCode @ "Add33(res_resh,res_resm,res_resl,scaledExpoHi,scaledExpoMi,scaledExpoLo,logMHi,logMMi,logMLo);\n";
                                       };
                            display = oldDisplay!;

                            /* Now emit the code */
                            implementationCode = "\n";
                            implementationCode = implementationCode @ poundDefines @ "\n" @ reciprocalTable @ "\n";
                                implementationCode = implementationCode @ "void " @ parametrization.functionBasename @ "(";
                                implementationCode = implementationCode @ (match (outputFormat) with
                                                                 D  : ( "double *res_resh, " )
                                                     DD : ( "double *res_resh, double *res_resm, " )
                                                     TD : ( "double *res_resh, double *res_resm, double *res_resl, " ));
                                implementationCode = implementationCode @ (match (problemdef.variableFormat) with
                                                                 D  : ( "double xh" )
                                                     DD : ( "double xh, double xm" )
                                                     TD : ( "double xh, double xm, double xl" ));
                                implementationCode = implementationCode @ ") {\n";
                                implementationCode = implementationCode @ variableDeclarations @ "\n" @ reductionCode @ "\n";
                            implementationCode = implementationCode @ (res.functionname) @ "(";
                            implementationCode = implementationCode @ (match (outputFormat) with
                                                         D  : ( "&polyHi, " )
                                                     DD : ( "&polyHi, &polyMi, " )
                                                     TD : ( "&polyHi, &polyMi, &polyLo, "));
                            implementationCode = implementationCode @ (match reducedArgumentFormat with
                                                         D  : ( "zh" )
                                                     DD : ( "zh, zm" )
                                                     TD : ( "zh, zm, zl"));
                            implementationCode = implementationCode @ ");\n";
                            implementationCode = implementationCode @ "\n" @ reconstructionCode @ "\n";
                            implementationCode = implementationCode @ "\n}\n";

                                write(implementationCode) >> parametrization.implementationFile;
                                result.approxerr = res.approxerr;
                                result.implerr = (1 + abs(res.implerr)) * (1 + abs(1/2 * problemdef.target)) - 1;    // TODO
                                    result.outputformat = outputFormat;
                                    result.functionname = parametrization.functionBasename;
                                result.okay = true;
                                } else {
                              write("Could not implement the subfunction ", g, " over ", reducedDom);
                            };
                         };
                          };
                           };
                         };
                     }
                default : { };

      return result;
};

procedure tryDetectPoweringArgRed(func, dom, target) {
      var result, a, b, c, sign;
      var testfunc, y, zerosUpper, zerosLower;

      result = { .okay = false };

      /* We have to detect if func behaves in dom
         like

         x^c for some constant c

         We say that func behaves like x^c
         if

         x^c = func * (1 + eps) with abs(eps) <= target.

         We start by computing a possible constant c
         as

         c = log(abs(f(b)/f(a)))/log(abs(b/a))

         where a, b are chosen as follows:

         * if sup(dom) == 0, a = 2/3 * inf(dom), b = 1/3 * inf(dom)
         * otherwise:
              - if inf(dom) == 0, a = 1/3 * sup(dom), b = 2/3 * sup(dom)
          - otherwise:
                   + if inf(dom) != -sup(dom), a = inf(dom), b = sup(dom)
                   + otherwise: a = inf(dom)/2, b = sup(dom)

      */
      if (sup(dom) == 0) then {
         a = 2/3 * inf(dom);
         b = 1/3 * inf(dom);
      } else {
         if (inf(dom) == 0) then {
            a = 1/3 * sup(dom);
        b = 2/3 * sup(dom);
         } else {
            if (inf(dom) != -sup(dom)) then {
          a = inf(dom);
          b = sup(dom);
        } else {
          a = inf(dom)/2;
          b = sup(dom);
        };
         };
      };

      if ((a != 0) && (~func(a) != 0)) then {
          oldPrec = prec;
          prec = max(2 * prec, ceil(-log2(abs(target))) * 4)!;
          c = log(abs(func(b)/func(a)))/log(abs(b/a));
          if (abs(c) - 1b-1000 < 0) then {
             c = 0;
          } else {
             c := c;
          };
          c = round(c,floor(prec/2),RN);
          prec = oldPrec!;

          if ((c == c) && (abs(c) != infty) && (c > 0) && (c != 2) && (c != 1)) then {
             /* Now we have to check if sign * x^c effectively approximates func with
                an accuracy of target

            We still have to determine sign: we just take the sign of func(a) * a.

             */

         if ((~func(a)) * a < 0) then sign = -1 else sign = 1;
             testfunc = simplifysafe((sign * x^c)/func - 1);

         if (!((inf(dom) < 0) && (floor(c) != c))) then {
         y = evaluate(testfunc, round(mid(dom) * (1 + 2^(-prec) * [-1.25;1]) + 1b-10 * (sup(dom) - mid(dom)),53,RN));
         if (y in [-4 * target, 4 * target]) then {
            y = evaluate(testfunc, [mid(dom)]);
            if (y in [-2 * target, 2 * target]) then {
                   y = evaluate(testfunc, mid(dom));
            };
         };
         } else {
           y = 4 * target;
         };
             if (y in [-target, target]) then {

            if (0 in dom) then {
               if (func(0) == 0) then {
                   if (inf(dom) == 0) then {
                       zerosUpper = mydirtyfindzeros(testfunc + target, [1b-1075; sup(dom)]);
                       zerosLower = mydirtyfindzeros(testfunc - target, [1b-1075; sup(dom)]);
                   } else {
                     if (sup(dom) == 0) then {
                         zerosUpper = mydirtyfindzeros(testfunc + target, [inf(dom); -1b-1075]);
                         zerosLower = mydirtyfindzeros(testfunc - target, [inf(dom); -1b-1075]);
                 } else {
                         zerosUpper = mydirtyfindzeros(testfunc + target, [inf(dom); -1b-1075]) @ mydirtyfindzeros(testfunc + target, [1b-1075; sup(dom)]);
                         zerosLower = mydirtyfindzeros(testfunc - target, [inf(dom); -1b-1075]) @ mydirtyfindzeros(testfunc - target, [1b-1075; sup(dom)]);
                 };
                   };
               } else {
                    zerosUpper = mydirtyfindzeros(testfunc + target, dom);
                    zerosLower = mydirtyfindzeros(testfunc - target, dom);
               };
            } else {
                zerosUpper = mydirtyfindzeros(testfunc + target, dom);
                zerosLower = mydirtyfindzeros(testfunc - target, dom);
            };

            if ((zerosUpper == [||]) && (zerosLower == [||])) then {
                              result.okay = true;
                      result.power = c;
                      result.sign = sign;
                      result.replacefunc = simplifysafe(horner(sign * x^c));
                };
                 };
          };
      };

      return result;
};

procedure tryImplementationThroughArgumentReductionPowering(problemdef, parametrization) {
      var result, needArgumentReduction, res, c, recurseProblemdef, sign;
      var doNotPerformPoweringArgRed;
          var deltaMax, epsMaxExponent, epsMaxScaledLogarithm, epsMaxAddition;
      var Emin, Emax, Ebitwidth, cBitwidth, canDoETimesCOnDouble, cFormat;
      var logProblemdef, logParametrization, logSuffix, resLog, logFormat, cStoreFormat;
      var expProblemdef, expParametrization, expSuffix, resExp;
      var expVariableformat, expDomain, expFormat, cStorageFormat;
      var cHi, cMi, cLo, oldDisplay, eTimesCFormat, eTimesCMinusFFormat;
      var eTimesCAdditionFormat, cTimesLogFormat, expFinalFormat;
      var preNegate, postNegate, recurseResult, recurseSuffix, recurseParametrization;
      var handleZero;

      result = { .okay = false };

      match ( { .problemdef = problemdef,
                    .parametrization = parametrization } ) with
                { .problemdef =      { .func = default,
                                       .dom = default,
                                       .target = default,
                                       .variableFormat = default },
                  .parametrization = { .maxDegree = default,
                                       .minWidth = default,
                                       .beta = default,
                           .implementationFile = default,
                                       .gappaFile = default,
                                       .gappaOutputFile = default,
                                       .gappaExecutable = default,
                       .functionBasename = default,
                       .tableIndexWidth = default } } : {

                       /* Test if we may perform this type of argument
                          reduction
                       */
                       doNotPerformPoweringArgRed = false;
                       match (parametrization) with
                             { .doNotPerformPoweringArgRed = true } : { doNotPerformPoweringArgRed = true; }
                         default : { };

                       if (!doNotPerformPoweringArgRed) then {
                           /* Start with a test if the domain actually needs
                                              argument reduction in order to stay below the maximum
                          polynomial degree
                           */
                           needArgumentReduction = true;
                           res = checkIfSufficientDegree(problemdef.func, problemdef.dom, parametrization.maxDegree, problemdef.target);

                                           if (res.okay) then {
                                           if (res.sufficientDegree) then needArgumentReduction = false;
                           } else {
                               needArgumentReduction = false;
                           };

                           if (needArgumentReduction) then {
                              /* Here, we need to detect if we can use
                             the powering argument reduction
                             for the given function
                          */

                          res = tryDetectPoweringArgRed(problemdef.func, problemdef.dom, problemdef.target * 1/8);

                          if (res.okay) then {
                         c = res.power;
                         sign = res.sign;

                         /* Now check if the replacement function x^c isn't just a polynomial x^k (k == c)
                            that can be implemented with the maximum degree that is currently allowed.

                            Continue with the replacement function only if that condition is not fullfilled.

                         */
                         if (!((nearestint(c) == c) && (1 < c) && (c <= parametrization.maxDegree))) then {
                            /* Now check if the implementation domain contains negative numbers.

                               If this is the case, there are several possibilities:

                               * If c is not an integer, it is a dyadic number and the function
                                 is not really defined *and continuous* on negative numbers.
                             In this case, we just fail.

                               * otherwise, do the following:
                                 - if there are positive numbers in the domain,
                               simply fail. Functions x^k are symmetical and symmetry
                                                           detection will eventually detect that and call us again
                               on a domain that does not change sign.
                                                         - otherwise we call ourselves on func(-x) and -dom.

                               Otherwise, we can continue and use the replacement function.

                            */

                            if (inf(problemdef.dom) < 0) then {
                               if (c == nearestint(c)) then {
                                  if (sup(problemdef.dom) <= 0) then {
                                 /* All numbers in the implementation domain are non-positive
                                    and the function is x^k.
                                 */
                                 recurseProblemdef = problemdef;
                                 recurseProblemdef.func = problemdef.func(-x);
                                 recurseProblemdef.dom = -problemdef.dom;
                                 match (problemdef) with { .definitionDomain = default } : {
                                                                   recurseProblemdef.definitionDomain = -problemdef.definitionDomain;
                                                                                  }
                                                                       default : {};
                                     recurseSuffix = "_negate";
                                 recurseParametrization = parametrization;
                                 recurseParametrization.implementationFile = parametrization.implementationFile;
                                         recurseParametrization.gappaFile = parametrization.gappaFile @ recurseSuffix;
                                         recurseParametrization.gappaOutputFile = parametrization.gappaOutputFile @ recurseSuffix;
                                         recurseParametrization.functionBasename = parametrization.functionBasename @ recurseSuffix;
                                     recurseResult = tryImplementationThroughArgumentReductionPowering(recurseProblemdef, recurseParametrization);
                                 if (recurseResult.okay) then {
                                    write("void ", parametrization.functionBasename, "(") >> parametrization.implementationFile;
                                match (recurseResult.outputformat) with
                                      D  : {
                                                   write("double *res_resh, ") >> parametrization.implementationFile;
                                           }
                                      DD : {
                                                   write("double *res_resh, double *res_resm, ") >> parametrization.implementationFile;
                                           }
                                      TD : {
                                                   write("double *res_resh, double *res_resm, double *res_resl, ") >> parametrization.implementationFile;
                                           };
                                    match (problemdef.variableFormat) with
                                      D  : {
                                                   write("double xh") >> parametrization.implementationFile;
                                           }
                                      DD : {
                                                   write("double xh, double xm") >> parametrization.implementationFile;
                                           }
                                      TD : {
                                                   write("double xh, double xm, double xl") >> parametrization.implementationFile;
                                           };
                                    write(")\n{\n",recurseResult.functionname,"(") >> parametrization.implementationFile;
                                match (recurseResult.outputformat) with
                                      D  : {
                                                   write("res_resh, ") >> parametrization.implementationFile;
                                           }
                                      DD : {
                                                   write("res_resh, res_resm, ") >> parametrization.implementationFile;
                                           }
                                      TD : {
                                                   write("res_resh, res_resm, res_resl, ") >> parametrization.implementationFile;
                                           };
                                    match (problemdef.variableFormat) with
                                      D  : {
                                                   write("-xh") >> parametrization.implementationFile;
                                           }
                                      DD : {
                                                   write("-xh, -xm") >> parametrization.implementationFile;
                                           }
                                      TD : {
                                                   write("-xh, -xm, -xl") >> parametrization.implementationFile;
                                           };
                                    write(");\n}\n") >> parametrization.implementationFile;
                                result = recurseResult;
                                result.functionname = parametrization.functionBasename;
                                 };
                              };
                               };
                            } else {
                                   write("Detected that the given function ", problemdef.func, " can be replaced with ", res.replacefunc, " on ", problemdef.dom, "\n");

                               /* Determine if we have to negate the argument
                                  and/or if we have to negate the result
                               */
                               if (mid(problemdef.dom) < 0) then {
                                  preNegate = true;
                               } else {
                                  preNegate = false;
                               };
                               if ((res.replacefunc)(mid(problemdef.dom)) < 0) then {
                                  postNegate = true;
                               } else {
                                  postNegate = false;
                               };

                               /* Test if we need to be able to handle zero as an
                                  argument
                                */
                               handleZero = (0 in problemdef.dom);

                               /* We implement x^c as follows

                                  x^c = (2^E * m)^c = 2^F * 2^((E * c - F) + c * log2(m))

                              where F = nearestint(E * c)

                              We do NOT care about the possible catastrophic cancellation
                              between (E * c - F) and c * log2(m) as it does not amplify the
                              error after the power of 2:

                              2^(x + delta) = 2^x * 2^delta = 2^x * (1 + (2^delta - 1))

                              So for delta bounded by abs(delta) <= deltaMax where

                              deltaMax = max(-log2(1 - epsMax),log2(1 + epsMax))

                              with epsMax the target error, we get

                              2^(x + delta) = 2^x * (1 + eps) with eps bounded by

                              abs(eps) <= epsMax.

                              Knowing deltaMax we can determine

                              epsMax1 = 1/abs(max(abs(Emax),abs(Emin)) * c) * 1/4 * deltaMax

                              epsMax2 = 1/abs(c) * 1/4 * deltaMax

                              and

                              epsMax3 = 1/abs(max(c,1/2)) * 1/4 * deltaMax


                              for which we get

                              2^(((E * c - F) * (1 + eps1) + c * log2(m) * (1 + eps2)) * (1 + eps3)) =

                              = 2^(E * c - F + c * log2(m) + (E * c - F) * eps1 + c * log2(m) * eps2 + eps3 * (E * c - F + c * log2(m) + (E * c - F) * eps1 + c * log2(m) * eps2)) =
                              = 2^(E * c - F + c * log2(m)) * (1 + (2^((E * c - F) * eps1 + c * log2(m) * eps2 + eps3 * (E * c - F + c * log2(m) + (E * c - F) * eps1 + c * log2(m) * eps2)) - 1))
                              = 2^(E * c - F + c * log2(m)) * (1 + eps)

                              with

                              eps = 2^((E * c - F) * eps1 + c * log2(m) * eps2 + eps3 * (E * c - F + c * log2(m) + (E * c - F) * eps1 + c * log2(m) * eps2)) - 1

                              bounded by abs(eps) <= epsMax

                              For the ease of understanding, we call

                              epsMax1 => epsMaxExponent
                              epsMax2 => epsMaxScaledLogarithm
                              epsMax3 => epsMaxAddition

                               */
                               if (inf(abs(problemdef.dom)) == 0) then {
                                  /* Least exponent for a double, including integer powers of 2 in the subnormal range */
                              Emin = -1074;
                               } else {
                                  Emin = floor(log2(inf(abs(problemdef.dom))));
                               };
                               Emax = floor(log2(sup(abs(problemdef.dom))));
                               Ebitwidth = ceil(log2(max(abs(Emin),abs(Emax))));
                               cBitwidth = precision(abs(c));
                               deltaMax = max(-log2(1 - abs(problemdef.target * 1/8)),log2(1 + abs(problemdef.target * 1/8)));
                                       epsMaxScaledLogarithm = 1/abs(c) * 1/4 * deltaMax;
                               epsMaxAddition = 1/abs(max(c,1/2)) * 1/4 * deltaMax;
                               canDoETimesCOnDouble = false;
                               if (Ebitwidth + cBitwidth <= 53) then {
                                  cFormat = D;
                              canDoETimesCOnDouble = true;
                              epsMaxExponent = 0;
                               } else {
                                  epsMaxExponent = 13/32 * 1/abs(sup(abs([Emin,Emax])) * c) * 1/4 * deltaMax;
                              canDoETimesCOnDouble = false;
                              if (epsMaxExponent <= 1b-101) then {
                                 cFormat = TD;
                              } else {
                                 if (epsMaxExponent <= 1b-51) then {
                                   cFormat = DD;
                                 } else {
                                   cFormat = D;
                                 };
                              };
                               };
                               cHi = D(c);
                               cMi = D(c - cHi);
                               cLo = D(c - (cHi + cMi));
                               if (epsMaxAddition <= 1b-102) then {
                                  eTimesCAdditionFormat = TD;
                               } else {
                                  if (epsMaxAddition <= 1b-53) then {
                                 eTimesCAdditionFormat = DD;
                              } else {
                                 eTimesCAdditionFormat = D;
                              };
                               };


                               /* Now generate the code for the logarithm log2(m) */
                               logSuffix = "_pow_log";
                               logProblemdef.func = log2(x);
                                   logProblemdef.dom = [1;2];
                                   logProblemdef.target = 1/4 * epsMaxScaledLogarithm;
                                   logProblemdef.definitionDomain = [1;2];
                               logProblemdef.variableFormat = problemdef.variableFormat;
                                   logParametrization = parametrization;
                               logParametrization.implementationFile = parametrization.implementationFile @ logSuffix;
                                   logParametrization.gappaFile = parametrization.gappaFile @ logSuffix;
                                   logParametrization.gappaOutputFile = parametrization.gappaOutputFile @ logSuffix;
                                   logParametrization.functionBasename = parametrization.functionBasename @ logSuffix;
                                   logParametrization.minWidth = (sup([1;2]) - inf([1;2])) * (parametrization.minWidth / (sup(problemdef.dom) - inf(problemdef.dom)));
                               logParametrization.doNotPerformPoweringArgRed = true;
                                   logParametrization.argumentReduced = true;

                               resLog = tryImplementation(logProblemdef, logParametrization);

                               if (resLog.okay) then {
                                 write("Implementation of the logarithm subfunction has been successful\n");
                             logFormat = resLog.outputformat;

                                 cStorageFormat = cFormat;
                             match (logFormat) with
                                   D  : { }
                                   DD : {
                                    if (cStorageFormat == D) then {
                                       cStorageFormat = DD;
                                    };
                                    }
                                   TD : {
                                    cStorageFormat = TD;
                                        };
                                 match cStorageFormat with
                                     TD : {
                                    if (D(c) == c) then {
                                       cStorageFormat = D;
                                    } else {
                                      if (DD(c) == c) then {
                                         cStorageFormat = DD;
                                      };
                                    };
                                      }
                                     DD : {
                                    if (D(c) == c) then {
                                       cStorageFormat = D;
                                    };
                                      }
                                     D  : { };

                             /* Now generate the code for the exponential 2^x */
                             expVariableformat = cFormat;
                             if (logFormat == TD) then {
                                expVariableformat = TD;
                             } else {
                                if ((logFormat == DD) && (expVariableformat != TD)) then {
                                   expVariableformat = DD;
                                };
                             };
                             if (eTimesCAdditionFormat == TD) then {
                                expVariableformat = TD;
                             } else {
                                if ((eTimesCAdditionFormat == DD) && (expVariableformat != TD)) then {
                                   expVariableformat = DD;
                                };
                             };

                             if (c > 0) then {
                                expDomain = [-1/2;c+1/2];
                             } else {
                                expDomain = [c-1/2;1/2];
                             };
                                         expSuffix = "_pow_exp";
                                 expProblemdef.func = 2^x;
                                     expProblemdef.dom = expDomain;
                                     expProblemdef.target = problemdef.target * 1/8;
                                     expProblemdef.definitionDomain = [-500;500];
                                 expProblemdef.variableFormat = expVariableformat;
                                     expParametrization = parametrization;
                                 expParametrization.implementationFile = parametrization.implementationFile;
                                     expParametrization.gappaFile = parametrization.gappaFile @ expSuffix;
                                     expParametrization.gappaOutputFile = parametrization.gappaOutputFile @ expSuffix;
                                     expParametrization.functionBasename = parametrization.functionBasename @ expSuffix;
                                     expParametrization.minWidth = (sup(expDomain) - inf(expDomain)) * (parametrization.minWidth / (sup(problemdef.dom) - inf(problemdef.dom)));
                                 expParametrization.doNotPerformPoweringArgRed = true;
                                         expParametrization.argumentReduced = true;

                             resExp = tryImplementation(expProblemdef, expParametrization);

                                 if (resExp.okay) then {
                                    write("Implementation of the exponential subfunction has been successful\n");
                                expFormat = resExp.outputformat;

                                /* Combine both codes into one implementation file */
                                bashexecute("cat " @ parametrization.implementationFile @ logSuffix @ " >> " @ parametrization.implementationFile);
                                bashexecute("rm " @ parametrization.implementationFile @ logSuffix);

                                /* Now generate the code performing range reduction
                                   and calling the two functions logarithm and
                                   exponential.
                                */
                                oldDisplay = display;
                                display = decimal!;
                                poundDefines = "\n";
                                variableDecls = "\n";
                                reductionCode = "\n";

                                match (cStorageFormat) with
                                      D  : {
                                        poundDefines = poundDefines @ "#define " @ (parametrization.functionBasename) @ "_exponent_hi " @ cHi @ "\n";
                                       }
                                      DD : {
                                        poundDefines = poundDefines @ "#define " @ (parametrization.functionBasename) @ "_exponent_hi " @ cHi @ "\n";
                                        poundDefines = poundDefines @ "#define " @ (parametrization.functionBasename) @ "_exponent_mi " @ cMi @ "\n";
                                       }
                                      TD : {
                                        poundDefines = poundDefines @ "#define " @ (parametrization.functionBasename) @ "_exponent_hi " @ cHi @ "\n";
                                        poundDefines = poundDefines @ "#define " @ (parametrization.functionBasename) @ "_exponent_mi " @ cMi @ "\n";
                                        poundDefines = poundDefines @ "#define " @ (parametrization.functionBasename) @ "_exponent_lo " @ cLo @ "\n";
                                       };

                                poundDefines = poundDefines @ "#define " @ (parametrization.functionBasename) @ "_shifter 6755399441055744.0\n";

                                    variableDecls = variableDecls @ "db_number argRedCaster;\n";
                                variableDecls = variableDecls @ "int E;\n";
                                variableDecls = variableDecls @ "double ed;\n";
                                variableDecls = variableDecls @ "double mh;\n";
                                if (preNegate) then {
                                   reductionCode = reductionCode @ "argRedCaster.d = -xh;\n";
                                } else {
                                   reductionCode = reductionCode @ "argRedCaster.d = xh;\n";
                                };

                                // TODO: Care about subnormal inputs

                                reductionCode = reductionCode @ "E = (int) ((argRedCaster.l >> 52) - 1023ll);\n";
                                reductionCode = reductionCode @ "ed = (double) E;\n";
                                    reductionCode = reductionCode @ "argRedCaster.l = (argRedCaster.l & 0x800fffffffffffffull) | 0x3ff0000000000000ull;\n";
                                reductionCode = reductionCode @ "mh = argRedCaster.d;\n";
                                match (problemdef.variableFormat) with
                                      D  : { }
                                  DD : {
                                                   variableDecls = variableDecls @ "db_number scaleCaster;\n";
                                                   variableDecls = variableDecls @ "double scale;\n";
                                       variableDecls = variableDecls @ "double mm;\n";
                                                   reductionCode = reductionCode @ "scaleCaster.l = 1023 - E;\n";
                                                   reductionCode = reductionCode @ "scaleCaster.l <<= 52;\n";
                                                   reductionCode = reductionCode @ "scale = scaleCaster.d;\n";
                                       if (preNegate) then {
                                           reductionCode = reductionCode @ "mm = -xm * scale;\n";
                                       } else {
                                           reductionCode = reductionCode @ "mm = xm * scale;\n";
                                       };
                                       }
                                  TD : {
                                                   variableDecls = variableDecls @ "db_number scaleCaster;\n";
                                                   variableDecls = variableDecls @ "double scale;\n";
                                       variableDecls = variableDecls @ "double mm;\n";
                                       variableDecls = variableDecls @ "double ml;\n";
                                                   reductionCode = reductionCode @ "scaleCaster.l = 1023 - E;\n";
                                                   reductionCode = reductionCode @ "scaleCaster.l <<= 52;\n";
                                                   reductionCode = reductionCode @ "scale = scaleCaster.d;\n";
                                       if (preNegate) then {
                                           reductionCode = reductionCode @ "mm = -xm * scale;\n";
                                           reductionCode = reductionCode @ "ml = -xl * scale;\n";
                                       } else {
                                           reductionCode = reductionCode @ "mm = xm * scale;\n";
                                           reductionCode = reductionCode @ "ml = xl * scale;\n";
                                       };
                                       };
                                    variableDecls = variableDecls @ "int F;\n";
                                variableDecls = variableDecls @ "double fd;\n";
                                if (canDoETimesCOnDouble) then {
                                   variableDecls = variableDecls @ "double eTimesC;\n";
                                   variableDecls = variableDecls @ "double shiftedETimesC;\n";
                                   variableDecls = variableDecls @ "db_number fCaster;\n";
                                   variableDecls = variableDecls @ "double eTimesCMinusF_hi;\n";
                                   reductionCode = reductionCode @ "eTimesC = ed * " @ (parametrization.functionBasename) @ "_exponent_hi;\n";
                                   reductionCode = reductionCode @ "shiftedETimesC = eTimesC + " @ (parametrization.functionBasename) @ "_shifter;\n";
                                   reductionCode = reductionCode @ "fd = shiftedETimesC - " @ (parametrization.functionBasename) @ "_shifter;\n";
                                   reductionCode = reductionCode @ "fCaster.d = shiftedETimesC;\n";
                                   reductionCode = reductionCode @ "fCaster.l <<= 32;\n";
                                   reductionCode = reductionCode @ "fCaster.l >>= 32;\n";
                                   reductionCode = reductionCode @ "F = (int) fCaster.l;\n";
                                   reductionCode = reductionCode @ "eTimesCMinusF_hi = eTimesC - fd;\n";
                                   eTimesCMinusFFormat = D;
                                } else {
                                   match (cFormat) with
                                         D  : {
                                                      variableDecls = variableDecls @ "double eTimesC_hi;\n";
                                                      variableDecls = variableDecls @ "double shiftedETimesC;\n";
                                                      variableDecls = variableDecls @ "db_number fCaster;\n";
                                                      reductionCode = reductionCode @ "eTimesC_hi = ed * " @ (parametrization.functionBasename) @ "_exponent_hi;\n";
                                                      reductionCode = reductionCode @ "shiftedETimesC = eTimesC_hi + " @ (parametrization.functionBasename) @ "_shifter;\n";
                                                      reductionCode = reductionCode @ "fd = shiftedETimesC - " @ (parametrization.functionBasename) @ "_shifter;\n";
                                                      reductionCode = reductionCode @ "fCaster.d = shiftedETimesC;\n";
                                                      reductionCode = reductionCode @ "fCaster.l <<= 32;\n";
                                                      reductionCode = reductionCode @ "fCaster.l >>= 32;\n";
                                                      reductionCode = reductionCode @ "F = (int) fCaster.l;\n";
                                          eTimesCFormat = D;
                                          }
                                         DD : {
                                          if (cStorageFormat == D) then {
                                                          variableDecls = variableDecls @ "double eTimesC_hi;\n";
                                                          variableDecls = variableDecls @ "double eTimesC_mi;\n";
                                                          variableDecls = variableDecls @ "double shiftedETimesC;\n";
                                                          variableDecls = variableDecls @ "db_number fCaster;\n";
                                              reductionCode = reductionCode @ "Mul12(&eTimesC_hi,&eTimesC_mi,ed," @ (parametrization.functionBasename) @ "_exponent_hi);\n";
                                                          reductionCode = reductionCode @ "shiftedETimesC = eTimesC_hi + " @ (parametrization.functionBasename) @ "_shifter;\n";
                                                          reductionCode = reductionCode @ "fd = shiftedETimesC - " @ (parametrization.functionBasename) @ "_shifter;\n";
                                                          reductionCode = reductionCode @ "fCaster.d = shiftedETimesC;\n";
                                                          reductionCode = reductionCode @ "fCaster.l <<= 32;\n";
                                                          reductionCode = reductionCode @ "fCaster.l >>= 32;\n";
                                                          reductionCode = reductionCode @ "F = (int) fCaster.l;\n";
                                              eTimesCFormat = DD;
                                          } else {
                                                          variableDecls = variableDecls @ "double eTimesC_hi;\n";
                                                          variableDecls = variableDecls @ "double eTimesC_mi;\n";
                                                          variableDecls = variableDecls @ "double shiftedETimesC;\n";
                                                          variableDecls = variableDecls @ "db_number fCaster;\n";
                                              reductionCode = reductionCode @ "Mul122(&eTimesC_hi,&eTimesC_mi,ed," @ (parametrization.functionBasename) @ "_exponent_hi," @ (parametrization.functionBasename) @ "_exponent_mi);\n";
                                                          reductionCode = reductionCode @ "shiftedETimesC = eTimesC_hi + " @ (parametrization.functionBasename) @ "_shifter;\n";
                                                          reductionCode = reductionCode @ "fd = shiftedETimesC - " @ (parametrization.functionBasename) @ "_shifter;\n";
                                                          reductionCode = reductionCode @ "fCaster.d = shiftedETimesC;\n";
                                                          reductionCode = reductionCode @ "fCaster.l <<= 32;\n";
                                                          reductionCode = reductionCode @ "fCaster.l >>= 32;\n";
                                                          reductionCode = reductionCode @ "F = (int) fCaster.l;\n";
                                              eTimesCFormat = DD;
                                          };
                                          }
                                         TD : {
                                          match (cStorageFormat) with
                                            D  : {
                                                                    variableDecls = variableDecls @ "double eTimesC_hi;\n";
                                                                    variableDecls = variableDecls @ "double eTimesC_mi;\n";
                                                                    variableDecls = variableDecls @ "double shiftedETimesC;\n";
                                                                    variableDecls = variableDecls @ "db_number fCaster;\n";
                                                        reductionCode = reductionCode @ "Mul12(&eTimesC_hi,&eTimesC_mi,ed," @ (parametrization.functionBasename) @ "_exponent_hi);\n";
                                                                    reductionCode = reductionCode @ "shiftedETimesC = eTimesC_hi + " @ (parametrization.functionBasename) @ "_shifter;\n";
                                                                    reductionCode = reductionCode @ "fd = shiftedETimesC - " @ (parametrization.functionBasename) @ "_shifter;\n";
                                                                    reductionCode = reductionCode @ "fCaster.d = shiftedETimesC;\n";
                                                                    reductionCode = reductionCode @ "fCaster.l <<= 32;\n";
                                                                    reductionCode = reductionCode @ "fCaster.l >>= 32;\n";
                                                                    reductionCode = reductionCode @ "F = (int) fCaster.l;\n";
                                                        eTimesCFormat = DD;
                                                 }
                                            DD : {
                                                                    variableDecls = variableDecls @ "double eTimesC_hi;\n";
                                                                    variableDecls = variableDecls @ "double eTimesC_mi;\n";
                                                                    variableDecls = variableDecls @ "double eTimesC_lo;\n";
                                                                    variableDecls = variableDecls @ "double shiftedETimesC;\n";
                                                                    variableDecls = variableDecls @ "db_number fCaster;\n";
                                                        reductionCode = reductionCode @ "Mul123(&eTimesC_hi,&eTimesC_mi,&eTimesC_lo,ed," @ (parametrization.functionBasename) @ "_exponent_hi," @ (parametrization.functionBasename) @ "_exponent_mi);\n";
                                                                    reductionCode = reductionCode @ "shiftedETimesC = eTimesC_hi + " @ (parametrization.functionBasename) @ "_shifter;\n";
                                                                    reductionCode = reductionCode @ "fd = shiftedETimesC - " @ (parametrization.functionBasename) @ "_shifter;\n";
                                                                    reductionCode = reductionCode @ "fCaster.d = shiftedETimesC;\n";
                                                                    reductionCode = reductionCode @ "fCaster.l <<= 32;\n";
                                                                    reductionCode = reductionCode @ "fCaster.l >>= 32;\n";
                                                                    reductionCode = reductionCode @ "F = (int) fCaster.l;\n";
                                                        eTimesCFormat = TD;
                                                 }
                                            TD : {
                                                                    variableDecls = variableDecls @ "double eTimesC_hi;\n";
                                                                    variableDecls = variableDecls @ "double eTimesC_mi;\n";
                                                                    variableDecls = variableDecls @ "double eTimesC_lo;\n";
                                                                    variableDecls = variableDecls @ "double shiftedETimesC;\n";
                                                                    variableDecls = variableDecls @ "db_number fCaster;\n";
                                                        reductionCode = reductionCode @ "Mul133(&eTimesC_hi,&eTimesC_mi,&eTimesC_lo,ed," @ (parametrization.functionBasename) @ "_exponent_hi," @ (parametrization.functionBasename) @ "_exponent_mi," @ (parametrization.functionBasename) @ "_exponent_lo);\n";
                                                                    reductionCode = reductionCode @ "shiftedETimesC = eTimesC_hi + " @ (parametrization.functionBasename) @ "_shifter;\n";
                                                                    reductionCode = reductionCode @ "fd = shiftedETimesC - " @ (parametrization.functionBasename) @ "_shifter;\n";
                                                                    reductionCode = reductionCode @ "fCaster.d = shiftedETimesC;\n";
                                                                    reductionCode = reductionCode @ "fCaster.l <<= 32;\n";
                                                                    reductionCode = reductionCode @ "fCaster.l >>= 32;\n";
                                                                    reductionCode = reductionCode @ "F = (int) fCaster.l;\n";
                                                        eTimesCFormat = TD;
                                                 };
                                          };
                                      variableDecls = variableDecls @ "double minusFd;\n";
                                      reductionCode = reductionCode @ "minusFd = -fd;\n";
                                      match (eTimesCAdditionFormat) with
                                        D  : {
                                            match (eTimesCFormat) with
                                                  D  : {
                                                    /* D - D => D */
                                                    variableDecls = variableDecls @ "double eTimesCMinusF_hi;\n";
                                                    reductionCode = reductionCode @ "eTimesCMinusF_hi = eTimesC_hi + minusFd;\n";
                                                    eTimesCMinusFFormat = D;
                                                       }
                                                  DD : {
                                                    /* DD - D => D */
                                                    variableDecls = variableDecls @ "double eTimesCMinusF_hi;\n";
                                                    reductionCode = reductionCode @ "eTimesCMinusF_hi = (eTimesC_hi + minusFd) + eTimesC_mi;\n";
                                                    eTimesCMinusFFormat = D;
                                                       }
                                                  TD : {
                                                    /* TD - D => D */
                                                    variableDecls = variableDecls @ "double eTimesCMinusF_hi;\n";
                                                    reductionCode = reductionCode @ "eTimesCMinusF_hi = ((eTimesC_hi + minusFd) + eTimesC_mi) + eTimesC_lo;\n";
                                                    eTimesCMinusFFormat = D;
                                                       };
                                             }
                                        DD : {
                                            match (eTimesCFormat) with
                                                  D  : {
                                                    /* D - D => DD (impossible - Sterbenz: D) */
                                                    variableDecls = variableDecls @ "double eTimesCMinusF_hi;\n";
                                                    reductionCode = reductionCode @ "eTimesCMinusF_hi = eTimesC_hi + minusFd;\n";
                                                    eTimesCMinusFFormat = D;
                                                       }
                                                  DD : {
                                                    /* DD - D => DD */
                                                    variableDecls = variableDecls @ "double eTimesCMinusF_hi;\n";
                                                    variableDecls = variableDecls @ "double eTimesCMinusF_mi;\n";
                                                    variableDecls = variableDecls @ "double tempSubstr1;\n";
                                                    reductionCode = reductionCode @ "tempSubstr1 = eTimesC_hi + minusFd;\n";
                                                    reductionCode = reductionCode @ "Add12(eTimesCMinusF_hi,eTimesCMinusF_mi,tempSubstr1,eTimesC_mi);\n";
                                                    eTimesCMinusFFormat = DD;
                                                       }
                                                  TD : {
                                                    /* TD - D => DD */
                                                    variableDecls = variableDecls @ "double eTimesCMinusF_hi;\n";
                                                    variableDecls = variableDecls @ "double eTimesCMinusF_mi;\n";
                                                    variableDecls = variableDecls @ "double tempSubstr1;\n";
                                                    variableDecls = variableDecls @ "double tempSubstr2_hi, tempSubstr2_lo;\n";
                                                    variableDecls = variableDecls @ "double tempSubstr3;\n";
                                                    reductionCode = reductionCode @ "tempSubstr1 = eTimesC_hi + minusFd;\n";
                                                    reductionCode = reductionCode @ "Add12(tempSubstr2_hi,tempSubstr2_lo,tempSubstr1,eTimesC_mi);\n";
                                                    reductionCode = reductionCode @ "tempSubstr3 = tempSubstr2_lo + eTimesC_mi;\n";
                                                    reductionCode = reductionCode @ "Add12(eTimesCMinusF_hi,eTimesCMinusF_mi,tempSubstr2_hi,tempSubstr3);\n";
                                                    eTimesCMinusFFormat = DD;
                                                       };
                                             }
                                        TD : {
                                            match (eTimesCFormat) with
                                                  D  : {
                                                    /* D - D => TD (impossible - Sterbenz: D) */
                                                    variableDecls = variableDecls @ "double eTimesCMinusF_hi;\n";
                                                    reductionCode = reductionCode @ "eTimesCMinusF_hi = eTimesC_hi + minusFd;\n";
                                                    eTimesCMinusFFormat = D;
                                                       }
                                                  DD : {
                                                    /* DD - D => TD (impossible - Sterbenz: DD) */
                                                    variableDecls = variableDecls @ "double eTimesCMinusF_hi;\n";
                                                    variableDecls = variableDecls @ "double eTimesCMinusF_mi;\n";
                                                    variableDecls = variableDecls @ "double tempSubstr1;\n";
                                                    reductionCode = reductionCode @ "tempSubstr1 = eTimesC_hi + minusFd;\n";
                                                    reductionCode = reductionCode @ "Add12(eTimesCMinusF_hi,eTimesCMinusF_mi,tempSubstr1,eTimesC_mi);\n";
                                                    eTimesCMinusFFormat = DD;
                                                       }
                                                  TD : {
                                                    /* TD - D => TD */
                                                    variableDecls = variableDecls @ "double eTimesCMinusF_hi;\n";
                                                    variableDecls = variableDecls @ "double eTimesCMinusF_mi;\n";
                                                    variableDecls = variableDecls @ "double eTimesCMinusF_lo;\n";
                                                    variableDecls = variableDecls @ "double tempSubstr1;\n";
                                                    reductionCode = reductionCode @ "tempSubstr1 = eTimesC_hi + minusFd;\n";
                                                    reductionCode = reductionCode @ "Renormalize3(&eTimesCMinusF_hi,&eTimesCMinusF_mi,&eTimesCMinusF_lo,tempSubstr1,eTimesC_mi,eTimesC_lo);\n";
                                                    eTimesCMinusFFormat = TD;
                                                       };
                                             };
                                };

                                variableDecls = variableDecls @ (match (logFormat) with
                                                               D  : ( "double res_logh;" )
                                                   DD : ( "double res_logh, res_logm;" )
                                                   TD : ( "double res_logh, res_logm, res_logl;" )) @ "\n";
                                reductionCode = reductionCode @ (resLog.functionname) @ "(";
                                reductionCode = reductionCode @ (match (logFormat) with
                                                               D  : ( "&res_logh, " )
                                                   DD : ( "&res_logh, &res_logm, " )
                                                   TD : ( "&res_logh, &res_logm, &res_logl, " ));
                                reductionCode = reductionCode @ (match (problemdef.variableFormat) with
                                                               D  : ( "mh" )
                                                   DD : ( "mh, mm" )
                                                   TD : ( "mh, mm, ml"));
                                reductionCode = reductionCode @ ");\n";

                                match (logFormat) with
                                      D  : {
                                        variableDecls = variableDecls @ "double cTimesLog_hi;\n";
                                        reductionCode = reductionCode @ "cTimesLog_hi = res_logh * " @ (parametrization.functionBasename) @ "_exponent_hi;\n";
                                        cTimesLogFormat = D;
                                       }
                                      DD : {
                                        if (cStorageFormat == D) then {
                                            variableDecls = variableDecls @ "double cTimesLog_hi;\n";
                                            variableDecls = variableDecls @ "double cTimesLog_mi;\n";
                                            reductionCode = reductionCode @ "Mul122(&cTimesLog_hi, &cTimesLog_mi, " @ (parametrization.functionBasename) @ "_exponent_hi, res_logh, res_logm);\n";
                                            cTimesLogFormat = DD;
                                        } else {
                                            variableDecls = variableDecls @ "double cTimesLog_hi;\n";
                                            variableDecls = variableDecls @ "double cTimesLog_mi;\n";
                                            reductionCode = reductionCode @ "Mul22(&cTimesLog_hi, &cTimesLog_mi, " @ (parametrization.functionBasename) @ "_exponent_hi, " @ (parametrization.functionBasename) @ "_exponent_mi, res_logh, res_logm);\n";
                                            cTimesLogFormat = DD;
                                        };
                                       }
                                      TD : {
                                        match (cStorageFormat) with
                                              D  : {
                                                       variableDecls = variableDecls @ "double cTimesLog_hi;\n";
                                                       variableDecls = variableDecls @ "double cTimesLog_mi;\n";
                                                       variableDecls = variableDecls @ "double cTimesLog_lo;\n";
                                                       reductionCode = reductionCode @ "Mul133(&cTimesLog_hi, &cTimesLog_mi, &cTimesLog_lo, " @ (parametrization.functionBasename) @ "_exponent_hi, res_logh, res_logm, res_logl);\n";
                                                       cTimesLogFormat = TD;
                                                   }
                                              DD : {
                                                       variableDecls = variableDecls @ "double cTimesLog_hi;\n";
                                                       variableDecls = variableDecls @ "double cTimesLog_mi;\n";
                                                       variableDecls = variableDecls @ "double cTimesLog_lo;\n";
                                                       reductionCode = reductionCode @ "Mul233(&cTimesLog_hi, &cTimesLog_mi, &cTimesLog_lo, " @ (parametrization.functionBasename) @ "_exponent_hi, " @ (parametrization.functionBasename) @ "_exponent_mi, res_logh, res_logm, res_logl);\n";
                                                       cTimesLogFormat = TD;
                                                   }
                                              TD : {
                                                       variableDecls = variableDecls @ "double cTimesLog_hi;\n";
                                                       variableDecls = variableDecls @ "double cTimesLog_mi;\n";
                                                       variableDecls = variableDecls @ "double cTimesLog_lo;\n";
                                                       reductionCode = reductionCode @ "Mul33(&cTimesLog_hi, &cTimesLog_mi, &cTimesLog_lo, " @ (parametrization.functionBasename) @ "_exponent_hi, " @ (parametrization.functionBasename) @ "_exponent_mi, " @ (parametrization.functionBasename) @ "_exponent_lo, res_logh, res_logm, res_logl);\n";
                                                       cTimesLogFormat = TD;
                                                   };
                                       };
                                    match (eTimesCMinusFFormat) with
                                      D  : {
                                        match (cTimesLogFormat) with
                                              D  : {
                                                /* D + D =>  */
                                                if (eTimesCAdditionFormat == D) then {
                                                   variableDecls = variableDecls @ "double exp_arg_hi;\n";
                                                   reductionCode = reductionCode @ "exp_arg_hi = eTimesCMinusF_hi + cTimesLog_hi;\n";
                                                   expFinalFormat = D;
                                                } else {
                                                   variableDecls = variableDecls @ "double exp_arg_hi;\n";
                                                   variableDecls = variableDecls @ "double exp_arg_mi;\n";
                                                   reductionCode = reductionCode @ "Add12Cond(exp_arg_hi, exp_arg_mi, eTimesCMinusF_hi, cTimesLog_hi);\n";
                                                   expFinalFormat = DD;
                                                };
                                                   }
                                              DD : {
                                                /* D + DD =>  */
                                                if (eTimesCAdditionFormat == TD) then {
                                                   variableDecls = variableDecls @ "double exp_arg_hi;\n";
                                                   variableDecls = variableDecls @ "double exp_arg_mi;\n";
                                                   variableDecls = variableDecls @ "double exp_arg_lo;\n";
                                                   variableDecls = variableDecls @ "double tempAdd1_hi, tempAdd1_lo;\n";
                                                   variableDecls = variableDecls @ "double tempAdd2_hi, tempAdd2_lo;\n";
                                                   variableDecls = variableDecls @ "double tempAdd3_hi, tempAdd3_lo;\n";
                                                   variableDecls = variableDecls @ "double tempAdd4;\n";
                                                   reductionCode = reductionCode @ "Add12Cond(tempAdd1_hi, tempAdd1_lo, eTimesCMinusF_hi, cTimesLog_hi);\n";
                                                   reductionCode = reductionCode @ "Add12Cond(tempAdd2_hi, tempAdd2_lo, tempAdd1_lo, cTimesLog_mi);\n";
                                                   reductionCode = reductionCode @ "Add12Cond(tempAdd3_hi, tempAdd3_lo, tempAdd1_hi, tempAdd2_hi);\n";
                                                   reductionCode = reductionCode @ "Renormalize3(tempAdd3_hi,tempAdd3_lo,tempAdd2_lo);\n";
                                                   expFinalFormat = TD;
                                                } else {
                                                   variableDecls = variableDecls @ "double exp_arg_hi;\n";
                                                   variableDecls = variableDecls @ "double exp_arg_mi;\n";
                                                   variableDecls = variableDecls @ "double tempAdd1_hi, tempAdd1_lo;\n";
                                                   variableDecls = variableDecls @ "double tempAdd2_hi, tempAdd2_lo;\n";
                                                   variableDecls = variableDecls @ "double tempAdd3_hi, tempAdd3_lo;\n";
                                                   variableDecls = variableDecls @ "double tempAdd4;\n";
                                                   reductionCode = reductionCode @ "Add12Cond(tempAdd1_hi, tempAdd1_lo, eTimesCMinusF_hi, cTimesLog_hi);\n";
                                                   reductionCode = reductionCode @ "Add12Cond(tempAdd2_hi, tempAdd2_lo, tempAdd1_lo, cTimesLog_mi);\n";
                                                   reductionCode = reductionCode @ "Add12Cond(tempAdd3_hi, tempAdd3_lo, tempAdd1_hi, tempAdd2_hi);\n";
                                                   reductionCode = reductionCode @ "tempAdd4 = tempAdd2_lo + tempAdd3_lo;\n";
                                                   reductionCode = reductionCode @ "Add12Cond(exp_arg_hi, exp_arg_mi, tempAdd3_hi, tempAdd4);\n";
                                                   expFinalFormat = DD;
                                                };
                                                   }
                                              TD : {
                                                /* D + TD =>  */
                                                   variableDecls = variableDecls @ "double exp_arg_hi;\n";
                                                   variableDecls = variableDecls @ "double exp_arg_mi;\n";
                                                   variableDecls = variableDecls @ "double exp_arg_lo;\n";
                                                   variableDecls = variableDecls @ "double tempAdd1_hi, tempAdd1_lo;\n";
                                                   variableDecls = variableDecls @ "double tempAdd2_hi, tempAdd2_lo;\n";
                                                   variableDecls = variableDecls @ "double tempAdd3_hi, tempAdd3_lo;\n";
                                                   variableDecls = variableDecls @ "double tempAdd4_hi, tempAdd4_mi, tempAdd4_lo;\n";
                                                   variableDecls = variableDecls @ "double tempAdd5;\n";
                                                   reductionCode = reductionCode @ "Add12Cond(tempAdd1_hi, tempAdd1_lo, eTimesCMinusF_hi, cTimesLog_hi);\n";
                                                   reductionCode = reductionCode @ "Add12Cond(tempAdd2_hi, tempAdd2_lo, tempAdd1_lo, cTimesLog_mi);\n";
                                                   reductionCode = reductionCode @ "Add12Cond(tempAdd3_hi, tempAdd3_lo, tempAdd2_lo, cTimesLog_lo);\n";
                                                   reductionCode = reductionCode @ "Renormalize3(&tempAdd4_hi,&tempAdd4_mi,&tempAdd4_lo,tempAdd1_hi,tempAdd2_hi,tempAdd3_hi);\n";
                                                   reductionCode = reductionCode @ "tempAdd5 = tempAdd4_lo + tempAdd3_lo;\n";
                                                   reductionCode = reductionCode @ "Renormalize3(&exp_arg_hi,&exp_arg_mi,&exp_arg_lo,tempAdd4_hi,tempAdd4_mi,tempAdd5);\n";
                                                   expFinalFormat = TD;
                                                   };
                                       }
                                      DD : {
                                        match (cTimesLogFormat) with
                                              D  : {
                                                /* DD + D =>  */
                                                if (eTimesCAdditionFormat == TD) then {
                                                   variableDecls = variableDecls @ "double exp_arg_hi;\n";
                                                   variableDecls = variableDecls @ "double exp_arg_mi;\n";
                                                   variableDecls = variableDecls @ "double exp_arg_lo;\n";
                                                   variableDecls = variableDecls @ "double tempAdd1_hi, tempAdd1_lo;\n";
                                                   variableDecls = variableDecls @ "double tempAdd2_hi, tempAdd2_lo;\n";
                                                   variableDecls = variableDecls @ "double tempAdd3_hi, tempAdd3_lo;\n";
                                                   variableDecls = variableDecls @ "double tempAdd4;\n";
                                                   reductionCode = reductionCode @ "Add12Cond(tempAdd1_hi, tempAdd1_lo, eTimesCMinusF_hi, cTimesLog_hi);\n";
                                                   reductionCode = reductionCode @ "Add12Cond(tempAdd2_hi, tempAdd2_lo, tempAdd1_lo, eTimesCMinusF_mi);\n";
                                                   reductionCode = reductionCode @ "Add12Cond(tempAdd3_hi, tempAdd3_lo, tempAdd1_hi, tempAdd2_hi);\n";
                                                   reductionCode = reductionCode @ "Renormalize3(tempAdd3_hi,tempAdd3_lo,tempAdd2_lo);\n";
                                                   expFinalFormat = TD;
                                                } else {
                                                   variableDecls = variableDecls @ "double exp_arg_hi;\n";
                                                   variableDecls = variableDecls @ "double exp_arg_mi;\n";
                                                   variableDecls = variableDecls @ "double tempAdd1_hi, tempAdd1_lo;\n";
                                                   variableDecls = variableDecls @ "double tempAdd2_hi, tempAdd2_lo;\n";
                                                   variableDecls = variableDecls @ "double tempAdd3_hi, tempAdd3_lo;\n";
                                                   variableDecls = variableDecls @ "double tempAdd4;\n";
                                                   reductionCode = reductionCode @ "Add12Cond(tempAdd1_hi, tempAdd1_lo, eTimesCMinusF_hi, cTimesLog_hi);\n";
                                                   reductionCode = reductionCode @ "Add12Cond(tempAdd2_hi, tempAdd2_lo, tempAdd1_lo, eTimesCMinusF_mi);\n";
                                                   reductionCode = reductionCode @ "Add12Cond(tempAdd3_hi, tempAdd3_lo, tempAdd1_hi, tempAdd2_hi);\n";
                                                   reductionCode = reductionCode @ "tempAdd4 = tempAdd2_lo + tempAdd3_lo;\n";
                                                   reductionCode = reductionCode @ "Add12Cond(exp_arg_hi, exp_arg_mi, tempAdd3_hi, tempAdd4);\n";
                                                   expFinalFormat = DD;
                                                };
                                                   }
                                              DD : {
                                                /* DD + DD =>  */
                                                if (eTimesCAdditionFormat == TD) then {
                                                   variableDecls = variableDecls @ "double exp_arg_hi;\n";
                                                   variableDecls = variableDecls @ "double exp_arg_mi;\n";
                                                   variableDecls = variableDecls @ "double exp_arg_lo;\n";
                                                   variableDecls = variableDecls @ "double tempAdd1_hi, tempAdd1_lo;\n";
                                                   variableDecls = variableDecls @ "double tempAdd2_hi, tempAdd2_lo;\n";
                                                   variableDecls = variableDecls @ "double tempAdd3_hi, tempAdd3_lo;\n";
                                                   variableDecls = variableDecls @ "double tempAdd4;\n";
                                                   reductionCode = reductionCode @ "Add12Cond(tempAdd1_hi, tempAdd1_lo, eTimesCMinusF_hi, cTimesLog_hi);\n";
                                                   reductionCode = reductionCode @ "Add12Cond(tempAdd2_hi, tempAdd2_lo, eTimesCMinusF_mi, cTimesLog_mi);\n";
                                                   reductionCode = reductionCode @ "Add12Cond(tempAdd3_hi, tempAdd3_lo, tempAdd1_lo, tempAdd2_hi);\n";
                                                   reductionCode = reductionCode @ "tempAdd4 = tempAdd2_lo + tempAdd3_lo;\n";
                                                   reductionCode = reductionCode @ "Renormalize3(&exp_arg_hi,&exp_arg_mi,&exp_arg_lo,tempAdd1_hi,tempAdd3_hi,tempAdd4);\n";
                                                   expFinalFormat = TD;
                                                } else {
                                                   variableDecls = variableDecls @ "double exp_arg_hi;\n";
                                                   variableDecls = variableDecls @ "double exp_arg_mi;\n";
                                                   reductionCode = reductionCode @ "Add22Cond(&exp_arg_hi, &exp_arg_mi, eTimesCMinusF_hi, eTimesCMinusF_mi, cTimesLog_hi, cTimesLog_mi);\n";
                                                   expFinalFormat = DD;
                                                };
                                                   }
                                              TD : {
                                                /* DD + TD =>  */
                                                variableDecls = variableDecls @ "double exp_arg_hi;\n";
                                                variableDecls = variableDecls @ "double exp_arg_mi;\n";
                                                variableDecls = variableDecls @ "double exp_arg_lo;\n";
                                                variableDecls = variableDecls @ "double tempAdd1_hi, tempAdd1_mi, tempAdd1_lo;\n";
                                                reductionCode = reductionCode @ "Add233Cond(&tempAdd1_hi, &tempAdd1_mi, &tempAdd1_lo, eTimesCMinusF_hi, eTimesCMinusF_mi, cTimesLog_hi, cTimesLog_mi, cTimesLog_lo);\n";
                                                expFinalFormat = TD;
                                                   };
                                       }
                                      TD : {
                                        match (cTimesLogFormat) with
                                              D  : {
                                                /* TD + D =>  */
                                                variableDecls = variableDecls @ "double exp_arg_hi;\n";
                                                variableDecls = variableDecls @ "double exp_arg_mi;\n";
                                                variableDecls = variableDecls @ "double exp_arg_lo;\n";
                                                variableDecls = variableDecls @ "double tempAdd1_hi, tempAdd1_lo;\n";
                                                variableDecls = variableDecls @ "double tempAdd2_hi, tempAdd2_lo;\n";
                                                variableDecls = variableDecls @ "double tempAdd3_hi, tempAdd3_lo;\n";
                                                variableDecls = variableDecls @ "double tempAdd4_hi, tempAdd4_mi, tempAdd4_lo;\n";
                                                variableDecls = variableDecls @ "double tempAdd5;\n";
                                                reductionCode = reductionCode @ "Add12Cond(tempAdd1_hi, tempAdd1_lo, eTimesCMinusF_hi, cTimesLog_hi);\n";
                                                reductionCode = reductionCode @ "Add12Cond(tempAdd2_hi, tempAdd2_lo, tempAdd1_lo, eTimesCMinusF_mi);\n";
                                                reductionCode = reductionCode @ "Add12Cond(tempAdd3_hi, tempAdd3_lo, tempAdd2_lo, eTimesCMinusF_lo);\n";
                                                reductionCode = reductionCode @ "Renormalize3(&tempAdd4_hi,&tempAdd4_mi,&tempAdd4_lo,tempAdd1_hi,tempAdd2_hi,tempAdd3_hi);\n";
                                                reductionCode = reductionCode @ "tempAdd5 = tempAdd4_lo + tempAdd3_lo;\n";
                                                reductionCode = reductionCode @ "Renormalize3(&exp_arg_hi,&exp_arg_mi,&exp_arg_lo,tempAdd4_hi,tempAdd4_mi,tempAdd5);\n";
                                                expFinalFormat = TD;
                                                   }
                                              DD : {
                                                /* TD + DD =>  */
                                                variableDecls = variableDecls @ "double exp_arg_hi;\n";
                                                variableDecls = variableDecls @ "double exp_arg_mi;\n";
                                                variableDecls = variableDecls @ "double exp_arg_lo;\n";
                                                variableDecls = variableDecls @ "double tempAdd1_hi, tempAdd1_mi, tempAdd1_lo;\n";
                                                reductionCode = reductionCode @ "Add233Cond(&tempAdd1_hi, &tempAdd1_mi, &tempAdd1_lo, cTimesLog_hi, cTimesLog_mi, eTimesCMinusF_hi, eTimesCMinusF_mi, eTimesCMinusF_lo);\n";
                                                expFinalFormat = TD;
                                                   }
                                              TD : {
                                                /* TD + TD =>  */
                                                variableDecls = variableDecls @ "double exp_arg_hi;\n";
                                                variableDecls = variableDecls @ "double exp_arg_mi;\n";
                                                variableDecls = variableDecls @ "double exp_arg_lo;\n";
                                                variableDecls = variableDecls @ "double tempAdd1_hi, tempAdd1_lo;\n";
                                                variableDecls = variableDecls @ "double tempAdd2_hi, tempAdd2_lo;\n";
                                                variableDecls = variableDecls @ "double tempAdd3_hi, tempAdd3_lo;\n";
                                                variableDecls = variableDecls @ "double tempAdd4;\n";
                                                reductionCode = reductionCode @ "Add12Cond(tempAdd1_hi, tempAdd1_lo, eTimesCMinusF_hi, cTimesLog_hi);\n";
                                                reductionCode = reductionCode @ "Add12Cond(tempAdd2_hi, tempAdd2_lo, eTimesCMinusF_mi, cTimesLog_mi);\n";
                                                reductionCode = reductionCode @ "Add12Cond(tempAdd3_hi, tempAdd3_lo, tempAdd2_hi, tempAdd1_lo);\n";
                                                reductionCode = reductionCode @ "tempAdd4 = tempAdd3_lo + (tempAdd2_lo + (cTimesLog_lo + eTimesCMinusF_lo));\n";
                                                reductionCode = reductionCode @ "Renormalize3(&exp_arg_hi,&exp_arg_mi,&exp_arg_lo,tempAdd1_hi,tempAdd3_hi,tempAdd4);\n";
                                                expFinalFormat = TD;
                                                   };
                                       };
                                    match (expVariableformat) with
                                      D  : { }
                                  DD : {
                                        if (expFinalFormat == D) then {
                                           variableDecls = variableDecls @ "double exp_arg_mi;\n";
                                           reductionCode = reductionCode @ "exp_arg_mi = 0.0;\n";
                                        };
                                       }
                                  TD : {
                                        match (expFinalFormat) with
                                              D  : {
                                                   variableDecls = variableDecls @ "double exp_arg_mi;\n";
                                                   reductionCode = reductionCode @ "exp_arg_mi = 0.0;\n";
                                                   variableDecls = variableDecls @ "double exp_arg_lo;\n";
                                                   reductionCode = reductionCode @ "exp_arg_lo = 0.0;\n";
                                                   }
                                              DD : {
                                                   variableDecls = variableDecls @ "double exp_arg_lo;\n";
                                                   reductionCode = reductionCode @ "exp_arg_lo = 0.0;\n";
                                                   }
                                              TD : { };
                                       };
                                variableDecls = variableDecls @ (match (expFormat) with
                                                                       D  : ( "double res_exph;\n" )
                                                   DD : ( "double res_exph, res_expm;\n" )
                                                   TD : ( "double res_exph, res_expm, res_expl;\n" ));
                                reductionCode = reductionCode @ (resExp.functionname) @ "(";
                                reductionCode = reductionCode @ (match (expFormat) with
                                                                       D  : ( "&res_exph, " )
                                                   DD : ( "&res_exph, &res_expm, " )
                                                   TD : ( "&res_exph, &res_expm, &res_expl, " ));
                                reductionCode = reductionCode @ (match (expVariableformat) with
                                                               D  : ( "exp_arg_hi" )
                                                   DD : ( "exp_arg_hi, exp_arg_mi" )
                                                   TD : ( "exp_arg_hi, exp_arg_mi, exp_arg_lo" ));
                                reductionCode = reductionCode @ ");\n";
                                variableDecls = variableDecls @ "int F1, F2;\n";
                                reductionCode = reductionCode @ "F1 = F >> 1;\n";
                                                            reductionCode = reductionCode @ "F2 = F - F1;\n";
                                variableDecls = variableDecls @ "db_number scaleCaster1, scaleCaster2;\n";
                                variableDecls = variableDecls @ "double scale1, scale2;\n";
                                reductionCode = reductionCode @ "scaleCaster1.l = F1 + 1023ll;\n";
                                reductionCode = reductionCode @ "scaleCaster1.l <<= 52;\n";
                                reductionCode = reductionCode @ "scale1 = scaleCaster1.d;\n";
                                reductionCode = reductionCode @ "scaleCaster2.l = F2 + 1023ll;\n";
                                reductionCode = reductionCode @ "scaleCaster2.l <<= 52;\n";
                                if (postNegate) then {
                                    reductionCode = reductionCode @ "scale2 = -scaleCaster2.d;\n";
                                    } else {
                                    reductionCode = reductionCode @ "scale2 = scaleCaster2.d;\n";
                                };
                                match (expFormat) with
                                      D  : {
                                        reductionCode = reductionCode @ "*res_resh = scale2 * (scale1 * res_exph);\n";
                                       }
                                      DD : {
                                        reductionCode = reductionCode @ "*res_resh = scale2 * (scale1 * res_exph);\n";
                                        reductionCode = reductionCode @ "*res_resm = scale2 * (scale1 * res_expm);\n";
                                       }
                                      TD : {
                                        reductionCode = reductionCode @ "*res_resh = scale2 * (scale1 * res_exph);\n";
                                        reductionCode = reductionCode @ "*res_resm = scale2 * (scale1 * res_expm);\n";
                                        reductionCode = reductionCode @ "*res_resl = scale2 * (scale1 * res_expl);\n";
                                       };

                                display = oldDisplay!;

                                /* Generate the function header etc. and print out everything */
                                implCode = "\n";
                                implCode = implCode @ poundDefines @ "\n";
                                implCode = implCode @ "void " @ (parametrization.functionBasename) @ "(";
                                implCode = implCode @ (match expFormat with
                                                     D  : ( "double *res_resh, " )
                                             DD : ( "double *res_resh, double *res_resm, " )
                                             TD : ( "double *res_resh, double *res_resm, double *res_resl, " ));
                                implCode = implCode @ (match (problemdef.variableFormat) with
                                                     D  : ( "double xh" )
                                             DD : ( "double xh, double xm" )
                                             TD : ( "double xh, double xm, double xl"));
                                        implCode = implCode @ ") {\n";
                                implCode = implCode @ variableDecls @ "\n";
                                if (handleZero) then {
                                    implCode = implCode @ "if (xh == 0.0) {\n";
                                implCode = implCode @ (match expFormat with
                                                     D  : ( "*res_resh = 0.0;" )
                                             DD : ( "*res_resh = 0.0; *res_resm = 0.0;" )
                                             TD : ( "*res_resh = 0.0; *res_resm = 0.0; *res_resl = 0.0;" ));
                                implCode = implCode @ "\n} else {\n" @ reductionCode @ "\n}\n";
                                } else {
                                    implCode = implCode @ reductionCode @ "\n";
                                    };
                                implCode = implCode @ "}\n";

                                write(implCode) >> parametrization.implementationFile;

                                /* Report success */
                                result.approxerr = 1/2 * problemdef.target;   // TODO
                                    result.implerr = 1/2 * problemdef.target;     // TODO
                                        result.outputformat = expFormat;
                                        result.functionname = parametrization.functionBasename;
                                    result.okay = true;
                             } else {
                                write("Could not implement 2^x on \n",expDomain);
                             };
                               } else {
                                 write("Could not implement log2(x) on [1;2]\n");
                               };
                            };
                         };
                          };
                           };
                         };
                     }
                default : { };

      return result;
};

procedure doWorkForTryImplementationThroughMetaSplitting(problemdef, parametrization) {
      var result, domains, dom, currDom, okay, minWidth, origDefDom;
      var myProblemdef, myParametrization, res, suffix, i, oldDisplay, currImplementationFile;
      var outputDomains, outputResults, outputFiles, implFile;
      var splitterCode, recursiveSplitterRes;
      var functionNames, outputFormats, myOutputFormat, myOutputFormatNum;
      var implErr, approxErr;
      var oP, oPP;

      result = { .okay = false };

      dom = problemdef.dom;
      minWidth = parametrization.metaSplitMinWidth;
      oP = prec;
      prec = max(300, prec)!;
      if (inf(dom) * sup(dom) < 0) then {
         domains = [| [ inf(dom), D(inf(dom) / 3)], [D(inf(dom) / 3), D(sup(dom) / 3)], [D(sup(dom) / 3), sup(dom)] |];
      } else {
         domains = [| [inf(dom), D(mid(dom))], [D(mid(dom)), sup(dom)] |];
      };
      prec = oP!;

      okay = true; i = 0;
      outputDomains = [||];
      outputResults = [||];
      outputFiles = [||];
      while (okay && (domains != [||])) do {
        currDom = head(domains);
        domains = tail(domains);
        if (sup(currDom) - inf(currDom) >= abs(minWidth)) then {
            oldDisplay = display;
            display = decimal!;
            suffix = "_metasplit_" @ i;
            display = oldDisplay!;
            currImplementationFile = parametrization.implementationFile @ suffix;
                    myProblemdef.func = problemdef.func;
            myProblemdef.dom = currDom;
            myProblemdef.target = problemdef.target;
            myProblemdef.variableFormat = problemdef.variableFormat;
            origDefDom = problemdef.dom;
            match (problemdef) with { .definitionDomain = default } : {
                                         if (origDefDom in problemdef.definitionDomain) then {
                                                    origDefDom = problemdef.definitionDomain;
                                                 }; }
                                            default : {};
            myProblemdef.definitionDomain = origDefDom;
            myParametrization = parametrization;
            myParametrization.gappaFile = parametrization.gappaFile @ suffix;
            myParametrization.gappaOutputFile = parametrization.gappaOutputFile @ suffix;
            myParametrization.functionBasename = parametrization.functionBasename @ suffix;
            myParametrization.implementationFile = currImplementationFile;
            myParametrization.doNotPerformMetaSplitArgRed = true;
            myParametrization.minWidth = (sup(currDom) - inf(currDom)) * (parametrization.minWidth / (sup(dom) - inf(dom)));
            myParametrization.argumentReduced = true;

            write("Trying to implement the given function on ", currDom, "\n");
            res = tryImplementation(myProblemdef, myParametrization);

            if (res.okay) then {
               write("The implementation of the function on ", currDom, " has been successful.\n");
               outputDomains = outputDomains :. currDom;
               outputResults = outputResults :. res;
               outputFiles = outputFiles :. currImplementationFile;
               i := i + 1;
            } else {
                  write("The implementation of the function on ", currDom, " has failed. Resplitting.\n");
              oPP = prec;
              prec = max(300, prec)!;
                      if (inf(currDom) * sup(currDom) < 0) then {
                         domains = [| [ inf(currDom), D(inf(currDom) / 3)], [D(inf(currDom) / 3), D(sup(currDom) / 3)], [D(sup(currDom) / 3), sup(currDom)] |] @ domains;
                      } else {
                         domains = [| [inf(currDom), D(mid(currDom))], [D(mid(currDom)), sup(currDom)] |] @ domains;
                      };
              prec = oPP!;
            };
        } else {
            okay = false;
        };
      };

      if (okay) then {
         /* Combine all implementation files into one file */
         write("\n") > parametrization.implementationFile;
         for implFile in outputFiles do {
             bashexecute("cat " @ implFile @ " >> " @ (parametrization.implementationFile));
         bashexecute("rm " @ implFile);
         };

         functionNames = [||];
         outputFormats = [||];
         myOutputFormatNum = 1;
         implErr = 0;
         approxErr = 0;
         for res in outputResults do {
             myOutputFormatNum = max(myOutputFormatNum,
                     match res.outputformat with D : (1) DD : (2) TD : (3));
         implErr = max(implErr, abs(res.implerr));
         approxErr = max(approxErr, abs(res.approxerr));
         outputFormats = outputFormats :. (res.outputformat);
         functionNames = functionNames :. (res.functionname);
         };

         myOutputFormat = match myOutputFormatNum with 1 : (D) 2 : (DD) 3 : (TD);

         splitterCode = "\n";
         recursiveSplitterRes = generateRecursiveSplitter((parametrization.functionBasename) @ "_metasplit", outputDomains, functionNames, outputFormats, problemdef.variableFormat, myOutputFormat);
             if (recursiveSplitterRes.okay) then {
        splitterCode = splitterCode @ recursiveSplitterRes.defines;
                splitterCode = splitterCode @ "\n\nvoid " @ (parametrization.functionBasename) @ "(";
            splitterCode = splitterCode @ (match myOutputFormat with
                                                     D   : ( "double *res_resh, " )
                                                     DD  : ( "double *res_resh, double *res_resm, " )
                                                     TD  : ( "double *res_resh, double *res_resm, double *res_resl, " )
                                              );
                splitterCode = splitterCode @ (match problemdef.variableFormat with
                                                     D   : ( "double xh" )
                                                     DD  : ( "double xh, double xm" )
                                                     TD  : ( "double xh, double xm, double xl" )
                                              );
                splitterCode = splitterCode @ ") {\n";
        splitterCode = splitterCode @ recursiveSplitterRes.splitterCode;
                splitterCode = splitterCode @ "}\n\n";
        write(splitterCode) >> parametrization.implementationFile;
             };

         result.okay = true;
         result.approxerr = approxErr;
         result.implErr = implErr;
         result.outputformat = myOutputFormat;
         result.functionname = (parametrization.functionBasename);
      };

      return result;
};

procedure tryImplementationThroughMetaSplitting(problemdef, parametrization) {
      var result, needArgumentReduction, res, doNotPerformMetaSplitArgRed;

      result = { .okay = false };

      match ( { .problemdef = problemdef,
                    .parametrization = parametrization } ) with
                { .problemdef =      { .func = default,
                                       .dom = default,
                                       .target = default,
                                       .variableFormat = default },
                  .parametrization = { .maxDegree = default,
                                       .minWidth = default,
                                       .beta = default,
                           .implementationFile = default,
                                       .gappaFile = default,
                                       .gappaOutputFile = default,
                                       .gappaExecutable = default,
                       .functionBasename = default,
                       .tableIndexWidth = default,
                       .metaSplitMinWidth = default } } : {

                       /* Test if we may perform this type of argument
                          reduction
                       */
                       doNotPerformMetaSplitArgRed = false;
                       match (parametrization) with
                             { .doNotPerformMetaSplitArgRed = true } : { doNotPerformMetaSplitArgRed = true; }
                         default : { };

                       if (!doNotPerformMetaSplitArgRed) then {
                           /* Start with a test if the domain actually needs
                                              argument reduction in order to stay below the maximum
                          polynomial degree
                           */
                           needArgumentReduction = true;
                           res = checkIfSufficientDegree(problemdef.func, problemdef.dom, parametrization.maxDegree, problemdef.target);

                                           if (res.okay) then {
                                           if (res.sufficientDegree) then needArgumentReduction = false;
                           } else {
                               needArgumentReduction = false;
                           };

                           if (needArgumentReduction) then {
                          result = doWorkForTryImplementationThroughMetaSplitting(problemdef, parametrization);
                           };
                         };
                     }
                default : { };

      return result;
};

procedure limitListToNElements(l,n) {
      var res, i;

      if (length(l) <= n) then {
         res = l;
      } else {
        res = [||];
        for i from 0 to n - 1 do {
            res = res :. (l[i]);
        };
      };

      return res;
};

procedure removeDoubleEntriesInSortedList(l) {
      var ll, p, e, lll;

      if (l == [||]) then {
         ll = [||];
      } else {
         lll = l;
         p = head(lll);
         lll = tail(lll);
         ll = [| p |];
         while (lll != [||]) do {
               e = head(lll);
           lll = tail(lll);
           if (e != p) then {
              ll = e .: ll;
              p = e;
           };
         };

      };

      return revert(ll);
};

procedure comparePossiblePeriods(ppA, ppB) {
      var res;

      if (mid(ppA) == mid(ppB)) then {
         res = 0;
      } else {
        if (mid(ppA) < mid(ppB)) then {
           res = -1;
        } else {
           res = 1;
        };
      };

      return res;
};

procedure insertPossiblePeriod(possiblePeriods, pp) {
      var res, ppH, ppT, i, m, bigger;

      if (possiblePeriods == [||]) then {
         res = [| pp |];
      } else {
         if (length(possiblePeriods) < 5) then {
            res = [||];
        i = 0;
        bigger = false;
        while ((i < length(possiblePeriods)) && (!bigger)) do {
               if (comparePossiblePeriods(possiblePeriods[i], pp) >= 0) then {
                          bigger = true;
               } else {
                  res = possiblePeriods[i] .: res;
                  i = i + 1;
               };
        };
        res = pp .: res;
        while (i < length(possiblePeriods)) do {
              res = possiblePeriods[i] .: res;
              i = i + 1;
        };
        res = revert(res);
         } else {
            m = floor((length(possiblePeriods) - 1) / 2);
        ppH = [||];
        ppT = [||];
        for i from 0 to length(possiblePeriods) - 1 do {
               if (i < m) then {
                  ppH = (possiblePeriods[i]) .: ppH;
               } else {
                  ppT = (possiblePeriods[i]) .: ppT;
               };
        };
        ppH = revert(ppH);
        ppT = revert(ppT);
        if (comparePossiblePeriods(ppT[0], pp) < 0) then {
           res = ppH @ insertPossiblePeriod(ppT, pp);
        } else {
           res = insertPossiblePeriod(ppH, pp) @ ppT;
        };
         };
      };

      return res;
};

procedure testIfFunctionCouldBePeriodic(func, dom) {
      var res, y, myDom, myFunc, t, zerosDerivShifted;
      var oldPrec, zerosDeriv, myFuncDeriv, zd, zu, zI;
      var possiblePeriods, i, j, pp, testedPossiblePeriods, c, yC, tX;
      var oP;

      res = false;
      oldPrec = prec;
      prec = 24!;
      y = evaluate(diff(func), dom);
      if (0 in y) then {
         t = inf(dom) - 1;
         oP = prec;
         prec = max(300, prec)!;
         myDom = dom - t;
         prec = oP!;
         myFunc = func(x + t);
         myFuncDeriv = diff(myFunc);
         zerosDerivShifted = mydirtyfindzeros(myFuncDeriv, myDom);
         if (length(zerosDerivShifted) >= 2) then {
            zerosDerivShifted = limitListToNElements(zerosDerivShifted, 25);
            zerosDeriv = [||];
        minZ = zerosDerivShifted[0];
        for z in zerosDerivShifted do {
            zd = min(z * (1 - 2^(-prec+2)), z * (1 + 2^(-prec+2)));
                zu = max(z * (1 - 2^(-prec+2)), z * (1 + 2^(-prec+2)));
                zI = [zd; zu];
            if (0 in evaluate(myFuncDeriv, zI)) then {
               zerosDeriv = (zI + t) .: zerosDeriv;
                    };
        };
        zerosDeriv = revert(zerosDeriv);
        if (length(zerosDeriv) >= 2) then {
            possiblePeriods = [||];
            for i from 0 to length(zerosDeriv) - 2 do {
                for j from i + 1 to length(zerosDeriv) - 1 do {
                pp = zerosDeriv[j] - zerosDeriv[i];
                if (!(0 in pp)) then {
                   possiblePeriods = insertPossiblePeriod(possiblePeriods, pp);
                };
            };
            };
            if (possiblePeriods != [||]) then {
                testedPossiblePeriods = [||];
                c = (1023 * inf(dom) + sup(dom)) / 1024;
                yC = evaluate(func,c);
                for pp in possiblePeriods do {
                    tX = c + pp;
                if ((inf(tX) >= inf(dom)) &&
                    (sup(tX) <= sup(dom))) then {
                    tY = evaluate(func, tX);
                    if (yC in tY) then {
                        testedPossiblePeriods = pp .: testedPossiblePeriods;
                    };
                };
                };
                testedPossiblePeriods = revert(testedPossiblePeriods);
                if (testedPossiblePeriods != [||]) then {
               /* Add additional filters here */
               res = true;
            };
            };
        };
         };
      };
      prec = oldPrec!;

      return res;
};

procedure tryDetectPeriodicArgRed(func, dom, target, xFormat) {
      var result, c, zeros, i, j, len;
      var oldPrec;
      var possiblePeriods;
      var testfunc, y, zerosUpper, zerosLower;
      var recDom;
      var oldPoints;
      var okay, myPeriod;
      var t;
      var zerosUpperRaw, zerosLowerRaw, z;
      var zerosDeriv;

      result = { .okay = false };

      if (testIfFunctionCouldBePeriodic(func, dom)) then {
      /* Functions with no local or only one local extrema can't be periodic.
         So start by checking if the derivative of the function
         has a zero
      */
          zerosDeriv = mydirtyfindzeros(diff(func), dom);

      if (length(zerosDeriv) >= 2) then {
      /* We try to find all points where
         func admits the same value as in
         a point c. The distances to c
         then give an idea of a possible
         period.
      */
      if (0 in dom) then {
         c = 0;
      } else {
         c = (1023 * inf(dom) + sup(dom)) / 1024;
      };

      oldPrec = prec;
      oldPoints = points;
          meanPeriod = 0;
      numPeriod = 0;
      points = ((points - 1) * 4 + 1)!;
      prec = max(500, prec, 4 * ceil(-log2(target)) + 100)!;
      if (abs(func(c)) <= 1b1024) then {
         zeros = mydirtyfindzeros(func - func(c), dom);
      } else {
         zeros = [||];
      };
      zeros = limitListToNElements(zeros, 25);

      points = oldPoints!;
      len = length(zeros);
          possiblePeriods = [||];
      if (len >= 2) then {
         for i from 0 to len - 2 do {
             for j from i + 1 to len - 1 do {
             possiblePeriods = (zeros[j] - zeros[i]) .: possiblePeriods;
         };
         };
         possiblePeriods = sort(possiblePeriods);
         possiblePeriods = removeDoubleEntriesInSortedList(possiblePeriods);
          };
      prec = oldPrec!;

      okay = false;
      while ((!okay) && (possiblePeriods != [||])) do {
        myPeriod = head(possiblePeriods);
        possiblePeriods = tail(possiblePeriods);
        recDom = [inf(dom); sup(dom) - myPeriod];
            testfunc = simplifysafe(func(x + myPeriod)/func - 1);

        if (0 in recDom) then t = 0 else t = ~((2 * inf(recDom) + sup(recDom)) / 3);
            y = evaluate(testfunc, t);

        if (!(y in [-target, target])) then {
           if (func(t) == 0) then {
              t = ~(inf(recDom) + myPeriod / 3);
              y = evaluate(testfunc, t);
           };
        };

            if (y in [-target, target]) then {

             zerosUpperRaw = mydirtyfindzeros(testfunc + target, recDom);
             zerosLowerRaw = mydirtyfindzeros(testfunc - target, recDom);

             zerosUpper = [||];
             for z in zerosUpperRaw do {
                 if (!(func(z + myPeriod) == func(z))) then {
                zerosUpper = z .: zerosUpper;
             };
             };

             zerosLower = [||];
             for z in zerosLowerRaw do {
                 if (!(func(z + myPeriod) == func(z))) then {
                zerosLower = z .: zerosLower;
             };
             };

             if ((zerosUpper == [||]) && (zerosLower == [||])) then {
                okay = true;
             };
        };
      };

      if (okay) then {
         result.okay = true;
         result.period = myPeriod;
      };

      };
      };

      return result;
};

procedure checkSterbenzConditionForPeriodicArgRed(dom, c, period) {
      var domMinusCOverPeriod;
      var kRange, k;
      var res;
      var alphaRange;
      var actualA, actualB, actualDom;
      var actualExpoDom, possibleExpoDom;

      /* Given k = nearestint((x - c)/p), we have to check if

         1/2 <= abs(x) / abs(p * k) <= 2

         or k = 0

         for all x in dom.

      */

      res = false;

      domMinusCOverPeriod = (dom - c) / period;
      kRange = nearestint(domMinusCOverPeriod);

      if (inf(kRange) == sup(kRange)) then {
         k = inf(kRange);
         if (k == 0) then {
            res = true;
         } else {
            alphaRange = abs(dom) / abs(k * period);
        res = (alphaRange in [1/2;2]);
         };
      } else {
         res = false;
         if (!(0 in kRange)) then {
            alphaRange = abs(dom) / abs(kRange * period);
        res = (alphaRange in [1/2;2]);
         };
         if (!res) then {
             if (sup(kRange) - inf(kRange) <= 10) then {
               res = true;
               for k from inf(kRange) to sup(kRange) do {
               if (k != 0) then {
                       if (period >= 0) then {
                      actualA := period * (k - 1/2) + c;
                      actualB := period * (k + 1/2) + c;
                   } else {
                      actualA := period * (k + 1/2) + c;
                      actualB := period * (k - 1/2) + c;
                   };
                   actualA = max(inf(dom), actualA);
                   actualB = min(sup(dom), actualB);
                   if (actualA <= actualB) then {
                      actualDom = [actualA; actualB];
                  currRes = (inf(abs(actualDom)) >= 1/2 * abs(k * period)) &&
                                        (sup(abs(actualDom)) <= 2 * abs(k * period));
                      if ((!currRes) && (!(0 in actualDom))) then {
                      actualExpoDom = floor(log2(abs(actualDom)));
                  possibleExpoDom = [floor(log2(abs(k * period))) - 1, floor(log2(abs(k * period))) + 1];
                  currRes = actualExpoDom in possibleExpoDom;
                  };
                  res = res && currRes;
                   };
                       };
               };
             } else {
                res = (checkSterbenzConditionForPeriodicArgRed([inf(dom); mid(dom)], c, period)
                   && checkSterbenzConditionForPeriodicArgRed([mid(dom); sup(dom)], c, period));
             };
          };
      };

      return res;
};

procedure computePeriodicArgumentReductionErrorAmplification(dom, c, period, xFormat) {
   var alpha;
   var kRange;
   var k;
   var pK, pKRounded, delta, currAlpha;
   var hardK;

   kRange = nearestint((dom - c)/period);
   alpha = 0;
   hardK = inf(kRange);
   for k from inf(kRange) to sup(kRange) do {
       if (k != 0) then {
          pK = period * k;
      pKRounded = round(~pK,xFormat,RN);
      delta = pKRounded - pK;
      currAlpha := abs((-pK)/delta);
      if (currAlpha > alpha) then {
         alpha = currAlpha;
         hardK = k;
      };
       };
   };

   if (!(alpha == alpha)) then {
      alpha = infty;
   };

   return { .alpha = alpha, .hardK = k };
};

procedure constantIsRepresentableOnDoubleExpansion(c) {
      var res;

      res = { .representable = false };

      if (D(c) - c == 0) then {
         res = { .representable = true, .format = D };
      } else {
         if (DD(c) - c == 0) then {
            res = { .representable = true, .format = DD };
         } else {
            if (TD(c) - c == 0) then {
               res = { .representable = true, .format = TD };
            };
         };
      };

      return res;
};

procedure tryImplementArgumentReductionCodePeriodic(dom, period, c, inputFormat, argRedConstantFormat, reducedArgFormat, outputFormat, haveSterbenzOnArgRed,
                                        reducedFunctionName, implementationFile, functionName) {
    var res;
    var roundedPeriod;
    var epsSubstr;
    var variableDecls, codeDecls, poundDefineDecls;
    var okay;
    var oldDisplay;

    res = { .okay = false };
    okay = true;
    roundedPeriod = round(~period, argRedConstantFormat, RN);
    res.epsConst = abs(roundedPeriod/period - 1);
    if (haveSterbenzOnArgRed) then {
       epsSubstr = 0;
    } else {
       epsSubstr = infty;
    };
    poundDefineDecls = "";
    variableDecls = "";
    codeDecls = "";

    /* Generate the variable declarations and the code for the argument reduction */
    oldDisplay = display;
    display = decimal!;
    poundDefineDecls = poundDefineDecls @ "#define " @ functionName @ "_shifter 6755399441055744.0\n";
    if (D(c) != 0) then poundDefineDecls = poundDefineDecls @ "#define " @ functionName @ "_center " @  D(c) @ "\n";
    poundDefineDecls = poundDefineDecls @ "#define " @ functionName @ "_period_recpr " @  D(1/period) @ "\n";
    match (argRedConstantFormat) with
          D  : { poundDefineDecls = poundDefineDecls @ "#define " @ functionName @ "_period_hi " @  D(-roundedPeriod) @ "\n"; }
      DD : { poundDefineDecls = poundDefineDecls @ "#define " @ functionName @ "_period_hi " @  D(-roundedPeriod) @ "\n";
                 poundDefineDecls = poundDefineDecls @ "#define " @ functionName @ "_period_mi " @  D(-roundedPeriod - D(-roundedPeriod)) @ "\n";
           }
          TD : { poundDefineDecls = poundDefineDecls @ "#define " @ functionName @ "_period_hi " @  D(-roundedPeriod) @ "\n";
                 poundDefineDecls = poundDefineDecls @ "#define " @ functionName @ "_period_mi " @  D(-roundedPeriod - D(-roundedPeriod)) @ "\n";
                 poundDefineDecls = poundDefineDecls @ "#define " @ functionName @ "_period_lo " @  D(-roundedPeriod - (D(-roundedPeriod) + D(-roundedPeriod - D(-roundedPeriod)))) @ "\n";
               };
    display = oldDisplay!;

    variableDecls = variableDecls @ "double t, s, k;\n";
    if (D(c) != 0) then {
       codeDecls = codeDecls @ "t = " @ functionName @ "_period_recpr * (xh - " @ functionName @ "_center);\n";
    } else {
       codeDecls = codeDecls @ "t = " @ functionName @ "_period_recpr * xh;\n";
    };
    codeDecls = codeDecls @ "s = " @ functionName @ "_shifter + t;\n";
    codeDecls = codeDecls @ "k = s - " @ functionName @ "_shifter;\n";

    match (inputFormat) with
          D  : {
            match (argRedConstantFormat) with
                  D  : {
                    match (reducedArgFormat) with
                          D  : {
                            codeDecls = codeDecls @ "MulAdd1111(&rh, xh, k, " @ functionName @ "_period_hi);\n";
                            if (!haveSterbenzOnArgRed) then epsSubstr = 1b-51;
                               }
                          DD : {
                            codeDecls = codeDecls @ "MulAdd1112(&rh, &rm, xh, k, " @ functionName @ "_period_hi);\n";
                            if (!haveSterbenzOnArgRed) then epsSubstr = 1b-104;
                               }
                          TD : {
                            codeDecls = codeDecls @ "MulAdd1113(&rh, &rm, &rl, xh, k, " @ functionName @ "_period_hi);\n";
                            if (!haveSterbenzOnArgRed) then epsSubstr = 1b-150;
                               };
                       }
                  DD : {
                    match (reducedArgFormat) with
                          D  : {
                            codeDecls = codeDecls @ "MulAdd1121(&rh, xh, k, " @ functionName @ "_period_hi, " @ functionName @ "_period_mi);\n";
                            if (!haveSterbenzOnArgRed) then epsSubstr = 1b-51;
                               }
                          DD : {
                            codeDecls = codeDecls @ "MulAdd1122(&rh, &rm, xh, k, " @ functionName @ "_period_hi, " @ functionName @ "_period_mi);\n";
                            if (!haveSterbenzOnArgRed) then epsSubstr = 1b-104;
                               }
                          TD : {
                            codeDecls = codeDecls @ "MulAdd1123(&rh, &rm, &rl, xh, k, " @ functionName @ "_period_hi, " @ functionName @ "_period_mi);\n";
                            if (!haveSterbenzOnArgRed) then epsSubstr = 1b-150;
                               };
                       }
                  TD : {
                    match (reducedArgFormat) with
                          D  : {
                            codeDecls = codeDecls @ "MulAdd1131(&rh, xh, k, " @ functionName @ "_period_hi, " @ functionName @ "_period_mi, " @ functionName @ "_period_lo);\n";
                            if (!haveSterbenzOnArgRed) then epsSubstr = 1b-51;
                               }
                          DD : {
                            codeDecls = codeDecls @ "MulAdd1132(&rh, &rm, xh, k, " @ functionName @ "_period_hi, " @ functionName @ "_period_mi, " @ functionName @ "_period_lo);\n";
                            if (!haveSterbenzOnArgRed) then epsSubstr = 1b-104;
                               }
                          TD : {
                            codeDecls = codeDecls @ "MulAdd1133(&rh, &rm, &rl, xh, k, " @ functionName @ "_period_hi, " @ functionName @ "_period_mi, " @ functionName @ "_period_lo);\n";
                            if (!haveSterbenzOnArgRed) then epsSubstr = 1b-150;
                               };
                       };
           }
          DD : {
            match (argRedConstantFormat) with
                  D  : {
                    match (reducedArgFormat) with
                          D  : {
                            codeDecls = codeDecls @ "MulAdd2111(&rh, xh, xm, k, " @ functionName @ "_period_hi);\n";
                            if (!haveSterbenzOnArgRed) then epsSubstr = 1b-51;
                               }
                          DD : {
                            codeDecls = codeDecls @ "MulAdd2112(&rh, &rm, xh, xm, k, " @ functionName @ "_period_hi);\n";
                            if (!haveSterbenzOnArgRed) then epsSubstr = 1b-104;
                               }
                          TD : {
                            codeDecls = codeDecls @ "MulAdd2113(&rh, &rm, &rl, xh, xm, k, " @ functionName @ "_period_hi);\n";
                            if (!haveSterbenzOnArgRed) then epsSubstr = 1b-150;
                               };
                       }
                  DD : {
                    match (reducedArgFormat) with
                          D  : {
                            codeDecls = codeDecls @ "MulAdd2121(&rh, xh, xm, k, " @ functionName @ "_period_hi, " @ functionName @ "_period_mi);\n";
                            if (!haveSterbenzOnArgRed) then epsSubstr = 1b-51;
                               }
                          DD : {
                            codeDecls = codeDecls @ "MulAdd2122(&rh, &rm, xh, xm, k, " @ functionName @ "_period_hi, " @ functionName @ "_period_mi);\n";
                            if (!haveSterbenzOnArgRed) then epsSubstr = 1b-104;
                               }
                          TD : {
                            codeDecls = codeDecls @ "MulAdd2123(&rh, &rm, &rl, xh, xm, k, " @ functionName @ "_period_hi, " @ functionName @ "_period_mi);\n";
                            if (!haveSterbenzOnArgRed) then epsSubstr = 1b-150;
                               };
                       }
                  TD : {
                    match (reducedArgFormat) with
                          D  : {
                            codeDecls = codeDecls @ "MulAdd2131(&rh, xh, xm, k, " @ functionName @ "_period_hi, " @ functionName @ "_period_mi, " @ functionName @ "_period_lo);\n";
                            if (!haveSterbenzOnArgRed) then epsSubstr = 1b-51;
                               }
                          DD : {
                            codeDecls = codeDecls @ "MulAdd2132(&rh, &rm, xh, xm, k, " @ functionName @ "_period_hi, " @ functionName @ "_period_mi, " @ functionName @ "_period_lo);\n";
                            if (!haveSterbenzOnArgRed) then epsSubstr = 1b-104;
                               }
                          TD : {
                            codeDecls = codeDecls @ "MulAdd2133(&rh, &rm, &rl, xh, xm, k, " @ functionName @ "_period_hi, " @ functionName @ "_period_mi, " @ functionName @ "_period_lo);\n";
                            if (!haveSterbenzOnArgRed) then epsSubstr = 1b-150;
                               };
                       };
           }
          TD : {
            match (argRedConstantFormat) with
                  D  : {
                    match (reducedArgFormat) with
                          D  : {
                            codeDecls = codeDecls @ "MulAdd3111(&rh, xh, xm, xl, k, " @ functionName @ "_period_hi);\n";
                            if (!haveSterbenzOnArgRed) then epsSubstr = 1b-51;
                               }
                          DD : {
                            codeDecls = codeDecls @ "MulAdd3112(&rh, &rm, xh, xm, xl, k, " @ functionName @ "_period_hi);\n";
                            if (!haveSterbenzOnArgRed) then epsSubstr = 1b-104;
                               }
                          TD : {
                            codeDecls = codeDecls @ "MulAdd3113(&rh, &rm, &rl, xh, xm, xl, k, " @ functionName @ "_period_hi);\n";
                            if (!haveSterbenzOnArgRed) then epsSubstr = 1b-150;
                               };
                       }
                  DD : {
                    match (reducedArgFormat) with
                          D  : {
                            codeDecls = codeDecls @ "MulAdd3121(&rh, xh, xm, xl, k, " @ functionName @ "_period_hi, " @ functionName @ "_period_mi);\n";
                            if (!haveSterbenzOnArgRed) then epsSubstr = 1b-51;
                               }
                          DD : {
                            codeDecls = codeDecls @ "MulAdd3122(&rh, &rm, xh, xm, xl, k, " @ functionName @ "_period_hi, " @ functionName @ "_period_mi);\n";
                            if (!haveSterbenzOnArgRed) then epsSubstr = 1b-104;
                               }
                          TD : {
                            codeDecls = codeDecls @ "MulAdd3123(&rh, &rm, &rl, xh, xm, xl, k, " @ functionName @ "_period_hi, " @ functionName @ "_period_mi);\n";
                            if (!haveSterbenzOnArgRed) then epsSubstr = 1b-150;
                               };
                       }
                  TD : {
                    match (reducedArgFormat) with
                          D  : {
                            codeDecls = codeDecls @ "MulAdd3131(&rh, xh, xm, xl, k, " @ functionName @ "_period_hi, " @ functionName @ "_period_mi, " @ functionName @ "_period_lo);\n";
                            if (!haveSterbenzOnArgRed) then epsSubstr = 1b-51;
                               }
                          DD : {
                            codeDecls = codeDecls @ "MulAdd3132(&rh, &rm, xh, xm, xl, k, " @ functionName @ "_period_hi, " @ functionName @ "_period_mi, " @ functionName @ "_period_lo);\n";
                            if (!haveSterbenzOnArgRed) then epsSubstr = 1b-104;
                               }
                          TD : {
                            codeDecls = codeDecls @ "MulAdd3133(&rh, &rm, &rl, xh, xm, xl, k, " @ functionName @ "_period_hi, " @ functionName @ "_period_mi, " @ functionName @ "_period_lo);\n";
                            if (!haveSterbenzOnArgRed) then epsSubstr = 1b-150;
                               };
                       };
           };

    /* Write the pound-defines, the function header and the code to the file */
    write("\n\n",poundDefineDecls,"\n\n") >> implementationFile;
    write("void ", functionName, "(") >> implementationFile;
    match (outputFormat) with
          D  : {
              write("double *res_resh, ") >> implementationFile;
           }
          DD : {
              write("double *res_resh, double *res_resm, ") >> implementationFile;
           }
          TD : {
              write("double *res_resh, double *res_resm, double *res_resl, ") >> implementationFile;
           };
    match (inputFormat) with
          D  : {
                  write("double xh") >> implementationFile;
           }
          DD : {
                  write("double xh, double xm") >> implementationFile;
           }
          TD : {
                  write("double xh, double xm, double xl") >> implementationFile;
           };
    write(") {\n") >> implementationFile;
    match (reducedArgFormat) with
          D  : {
                  write("double rh;\n") >> implementationFile;
           }
          DD : {
                  write("double rh, rm;\n") >> implementationFile;
           }
          TD : {
                  write("double rh, rm, rl;\n") >> implementationFile;
           };
    write(variableDecls,"\n\n",codeDecls,"\n") >> implementationFile;
    write(reducedFunctionName,"(") >> implementationFile;
    match (outputFormat) with
          D  : {
              write("res_resh, ") >> implementationFile;
           }
          DD : {
              write("res_resh, res_resm, ") >> implementationFile;
           }
          TD : {
              write("res_resh, res_resm, res_resl, ") >> implementationFile;
           };
    match (reducedArgFormat) with
          D  : {
                  write("rh") >> implementationFile;
           }
          DD : {
                  write("rh, rm") >> implementationFile;
           }
          TD : {
                  write("rh, rm, rl") >> implementationFile;
           };
    write(");\n}\n\n") >> implementationFile;

    /* Return the status */
    res.epsSubstr = epsSubstr;
    if (okay) then {
       res.okay = true;
    };

    return res;
};

procedure computeReducedDomainAndMidpointCasesPeriodic(func, dom, c, p, xFormat) {
      var midpointCases;
      var a, b, r, t, s, k, i, ia, ib, td, xt, tpl, xtp;

      /* We have to compute the image domain of the
         argument reduction

          r = x - p * nearestint((x - c) / p)

         for x in dom a floating-point value of format xFormat.

         For that image domain, we must not account for midpoint
         cases but put them in an extra list.

         We start by analyzing at the bounds of the original
         domain.

      */
      midpointCases = [||];

      s = round(inf(dom),xFormat,RU);
      t = (s - c) / p;
      k = nearestint(t);
      if (abs(k - t) == 1/2) then {
         midpointCases = s .: midpointCases;
         s = round(inf(dom) + 1b-2000,xFormat,RU);
         t = (s - c) / p;
         k = nearestint(t);
      };
      r = s - p * k;
      a = r;
      b = r;

      s = round(sup(dom),xFormat,RD);
      t = (s - c) / p;
      k = nearestint(t);
      if (abs(k - t) == 1/2) then {
         midpointCases = s .: midpointCases;
         s = round(sup(dom) - 1b-2000,xFormat,RD);
         t = (s - c) / p;
         k = nearestint(t);
      };
      r = s - p * k;

      a = min(a, r);
      b = max(b, r);

      /* Now go over all rounding boundaries of nearestint
         that are possible in the domain for (x - c)/p
      */
      td = (dom - c) / p;
      ia = floor(inf(td)) + 1/2;
      while (ia < inf(td)) do ia = ia + 1;
      ib = ceil(sup(td)) - 1/2;
      while (ib > sup(td)) do ib = ib - 1;

      for i from ia to ib by 1 do {
          xt = i * p + c;
          if (xt == round(xt,xFormat,RN)) then {
             midpointCases = xt .: midpointCases;
         tpl = [| round(xt - 1b-2000, xFormat, RD), round(xt + 1b-2000, xFormat, RU) |];
          } else {
             tpl = [| round(xt, xFormat, RD), round(xt, xFormat, RU) |];
          };

          for xtp in tpl do {
              if (xtp in dom) then {
                 t = (xtp - c) / p;
                 k = nearestint(t);
                 r = xtp - p * k;

                 a = min(a, r);
                 b = max(b, r);
          };
          };
      };

      return { .reducedDom = [a, b], .midpointCases = midpointCases };
};

procedure doWorkForTryImplementationThroughPeriodic(problemdef, parametrization) {
      var result, res;
      var func, dom, target, period;
      var c, reducedDom;
      var haveSterbenzOnArgRed, pKStaysSmall, kStaysSmall;
      var alphaPeriodConstant, alphaPeriodConstantTemp;
      var variableFormat;
      var alpha;
      var argRedTarget, reducedTarget;
      var isRepresentablePeriod;
      var argRedConstantTarget, argRedSubtractionTarget;
      var argRedConstantFormat;
      var argRedRepresentationTarget;
      var reducedArgFormat;
      var myProblemdef, origDefDom, suffix;
      var resArgRed;
      var midpointCases;
      var redDomMidpointCases;
      var neededAccuracyOfArg;
      var cantbe;

      result = { .okay = false };

      cantbe = false;
      match (parametrization) with
            { .originalProblemDefinition = default,
          .estimatedRangeFuncPrime = default } : {
                                if ((abs(inf(parametrization.estimatedRangeFuncPrime)) < infty) &&
                                    (abs(sup(parametrization.estimatedRangeFuncPrime)) < infty) &&
                                    (inf(parametrization.estimatedRangeFuncPrime) == inf(parametrization.estimatedRangeFuncPrime)) &&
                                    (sup(parametrization.estimatedRangeFuncPrime) == sup(parametrization.estimatedRangeFuncPrime)) &&
                                    ((parametrization.originalProblemDefinition.func) == (problemdef.func)) &&
                                    ((problemdef.dom) in (parametrization.originalProblemDefinition.dom))) then {
                                    if (!(0 in (parametrization.estimatedRangeFuncPrime))) then {
                                       cantbe = true;
                                    } else {
                                       cantbe = false;
                                    };
                                    } else {
                                   cantbe = false;
                                };  
                                                 }
        default : { cantbe = false; };

          if (!cantbe) then {
         match (parametrization) with
               { .originalProblemDefinition = default,
             .estimatedZerosFunc = default } : {
                              if (((parametrization.originalProblemDefinition.func) == (problemdef.func)) &&
                                  ((problemdef.dom) in (parametrization.originalProblemDefinition.dom))) then {
                                if (length(parametrization.estimatedZerosFunc) == 1) then {
                                   cantbe = true;
                                } else {
                                   cantbe = false;
                                };
                              } else {
                                cantbe = false;
                              };
                                                       }
           default : { cantbe = false; };
      };

      if (cantbe) then {
             res = { .okay = false };
      } else {
             res = tryDetectPeriodicArgRed(problemdef.func, problemdef.dom, problemdef.target * 1/8, problemdef.variableFormat);
      };

      if (res.okay) then {
         /* Here we know that func is periodic with period period */
         func = problemdef.func;
         dom = problemdef.dom;
         target = problemdef.target * 1/8;
         period = res.period;
         variableFormat = problemdef.variableFormat;

         /* Now compute a value c and a resulting
            reduced domain:

        r = x - p * nearestint((x - c) / p)

        where p is the period

        The reduced domain is

        reducedDom = [ c - p/2 ; c + p/2 ]

        As we want to stay in the same definition
        domain of the function, we must choose c in
        such a way that reducedDom is included in dom.
              */
          if (sup(dom) - inf(dom) > period) then {
             if (0 in [inf(dom) + period/2; sup(dom) - period/2]) then {
            c = 0;
         } else {
            if (0 in [inf(dom); inf(dom) + period/2]) then {
               c = round(inf(dom) + period/2, D, RU);
            } else {
              if (0 in [sup(dom) - period/2; sup(dom)]) then {
                 c = round(sup(dom) - period/2, D, RD);
              } else {
                 c = D(mid(dom));
              };
            };
         };
         reducedDom = [ c - period/2; c + period/2 ];
         midpointCases = [||];
         
         /* Just to be sure, we check that the reduced domain
            is contained in the original domain. Otherwise, we simply fail.

            We also check if the integer nearestint((x-c)/p)) we need for
                    argument reduction does not grow too large.

         */
         if ((reducedDom in dom) && (sup(abs((dom - c)/period)) <= 1b13)) then {
            /* Now check if the function has a zero in the reduced domain.
               If yes, recompute the reduced domain to contain only
               non-midpoint cases of argument reduction, along with a
               list of midpoint cases.
            */

            if (mydirtyfindzeros(func, reducedDom) != [||]) then {
               redDomMidpointCases = computeReducedDomainAndMidpointCasesPeriodic(func, dom, c, period, variableFormat);
               reducedDom = redDomMidpointCases.reducedDom;
               midpointCases = redDomMidpointCases.midpointCases;
            };

            /* Now we check if we have either the Sterbenz condition
                       for the subtraction

                          x minus p * nearestint((x - c)/p)

                       or the certainty that

                          abs(p * nearestint((x - c)/p)) <= 1/2 * abs(x)
                    */
            haveSterbenzOnArgRed = checkSterbenzConditionForPeriodicArgRed(dom, c, period);

            pKStaysSmall = false;
            if (!haveSterbenzOnArgRed) then {
               pKStaysSmall = (sup(abs(period * nearestint((dom - c)/period))) <= inf(abs(1/2 * dom)));
            };

            kStaysSmall = false;
            if (!pKStaysSmall) then {
               kStaysSmall = (sup(abs(nearestint((dom - c)/period))) < 1000);
            };

            if (haveSterbenzOnArgRed || pKStaysSmall || kStaysSmall) then {
               /* Compute the factor alpha by which the function amplifies the
                  relative error of the reduced argument into the final error due
              to argument reduction.
               */

               neededAccuracyOfArg = computeNeededAccuracyOfArgumentWorkHard(func, reducedDom, target);

               alpha = abs(abs(target) / abs(neededAccuracyOfArg));
               write("The amplification factor of the periodic function is approximately ", round(alpha,12,RN), " = 2^(", round(log2(alpha),12,RN),")\n");

               /* Compute the target errors */
               reducedTarget = 1/8 * target;
               argRedTarget = 1/8 * target * 1/alpha;
               if (haveSterbenzOnArgRed) then {
                  argRedConstantTarget = 1/4 * argRedTarget;
              argRedSubtractionTarget = 0;
              argRedRepresentationTarget = 1/8 * argRedTarget;
               } else {
                  argRedConstantTarget = 1/8 * argRedTarget;
              argRedSubtractionTarget = 1/8 * argRedTarget;
              argRedRepresentationTarget = 1/8 * argRedTarget;
               };

               /* Check if the period is representable on a double expansion.

              If yes, we perhaps don't need to compute the amplification factor of the
              error in the constant.
               */
               isRepresentablePeriod = constantIsRepresentableOnDoubleExpansion(period);

               /* Preset the format for the argument reduction constant (the period) */
               argRedConstantFormat = { .determined = false };

               /* Depending on whether the period is representable on a double expansion,
                  compute the amplification factor that determines how much the error in the
              stored constant is amplified.
               */
               if (isRepresentablePeriod.representable) then {
                  if (isRepresentablePeriod.format == D) then {
                 argRedConstantFormat = { .determined = true, .format = D };
              } else {
                 /* Now, we compute the amplification factor alphaPeriodConstant
                        that amplifies the relative error in the stored constant for the period
                                with respect to the relative error of the reduced argument that gets
                                computed out of the approximate constant.
                     */
                     alphaPeriodConstantTemp = computePeriodicArgumentReductionErrorAmplification(dom, c, period, variableFormat);
                     alphaPeriodConstant = alphaPeriodConstantTemp.alpha;

                     if (1b-53 * alphaPeriodConstant <= argRedConstantTarget) then {
                    argRedConstantFormat = { .determined = true, .format = D };
                 } else {
                    if (1b-107 * alphaPeriodConstant <= argRedConstantTarget) then {
                       argRedConstantFormat = { .determined = true, .format = DD };
                    } else {
                       if (1b-161 * alphaPeriodConstant <= argRedConstantTarget) then {
                      if (isRepresentablePeriod.format == DD) then {
                                         argRedConstantFormat = { .determined = true, .format = DD };
                      } else {
                             argRedConstantFormat = { .determined = true, .format = TD };
                          };
                       } else {
                      argRedConstantFormat = { .determined = true, .format = isRepresentablePeriod.format };
                   };
                    };
                 };
              };
               } else {
              /* Now, we compute the amplification factor alphaPeriodConstant
                     that amplifies the relative error in the stored constant for the period
                             with respect to the relative error of the reduced argument that gets
                             computed out of the approximate constant.
                  */
                  alphaPeriodConstantTemp = computePeriodicArgumentReductionErrorAmplification(dom, c, period, variableFormat);
                  alphaPeriodConstant = alphaPeriodConstantTemp.alpha;

              if (1b-53 * alphaPeriodConstant <= argRedConstantTarget) then {
                 argRedConstantFormat = { .determined = true, .format = D };
              } else {
                 if (1b-107 * alphaPeriodConstant <= argRedConstantTarget) then {
                    argRedConstantFormat = { .determined = true, .format = DD };
                 } else {
                    if (1b-161 * alphaPeriodConstant <= argRedConstantTarget) then {
                       argRedConstantFormat = { .determined = true, .format = TD };
                    };
                 };
              };
               };

               if (argRedConstantFormat.determined) then {
                  argRedConstantFormat = argRedConstantFormat.format;
              write("Periodic argument reduction will store the periodic constant as a ", argRedConstantFormat, "\n");

              /* Now determine the format the reduced
                             argument has to be in. This format
                             usually is smaller than the format used for the periodic constant and it might
                             actually be smaller than the entering variable format.
             */
                 reducedArgFormat = { .determined = false };

             if (1b-53 <= argRedRepresentationTarget) then {
                reducedArgFormat = { .determined = true, .format = D };
             } else {
                if (1b-107 <= argRedRepresentationTarget) then {
                   reducedArgFormat = { .determined = true, .format = DD };
                } else {
                   if (1b-161 <= argRedRepresentationTarget) then {
                      reducedArgFormat = { .determined = true, .format = TD };
                   };
                            };
             };

             if (reducedArgFormat.determined) then {
                reducedArgFormat = reducedArgFormat.format;
                write("The reduced argument after periodic argument reduction will be represented on a ", reducedArgFormat, "\n");

                /* Now try to implement the reduced function */
                suffix = "_periodic";
                            myProblemdef.func = problemdef.func;
                    myProblemdef.dom = reducedDom;
                    myProblemdef.target = reducedTarget;
                    myProblemdef.variableFormat = reducedArgFormat;
                    origDefDom = problemdef.dom;
                    match (problemdef) with { .definitionDomain = default } : {
                                              if (origDefDom in problemdef.definitionDomain) then {
                                                          origDefDom = problemdef.definitionDomain;
                                                      }; }
                                                    default : {};
                    myProblemdef.definitionDomain = origDefDom;
                    myParametrization = parametrization;
                    myParametrization.functionBasename = parametrization.functionBasename @ suffix;
                    myParametrization.doNotPerformPeriodicArgRed = true;
                myParametrization.minWidth = (sup(reducedDom) - inf(reducedDom)) * (parametrization.minWidth / (sup(problemdef.dom) - inf(problemdef.dom)));
                            myParametrization.argumentReduced = true;

                    write("Trying to implement the function on the reduced argument domain ", reducedDom, "\n");
                    res = tryImplementation(myProblemdef, myParametrization);

                    if (res.okay) then {
                   write("Implementation of the function on the reduced domain was successful. Trying to implement the argument reduction.\n");
                   resArgRed = tryImplementArgumentReductionCodePeriodic(dom, period, c, variableFormat, argRedConstantFormat, reducedArgFormat, res.outputformat, haveSterbenzOnArgRed,
                                                                         res.functionname, parametrization.implementationFile, parametrization.functionBasename);

                   if (resArgRed.okay) then {
                              result.okay = true;
                              result.approxerr = res.approxerr;
                              result.implErr = (1 + problemdef.target * 1/8) * (1 + alpha * alphaPeriodConstant * resArgRed.epsConst +
                                                                                        alpha * resArgRed.epsSubstr +
                                                                                        alpha * alphaPeriodConstant * resArgRed.epsConst * resArgRed.epsSubstr) - 1;
                              result.outputformat = res.outputformat;
                              result.functionname = parametrization.functionBasename;
                           };
                };
             };
               };
            };
         };
          };
      };

      return result;
};

procedure tryImplementationThroughArgumentReductionPeriodic(problemdef, parametrization) {
      var result, needArgumentReduction, res, doNotPerformPeriodicArgRed;

      result = { .okay = false };

      match ( { .problemdef = problemdef,
                    .parametrization = parametrization } ) with
                { .problemdef =      { .func = default,
                                       .dom = default,
                                       .target = default,
                                       .variableFormat = default },
                  .parametrization = { .maxDegree = default,
                                       .minWidth = default,
                                       .beta = default,
                           .implementationFile = default,
                                       .gappaFile = default,
                                       .gappaOutputFile = default,
                                       .gappaExecutable = default,
                       .functionBasename = default,
                       .tableIndexWidth = default,
                       .metaSplitMinWidth = default } } : {

                       /* Test if we may perform this type of argument
                          reduction
                       */
                       doNotPerformPeriodicArgRed = false;
                       match (parametrization) with
                             { .doNotPerformPeriodicArgRed = true } : { doNotPerformPeriodicArgRed = true; }
                         default : { };

                       if (!doNotPerformPeriodicArgRed) then {
                           /* Start with a test if the domain actually needs
                                              argument reduction in order to stay below the maximum
                          polynomial degree
                           */
                           needArgumentReduction = true;
                           res = checkIfSufficientDegree(problemdef.func, problemdef.dom, parametrization.maxDegree, problemdef.target);

                                           if (res.okay) then {
                                           if (res.sufficientDegree) then needArgumentReduction = false;
                           } else {
                               needArgumentReduction = false;
                           };

                           if (needArgumentReduction) then {
                          result = doWorkForTryImplementationThroughPeriodic(problemdef, parametrization);
                           };
                         };
                     }
                default : { };

      return result;
};


procedure formatToExpansionLength(format) {
      return match (format) with
                  D       : (1)
          DD      : (2)
                  TD      : (3)
                  default : (error);
};

procedure expansionLengthToFormat(expans) {
      return [| D, DD, TD |][expans - 1];
};

procedure doWorkForTryImplementationThroughExpressionDecompositionAddition(func, g, h, problemdef, parametrization) {
      var result;
      var maxeps, dom;
      var maxepsAdd, maxepsG, maxepsH, alphaG, alphaH;

      result = { .okay = false };

      /* Get the target error bound and the domain for g and h */
      maxeps = abs(problemdef.target);
      dom = problemdef.dom;

      /* Cut the target error into pieces */
      maxepsAdd = 1/3 * maxeps;

      alphaG = mydirtyinfnorm(g / (g + h),dom);
      alphaH = mydirtyinfnorm(h / (g + h),dom);

      /* TODO */

      return result;
};



procedure doWorkForTryImplementationThroughExpressionDecompositionMultiplication(func, g, h, problemdef, parametrization) {
      var result;
      var maxeps, dom, maxepsG, maxepsH, maxepsMul;
      var myProblemdef, suffix, origDefDom, myParametrization, res, res2;
      var finalOutputFormat;
      var implementationcode;

      result = { .okay = false };

      /* Get the target error bound and the domain for g and h */
      maxeps = abs(problemdef.target);
      dom = problemdef.dom;

      /* Cut the target error into pieces */
      maxepsG = 1/4 * maxeps;
      maxepsH = 1/4 * maxeps;
      maxepsMul = 1/4 * maxeps;

      /* Say that we are going to decompose f into g and h */
      write("Expression decomposition detected that the function can be split into f = g(x) * h(x) with\n");
      write("    g(x) = ", g, " on domain ", dom, " and\n");
      write("    h(x) = ", h, " on domain ", dom, "\n");

      /* Try to implement g */
      myProblemdef.func = g;
      myProblemdef.dom = dom;
      myProblemdef.target = maxepsG;
      myProblemdef.variableFormat = problemdef.variableFormat;
      suffix = "_expr_decomp_prod_g";
      origDefDom = problemdef.dom;
      match (problemdef) with { .definitionDomain = default } : {
                                   if (origDefDom in problemdef.definitionDomain) then {
                                          origDefDom = problemdef.definitionDomain;
                                       }; }
                                  default : {};
      myProblemdef.definitionDomain = origDefDom;
      myParametrization = parametrization;
      myParametrization.performExpressionDecomposition = max(parametrization.performExpressionDecomposition - 1, 0);
      myParametrization.gappaFile = parametrization.gappaFile @ suffix;
      myParametrization.gappaOutputFile = parametrization.gappaOutputFile @ suffix;
      myParametrization.functionBasename = parametrization.functionBasename @ suffix;

      res = tryImplementation(myProblemdef, myParametrization);

      if (res.okay) then {
        write("Implementation of subfunction g successful, now trying to implement h\n");

            myProblemdef.func = h;
            myProblemdef.dom = dom;
            myProblemdef.target = maxepsH;
            myProblemdef.variableFormat = problemdef.variableFormat;
            suffix = "_expr_decomp_prod_h";
            myProblemdef.definitionDomain = origDefDom;
            myParametrization = parametrization;
            myParametrization.performExpressionDecomposition = max(parametrization.performExpressionDecomposition - 1, 0);
            myParametrization.gappaFile = parametrization.gappaFile @ suffix;
            myParametrization.gappaOutputFile = parametrization.gappaOutputFile @ suffix;
            myParametrization.functionBasename = parametrization.functionBasename @ suffix;
                myParametrization.implementationFile = parametrization.implementationFile @ "_expr_decomp_prod_subfunction_g";

            res2 = tryImplementation(myProblemdef, myParametrization);

        if (res2.okay) then {
           write("Implementation of subfunction h successful\n");
           bashexecute("cat " @ parametrization.implementationFile @ "_expr_decomp_prod_subfunction_g >> " @ parametrization.implementationFile);
           bashexecute("rm " @ parametrization.implementationFile @ "_expr_decomp_prod_subfunction_g");
           write("Generating multiplication code\n");

           if (maxepsMul < 1b-102) then finalOutputFormat = TD else
            if (maxepsMul < 1b-53) then finalOutputFormat = DD else
             finalOutputFormat = D;

           finalOutputFormat = expansionLengthToFormat(max(formatToExpansionLength(finalOutputFormat),
                                       formatToExpansionLength(res.outputformat),
                                       formatToExpansionLength(res2.outputformat)));

           implementationcode = "\n";
           implementationcode = implementationcode @ "void " @ parametrization.functionBasename @ "(";
           implementationcode = implementationcode @ (match finalOutputFormat with
                                            D  : ( "double *res_resh, " )
                                    DD : ( "double *res_resh, double *res_resm, " )
                                    TD : ( "double *res_resh, double *res_resm, double *res_resl, " ));
           implementationcode = implementationcode @ (match problemdef.variableFormat with
                                            D  : ( "double xh" )
                                    DD : ( "double xh, double xm" )
                                    TD : ( "double xh, double xm, double xl"));
           implementationcode = implementationcode @ ") {\n";
           match (res.outputformat) with
                 D  : {
                    implementationcode = implementationcode @ "double res_g_resh;\n";
                      }
                 DD : {
                    implementationcode = implementationcode @ "double res_g_resh;\n";
                    implementationcode = implementationcode @ "double res_g_resm;\n";
                      }
                 TD : {
                    implementationcode = implementationcode @ "double res_g_resh;\n";
                    implementationcode = implementationcode @ "double res_g_resm;\n";
                    implementationcode = implementationcode @ "double res_g_resl;\n";
                      };
           match (res2.outputformat) with
                 D  : {
                    implementationcode = implementationcode @ "double res_h_resh;\n";
                      }
                 DD : {
                    implementationcode = implementationcode @ "double res_h_resh;\n";
                    implementationcode = implementationcode @ "double res_h_resm;\n";
                      }
                 TD : {
                    implementationcode = implementationcode @ "double res_h_resh;\n";
                    implementationcode = implementationcode @ "double res_h_resm;\n";
                    implementationcode = implementationcode @ "double res_h_resl;\n";
                      };
           implementationcode = implementationcode @ "\n";
           implementationcode = implementationcode @ res.functionname @ "(";
           implementationcode = implementationcode @ (match (res.outputformat) with
                                            D  : ( "&res_g_resh, " )
                                    DD : ( "&res_g_resh, &res_g_resm, " )
                                    TD : ( "&res_g_resh, &res_g_resm, &res_g_resl, "));
           implementationcode = implementationcode @ (match (problemdef.variableFormat) with
                                            D  : ( "xh" )
                                    DD : ( "xh, xm" )
                                    TD : ( "xh, xm, xl" ));
           implementationcode = implementationcode @ ");\n";
                   implementationcode = implementationcode @ res2.functionname @ "(";
           implementationcode = implementationcode @ (match (res2.outputformat) with
                                            D  : ( "&res_h_resh, " )
                                    DD : ( "&res_h_resh, &res_h_resm, " )
                                    TD : ( "&res_h_resh, &res_h_resm, &res_h_resl, "));
           implementationcode = implementationcode @ (match (problemdef.variableFormat) with
                                            D  : ( "xh" )
                                    DD : ( "xh, xm" )
                                    TD : ( "xh, xm, xl" ));
           implementationcode = implementationcode @ ");\n";
           match (finalOutputFormat) with
                 D  : {
                    implementationcode = implementationcode @ "*res_resh = res_g_resh * res_h_resh;\n";
                              }
                 DD : {
                    match (res.outputformat) with
                          D  : {
                            implementationcode = implementationcode @ "Mul122(res_resh,res_resm,res_g_resh,res_h_resh,res_h_resm);\n";
                               }
                              DD : {
                            match (res2.outputformat) with
                                  D  : {
                                            implementationcode = implementationcode @ "Mul122(res_resh,res_resm,res_h_resh,res_g_resh,res_g_resm);\n";
                                   }
                                      DD : {
                                            implementationcode = implementationcode @ "Mul22(res_resh,res_resm,res_g_resh,res_g_resm,res_h_resh,res_h_resm);\n";
                                   };
                               };
                      }
                 TD : {
                    match (res.outputformat) with
                          D  : {
                                implementationcode = implementationcode @ "Mul133(res_resh,res_resm,res_resl,res_g_resh,res_h_resh,res_h_resm,res_h_resl);\n";
                               }
                          DD : {
                                implementationcode = implementationcode @ "Mul233(res_resh,res_resm,res_resl,res_g_resh,res_g_resm,res_h_resh,res_h_resm,res_h_resl);\n";
                               }
                          TD : {
                            match (res2.outputformat) with
                                  D  : {
                                            implementationcode = implementationcode @ "Mul133(res_resh,res_resm,res_resl,res_h_resh,res_g_resh,res_g_resm,res_g_resl);\n";
                                       }
                                  DD : {
                                            implementationcode = implementationcode @ "Mul233(res_resh,res_resm,res_resl,res_h_resh,res_h_resm,res_g_resh,res_g_resm,res_g_resl);\n";
                                       }
                                  TD : {
                                            implementationcode = implementationcode @ "Mul33(res_resh,res_resm,res_resl,res_h_resh,res_h_resm,res_h_resl,res_g_resh,res_g_resm,res_g_resl);\n";
                                       };
                               };
                      };
           implementationcode = implementationcode @ "}\n";
           write(implementationcode) >> parametrization.implementationFile;
           result.okay = true;
           result.outputformat = finalOutputFormat;
           result.functionname = parametrization.functionBasename;
           // TODO Add error bounds
        };
      };

      return result;
};

procedure doWorkForTryImplementationThroughExpressionDecompositionComposition(func, g, h, problemdef, parametrization) {
      var result;
      var domG, domH;
      var maxepsG, maxepsH, maxeps;
      var myProblemdef, suffix, origDefDom, myParametrization, res, res2;

      result = { .okay = false };

      /* Get the target error bound, get the domain for h */
      maxeps = abs(problemdef.target);
      domH = problemdef.dom;

      /* Compute the domain for g */
      domG = dirtyEvaluateImage(h,domH);

      /* Compute the accuracy needed for h in order to stay within the target error bound
         after the amplification of the error by g
      */
      maxepsH = abs(computeNeededAccuracyOfArgumentWorkHard(g,domG,3/8 * maxeps));
      maxepsG = 3/8 * maxeps;

      /* Check if we can theoretically do both error bounds */
      if ((maxepsH > 1b-157) && (maxepsG > 1b-157)) then {
         write("Expression decomposition detected that the function can be split into f = g(h(x)) with\n");
         write("    g(x) = ", g, " on domain ", domG, " with rel. err. bounded by 2^(",~log2(maxepsG),") and\n");
         write("    h(x) = ", h, " on domain ", domH, " with rel. err. bounded by 2^(",~log2(maxepsH),")\n");

         write("Trying to implement h\n");
         myProblemdef.func = h;
         myProblemdef.dom = domH;
         myProblemdef.target = maxepsH;
         myProblemdef.variableFormat = problemdef.variableFormat;
         suffix = "_expr_decomp_h";
         origDefDom = problemdef.dom;
         match (problemdef) with { .definitionDomain = default } : {
                                      if (origDefDom in problemdef.definitionDomain) then {
                                             origDefDom = problemdef.definitionDomain;
                                          }; }
                                     default : {};
         myProblemdef.definitionDomain = origDefDom;
         myParametrization = parametrization;
         myParametrization.performExpressionDecomposition = max(parametrization.performExpressionDecomposition - 1, 0);
         myParametrization.gappaFile = parametrization.gappaFile @ suffix;
         myParametrization.gappaOutputFile = parametrization.gappaOutputFile @ suffix;
         myParametrization.functionBasename = parametrization.functionBasename @ suffix;

         res = tryImplementation(myProblemdef, myParametrization);

         if (res.okay) then {
            write("Implementation of subfunction h successful, now trying to implement g\n");

            myProblemdef.func = g;
            myProblemdef.dom = domG;
            myProblemdef.target = maxepsG;
            myProblemdef.variableFormat = res.outputformat;
            suffix = "_expr_decomp_g";
            myProblemdef.definitionDomain = domG;
            myParametrization = parametrization;
            myParametrization.performExpressionDecomposition = max(parametrization.performExpressionDecomposition - 1, 0);
            myParametrization.gappaFile = parametrization.gappaFile @ suffix;
            myParametrization.gappaOutputFile = parametrization.gappaOutputFile @ suffix;
            myParametrization.functionBasename = parametrization.functionBasename @ suffix;
                myParametrization.implementationFile = parametrization.implementationFile @ "_expr_decomp_subfunction_g";

            res2 = tryImplementation(myProblemdef, myParametrization);

        if (res2.okay) then {
           write("Implementation of subfunction g successful\n");
           bashexecute("cat " @ parametrization.implementationFile @ "_expr_decomp_subfunction_g >> " @ parametrization.implementationFile);
           bashexecute("rm " @ parametrization.implementationFile @ "_expr_decomp_subfunction_g");
           write("Generating composition code\n");

           implementationcode = "\n";
           implementationcode = implementationcode @ "void " @ parametrization.functionBasename @ "(";
           implementationcode = implementationcode @ (match res2.outputformat with
                                            D  : ( "double *res_resh, " )
                                    DD : ( "double *res_resh, double *res_resm, " )
                                    TD : ( "double *res_resh, double *res_resm, double *res_resl, " ));
           implementationcode = implementationcode @ (match problemdef.variableFormat with
                                            D  : ( "double xh" )
                                    DD : ( "double xh, double xm" )
                                    TD : ( "double xh, double xm, double xl"));
           implementationcode = implementationcode @ ") {\n";
           implementationcode = implementationcode @ (match res.outputformat with
                                            D  : ( "double res_h_resh;\n" )
                                    DD : ( "double res_h_resh, res_h_resm;\n" )
                                    TD : ( "double res_h_resh, res_h_resm, res_h_resl;\n" ));
           implementationcode = implementationcode @ "\n";

           implementationcode = implementationcode @ res.functionname @ "(";
           implementationcode = implementationcode @ (match res.outputformat with
                                            D  : ( "&res_h_resh, " )
                                    DD : ( "&res_h_resh, &res_h_resm, " )
                                    TD : ( "&res_h_resh, &res_h_resm, &res_h_resl, " ));
           implementationcode = implementationcode @ (match problemdef.variableFormat with
                                            D  : ( "xh" )
                                    DD : ( "xh, xm" )
                                    TD : ( "xh, xm, xl"));
           implementationcode = implementationcode @ ");\n";

           implementationcode = implementationcode @ res2.functionname @ "(";
           implementationcode = implementationcode @ (match res2.outputformat with
                                            D  : ( "res_resh, " )
                                    DD : ( "res_resh, res_resm, " )
                                    TD : ( "res_resh, res_resm, res_resl, " ));
           implementationcode = implementationcode @ (match res.outputformat with
                                            D  : ( "res_h_resh" )
                                    DD : ( "res_h_resh, res_h_resm" )
                                    TD : ( "res_h_resh, res_h_resm, res_h_resl" ));
           implementationcode = implementationcode @ ");\n";

           implementationcode = implementationcode @ "}\n\n";

           write(implementationcode) >> parametrization.implementationFile;
                   result.okay = true;
           result.outputformat = res2.outputformat;
           result.functionname = parametrization.functionBasename;
           // TODO: add error bounds
        };
         };
      };

      return result;
};

procedure doWorkForTryImplementationThroughExpressionDecomposition(problemdef, parametrization) {
      var result, func;

      result = { .okay = false };

      func = problemdef.func;

      match (func) with
        g + h  : {
                /* Make sure that neither g nor h is a stupid constant */
                if ((degree(g) != 0) && (degree(h) != 0)) then {
                   result = doWorkForTryImplementationThroughExpressionDecompositionAddition(func, g, h, problemdef, parametrization);
                };
                 }
                g * h  : {
                result = doWorkForTryImplementationThroughExpressionDecompositionMultiplication(func, g, h, problemdef, parametrization);
                 }
                g ^ h  : {
                                /* Make sure that g is just a constant and h is neither a constant nor just x */
                if ((degree(g) == 0) && (!(degree(h) in [0;1]))) then {
                   result = doWorkForTryImplementationThroughExpressionDecompositionComposition(func, g^x, h, problemdef, parametrization);
                };
                         }
                g(h)   : {
                /* Make sure that h is neither a constant nor just x */
                if (!(degree(h) in [0;1])) then {
                   result = doWorkForTryImplementationThroughExpressionDecompositionComposition(func, g, h, problemdef, parametrization);
                };
                 }
                default: {
             };

      return result;
};

procedure tryImplementationThroughExpressionDecomposition(problemdef, parametrization) {
      var result, needArgumentReduction, res, performExpressionDecompositionLevel;

      result = { .okay = false };

      match ( { .problemdef = problemdef,
                    .parametrization = parametrization } ) with
                { .problemdef =      { .func = default,
                                       .dom = default,
                                       .target = default,
                                       .variableFormat = default },
                  .parametrization = { .maxDegree = default,
                                       .minWidth = default,
                                       .beta = default,
                           .implementationFile = default,
                                       .gappaFile = default,
                                       .gappaOutputFile = default,
                                       .gappaExecutable = default,
                       .functionBasename = default,
                       .tableIndexWidth = default,
                       .metaSplitMinWidth = default } } : {

                       /* Test if we may perform this type of argument
                          reduction
                       */
                       performExpressionDecompositionLevel = 0;
                       match (parametrization) with
                             { .performExpressionDecomposition = a } : { performExpressionDecompositionLevel = a; }
                         default : { };

                       if (performExpressionDecompositionLevel > 0) then {
                           /* Start with a test if the domain actually needs
                                              decomposition or argument reduction in order to stay below the maximum
                          polynomial degree
                           */
                           needArgumentReduction = true;
                           res = checkIfSufficientDegree(problemdef.func, problemdef.dom, parametrization.maxDegree, problemdef.target);

                                           if (res.okay) then {
                                           if (res.sufficientDegree) then needArgumentReduction = false;
                           } else {
                               needArgumentReduction = false;
                           };

                           if (needArgumentReduction) then {
                          result = doWorkForTryImplementationThroughExpressionDecomposition(problemdef, parametrization);
                           };
                         };
                     }
                default : { };

      return result;
};

procedure tryImplementationThroughExpressionDecomposition(problemdef, parametrization) {
      var result, needArgumentReduction, res, performExpressionDecompositionLevel;

      result = { .okay = false };

      match ( { .problemdef = problemdef,
                    .parametrization = parametrization } ) with
                { .problemdef =      { .func = default,
                                       .dom = default,
                                       .target = default,
                                       .variableFormat = default },
                  .parametrization = { .maxDegree = default,
                                       .minWidth = default,
                                       .beta = default,
                           .implementationFile = default,
                                       .gappaFile = default,
                                       .gappaOutputFile = default,
                                       .gappaExecutable = default,
                       .functionBasename = default,
                       .tableIndexWidth = default,
                       .metaSplitMinWidth = default } } : {

                       /* Test if we may perform this type of argument
                          reduction
                       */
                       performExpressionDecompositionLevel = 0;
                       match (parametrization) with
                             { .performExpressionDecomposition = a } : { performExpressionDecompositionLevel = a; }
                         default : { };

                       if (performExpressionDecompositionLevel > 0) then {
                           /* Start with a test if the domain actually needs
                                              decomposition or argument reduction in order to stay below the maximum
                          polynomial degree
                           */
                           needArgumentReduction = true;
                           res = checkIfSufficientDegree(problemdef.func, problemdef.dom, parametrization.maxDegree, problemdef.target);

                                           if (res.okay) then {
                                           if (res.sufficientDegree) then needArgumentReduction = false;
                           } else {
                               needArgumentReduction = false;
                           };

                           if (needArgumentReduction) then {
                          result = doWorkForTryImplementationThroughExpressionDecomposition(problemdef, parametrization);
                           };
                         };
                     }
                default : { };

      return result;
};

procedure tryDetectTrigonometric(func, dom) {
      var result;
      var ff, p, found;

      result = { .okay = false };

      found = false;
      match (func) with
        (sin(q)) : {
                ff = sin(x);
                p = q;
                found = true;
                   }
            (cos(q)) : {
                ff = cos(x);
                p = q;
                found = true;
               }
        (default) : { };

          if (found) then {
         if (degree(p) >= 1) then {
            result.func = ff;
        result.c = (2 * coeff(p, degree(p))) / pi;
        result.poly = horner(p / coeff(p, degree(p)));
        result.okay = true;
        result.q = horner(p);
         };
      };

      return result;
};

procedure solvePolynomialEquation(p, dom) {
      var res, n, oldPrec, a, b, c, sol;

      n = degree(p);
      if (n < 0) then {
         res = mydirtyfindzeros(p, dom);
      } else {
         if (n == 0) then {
            c = coeff(p, 0);
        if (c == 0) then {
          res = [| inf(dom), mid(dom), sup(dom) |];
        } else {
          res = [||];
        };
         } else {
           if (n == 1) then {
             c = coeff(p, 0);
         b = coeff(p, 1);
         if (-c/b in dom) then {
           res = [| -c/b |];
         } else {
           res = [||];
         };
           } else {
             if (n == 2) then {
            a = coeff(p, 2);
            b = coeff(p, 1);
            c = coeff(p, 0);
            if (b^2 - 4 * a * c >= 0) then {
               res = [||];
               for sol in [| (-b + sqrt(b^2 - 4 * a * c))/(2 * a), (-b + sqrt(b^2 - 4 * a * c))/(2 * a) |] do {
                   if (sol in dom) then {
                  res = sol .: res;
               };
               };
            } else {
               res = [||];
            };
         } else {
           oldPrec = prec;
           prec = 2 * prec!;
           res = mydirtyfindzeros(p, dom);
           prec = oldPrec!;
         };
           };
         };
      };

      return res;
};

procedure boundPolynomial(p, dom) {
      var res, cp, criticalPoints, Y, minVal, maxVal;

      criticalPoints = inf(dom) .: (sup(dom) .: (solvePolynomialEquation(diff(p), dom)));
      Y = evaluate(p, mid(dom));
      minVal = inf(Y);
      maxVal = sup(Y);
      for cp in criticalPoints do {
          Y = evaluate(p, cp);
          minVal = min(minVal, inf(Y));
          maxVal = max(maxVal, sup(Y));
      };
      res = [ minVal, maxVal ];

      return res;
};

procedure tryGenerateArgumentReductionTrigonometricDetermineAlphas(c, p, dom, kDom, variableFormat) {
      var result;
      var alpha1, alpha2, okay;
      var k;
      var a1, a2;
      var X, criticalX, rndX;

      result = { .okay = false };

      okay = true;
      alpha1 = 0;
      alpha2 = 0;
      k = floor(inf(kDom));
      while (okay && (k <= ceil(sup(kDom)))) do {
        if (k != 0) then {
           criticalX = solvePolynomialEquation(c * p - k, dom);
           for X in criticalX do {
               if (abs((c * p - k)(round(X, variableFormat, RN))) <= 1b-1076) then {
                   okay = false;
               } else {
                   for rndX in [| round(X, variableFormat, RD), round(X, variableFormat, RU),
                                  round(round(X, variableFormat, RD) - 1b-1076, variableFormat, RD), round(round(X, variableFormat, RU) + 1b-1076, variableFormat, RU) |] do {
                         a2 = -k / (c * p(rndX) - k);
                         a1 = 1.5 * a2;
                         alpha1 = max(alpha1, abs(a1));
                         alpha2 = max(alpha2, abs(a2));
                           };
               };
           };
        };
        k = k + 1;
      };

      if (okay) then {
         result.okay = true;
         result.alpha1 = alpha1;
         result.alpha2 = alpha2;
      };

      return result;
};

procedure testRealNonZeroConstant(X) {
      var res;

      if (X == 0) then {
         res = false;
      } else {
        if (!(X == X)) then {
           res = false;
        } else {
          if (abs(X) == infty) then {
             res = false;
          } else {
             res = true;
          };
        };
      };

      return res;
};

procedure tryGenerateArgumentReductionTrigonometricCodeForK(c, p, dom, variableFormat, baseName, implementationFile, parametrization) {
      var result;
      var q;
      var myproblemdef, myparametrization, res;
      var evalFuncName, outputFormat;
      var suffix;

      result = { .okay = false };

      q = horner(c * p);

      myproblemdef.func = q;
      myproblemdef.dom = dom;
      myproblemdef.target = 1b-16;
      myproblemdef.variableFormat = variableFormat;

      myparametrization = parametrization;
      myparametrization.maxDegree = min(degree(q), parametrization.maxDegree);
      myparametrization.functionBasename = baseName @ "_poly_q_for_k";
      suffix = "_poly_q_for_k";
      myparametrization.implementationFile = implementationFile @ suffix;
      myparametrization.gappaFile = parametrization.gappaFile @ suffix;
      myparametrization.gappaOutputFile = parametrization.gappaOutputFile @ suffix;

      res = tryImplementation(myproblemdef, myparametrization);

      if (res.okay) then {
         evalFuncName = res.functionname;
         outputFormat = res.outputformat;

         bashexecute("cat " @ myparametrization.implementationFile @ " >> " @ implementationFile);
         bashexecute("rm " @ myparametrization.implementationFile);

         write("\nvoid ", baseName, "_period_k(double *k, ") >> implementationFile;
         match (variableFormat) with
               D  : { write("double x") >> implementationFile; }
               DD : { write("double xh, double xl") >> implementationFile; }
           TD : { write("double xh, double xm, xl") >> implementationFile; };
             write(") {\n") >> implementationFile;
         write("    double t;\n") >> implementationFile;
         write("    double q;\n") >> implementationFile;
         match (outputFormat) with
               D  : { }
           DD : { write("    double qh, ql;\n") >> implementationFile; }
           TD : { write("    double qh, qm, ql;\n") >> implementationFile; };
         write("    ",evalFuncName,"(") >> implementationFile;
         match (outputFormat) with
               D  : { write("&q, ") >> implementationFile; }
           DD : { write("&qh, &ql, ") >> implementationFile; }
           TD : { write("&qh, &qm, &ql, ") >> implementationFile; };
         match (variableFormat) with
               D  : { write("x") >> implementationFile; }
           DD : { write("xh, xl") >> implementationFile; }
           TD : { write("xh, xm, xl") >> implementationFile; };
             write(");\n") >> implementationFile;
         match (outputFormat) with
               D  : { }
           DD : { write("    q = qh + ql;\n") >> implementationFile; }
           TD : { write("    q = qh + (qm + ql);\n") >> implementationFile; };
         write("    t = q + 6755399441055744.0;\n") >> implementationFile;
         write("    *k = t - 6755399441055744.0;\n") >> implementationFile;
         write("}\n\n") >> implementationFile;

         result.okay = true;
      };

      return result;
};

procedure tryGenerateArgumentReductionTrigonometricCodeForKPiHalf(dom, target, baseName, implementationFile) {
      var result;
      var okay, lenExpanPi;
      var w, expansionPi, expansionPiSum;
      var outputFormatNum, i, outputFormat;

      result = { .okay = false };

      okay = true;
      if (sup(abs(dom)) > 0) then {
        w = ceil(log2(sup(abs(dom))));
        expansionPi = [| round(-pi/2,53-w,RN) |];
        expansionPiSum = head(expansionPi);
        lenExpanPi = 1;
        while ((abs(expansionPiSum / (-pi/2) - 1) >= 3/8*target) && (lenExpanPi <= 4)) do {
              expansionPi = expansionPi :. (round(-pi/2 - expansionPiSum,53-w,RN));
          expansionPiSum = expansionPiSum + expansionPi[length(expansionPi)-1];
          lenExpanPi = lenExpanPi + 1;
        };
        if (!(abs(expansionPiSum / (-pi/2) - 1) < 3/8*target)) then {
           okay = false;
        };
      } else {
        okay = false;
      };
      if (okay) then {
         if (3/8*target < 1b-52) then {
           if (3/8*target < 1b-105) then {
             if (3/8*target < 1b-145) then {
            okay = false;
         } else {
                    outputFormatNum = 3;
         };
           } else {
             outputFormatNum = 2;
           };
         } else {
           outputFormatNum = 1;
         };
      };
      if (okay) then {
         if (lenExpanPi < outputFormatNum) then {
            for i from lenExpanPi + 1 to outputFormatNum do {
              expansionPi = expansionPi :. (round(-pi/2 - expansionPiSum,53-w,RN));
          expansionPiSum = expansionPiSum + expansionPi[length(expansionPi)-1];
        };
        lenExpanPi = outputFormatNum;
         };
         if (lenExpanPi > outputFormatNum + 1) then {
            okay = false;
         };
      };
      if (okay) then {
         outputFormat = (match (outputFormatNum) with
                           2 : (DD)
                   3 : (TD)
                   default : (D));
         for i from 0 to lenExpanPi - 1 do {
             write("#define ", baseName, "_pi_half_expan_", (i+1), " (", expansionPi[i], ")\n") >> implementationFile;
         };
         write("\nvoid ", baseName, "_k_pi_half(") >> implementationFile;
         match (outputFormat) with
               D  : { write("double *res_h, ") >> implementationFile; }
               DD : { write("double *res_h, double *res_m, ") >> implementationFile; }
               TD : { write("double *res_h, double *res_m, double *res_l, ") >> implementationFile; };
             write("double k) {\n") >> implementationFile;
         for i from 0 to lenExpanPi - 1 do {
             write("    double t_", (i+1), ";\n") >> implementationFile;
         };
         if (lenExpanPi != outputFormatNum) then {
            match (outputFormat) with
              D  : { }
              DD : { write("    double t_4, t_5, t_6;\n") >> implementationFile; }
              TD : { write("    double t_5, t_6, t_7;\n") >> implementationFile; };
         };
         write("\n") >> implementationFile;
         for i from 0 to lenExpanPi - 1 do {
             write("    t_", (i+1), " = k * ", baseName, "_pi_half_expan_", (i+1), ";\n") >> implementationFile;
         };
         if (lenExpanPi == outputFormatNum) then {
            match (outputFormat) with
              D  : { write("    *res_h = t_1;\n") >> implementationFile; }
              DD : { write("    Add12(*res_h, *res_m, t_1, t_2);\n") >> implementationFile; }
              TD : { write("    Renormalize3(res_h, res_m, res_l, t_1, t_2, t_3);\n") >> implementationFile; };
         } else {
            match (outputFormat) with
              D  : { write("    *res_h = t_1 + t_2;\n") >> implementationFile; }
              DD : { write("    Renormalize3(&t_4, &t_5, &t_6, t_1, t_2, t_3);\n") >> implementationFile;
                     write("    Add12(*res_h, *res_m, t_4, t_5);\n") >> implementationFile;
                   }
              TD : { write("    Renormalize3(&t_5, &t_6, &t_7, t_2, t_3, t_4);\n") >> implementationFile;
                     write("    Renormalize3(res_h, res_m, res_l, t_1, t_5, t_6);\n") >> implementationFile;
                   };
         };
             write("}\n\n") >> implementationFile;
         result.outputFormat = outputFormat;
         result.okay = true;
      };

      return result;
};

procedure tryGenerateArgumentReductionTrigonometricCodeForQ(q, dom, variableFormat, target, baseName, implementationFile, parametrization) {
      var result;
      var myproblemdef, myparametrization, res;
      var suffix;

          result = { .okay = false };

          if (horner(q - x) == 0) then {
             write("void ", baseName, "_poly_q(") >> implementationFile;
             match (variableFormat) with
                   D  : { write("double *res_h, double x") >> implementationFile; }
                   DD : { write("double *res_h, double *res_m, double xh, double xm") >> implementationFile; }
                   TD : { write("double *res_h, double *res_m, double *res_l, double xh, double xm, double xl") >> implementationFile; };
             write(") {\n") >> implementationFile;
             match (variableFormat) with
                   D  : { write("    *res_h = x;\n") >> implementationFile; }
                   DD : { write("    *res_h = xh; *res_m = xm;\n") >> implementationFile; }
                   TD : { write("    *res_h = xh; *res_m = xm; *res_l = xl;\n") >> implementationFile; };
             write("}\n\n") >> implementationFile;
             result.okay = true;
             result.outputFormat = variableFormat;
         result.functionName = baseName @ "_poly_q";
          } else {

             myproblemdef.func = horner(q);
             myproblemdef.dom = dom;
             myproblemdef.target = target;
             myproblemdef.variableFormat = variableFormat;

             myparametrization = parametrization;
             myparametrization.maxDegree = min(degree(q), parametrization.maxDegree);
             myparametrization.functionBasename = baseName @ "_poly_q";
         suffix = "_poly_q";
         myparametrization.implementationFile = implementationFile @ suffix;
         myparametrization.gappaFile = parametrization.gappaFile @ suffix;
         myparametrization.gappaOutputFile = parametrization.gappaOutputFile @ suffix;

             res = tryImplementation(myproblemdef, myparametrization);

         if (res.okay) then {
            bashexecute("cat " @ myparametrization.implementationFile @ " >> " @ implementationFile);
            bashexecute("rm " @ myparametrization.implementationFile);

            result.functionName = res.functionname;
            result.outputFormat = res.outputformat;
        result.okay = true;
             };
      };

      return result;
};

procedure tryGenerateArgumentReductionTrigonometricCodeForAddition(operandFormat1, operandFormat2, target, baseName, implementationFile) {
      var result;
      var outputFormat;
      var declarations, code;
      var varNum, buckets, opNum1, opNum2, numBuckets;
      var okay, i, b, o1, o2;
      var currh, currm, currl;

      result = { .okay = false };

      okay = true;
      if (target < 1b-52) then {
        if (target < 1b-104) then {
           if (target < 1b-150) then {
              okay = false;
           } else {
              outputFormat = TD;
           };
        } else {
           outputFormat = DD;
        };
      } else {
        outputFormat = D;
      };
      if (okay) then {
         declarations = "";
         code = "";
         varNum = 0;
         opNum1 = (match (operandFormat1) with
                         D  : (1)
                 DD : (2)
                 TD : (3));
             opNum2 = (match (operandFormat2) with
                             D  : (1)
                             DD : (2)
                             TD : (3));
         numBuckets = max(opNum1, opNum2) + 1;
         buckets = [||];
         for i from 0 to numBuckets - 1 do buckets = [||] .: buckets;
             write("void ", baseName, "_reduc_add(") >> implementationFile;
         match (outputFormat) with
               D  : { write("double *res_h, ") >> implementationFile; }
               DD : { write("double *res_h, double *res_m, ") >> implementationFile; }
               TD : { write("double *res_h, double *res_m, double *res_l, ") >> implementationFile; };
         match (operandFormat1) with
               D  : { write("double ah, ") >> implementationFile; }
               DD : { write("double ah, double am, ") >> implementationFile; }
               TD : { write("double ah, double am, double al, ") >> implementationFile; };
         match (operandFormat2) with
               D  : { write("double bh") >> implementationFile; }
               DD : { write("double bh, double bm") >> implementationFile; }
               TD : { write("double bh, double bm, double bl") >> implementationFile; };
             write(") {\n") >> implementationFile;
         match (operandFormat1) with
               D  : { buckets[0] = buckets[0] :. "ah"; }
               DD : { buckets[0] = buckets[0] :. "ah"; buckets[1] = buckets[1] :. "am"; }
               TD : { buckets[0] = buckets[0] :. "ah"; buckets[1] = buckets[1] :. "am"; buckets[2] = buckets[2] :. "al"; };
         match (operandFormat2) with
               D  : { buckets[0] = buckets[0] :. "bh"; }
               DD : { buckets[0] = buckets[0] :. "bh"; buckets[1] = buckets[1] :. "bm"; }
               TD : { buckets[0] = buckets[0] :. "bh"; buckets[1] = buckets[1] :. "bm"; buckets[2] = buckets[2] :. "bl"; };
         for i from 0 to numBuckets - 1 do {
             b = buckets[i];
         while (length(b) > 1) do {
               o1 = head(b); b = tail(b);
               o2 = head(b); b = tail(b);
               if (i == numBuckets - 1) then {
                  varNum = varNum + 1;
              code = code @ "    t_" @ varNum @ " = " @ o1 @ " + " @ o2 @ ";\n";
              b = b :. ("t_" @ varNum);
               } else {
                  varNum = varNum + 2;
              code = code @ "    Add12Cond(t_" @ (varNum - 1) @ ", t_" @ varNum @ ", " @ o1 @ ", " @ o2 @ ");\n";
              b = b :. ("t_" @ (varNum - 1));
              buckets[i + 1] = buckets[i + 1] :. ("t_" @ varNum);
               };
         };
         buckets[i] = b;
         };
         while (buckets[numBuckets - 1] == [||]) do {
               numBuckets = numBuckets - 1;
         };
         match (outputFormat) with
               D  : {
                currh = head(buckets[numBuckets - 1]);
                for i from numBuckets - 2 to 0 by -1 do {
                    varNum = varNum + 1;
                    code = code @ "    t_" @ varNum @ " = " @ head(buckets[i]) @ " + " @ currh @ ";\n";
                    currh = "t_" @ varNum;
                };
                code = code @ "    *res_h = " @ currh @ ";\n";
                }
               DD : {
                currh = head(buckets[numBuckets - 1]);
                varNum = varNum + 1;
                currm = "t_" @ varNum;
                code = code @ "    t_" @ varNum @ " = 0.0;\n";
                for i from numBuckets - 2 to 0 by -1 do {
                    varNum = varNum + 2;
                    code = code @ "    Add122(&t_" @ (varNum - 1) @ ", &t_" @ varNum @ ", " @ head(buckets[i]) @ ", " @ currh @ ", " @ currm @ ");\n";
                    currh = "t_" @ (varNum - 1);
                    currm = "t_" @ varNum;
                };
                code = code @ "    *res_h = " @ currh @ ";\n";
                code = code @ "    *res_m = " @ currm @ ";\n";
                }
               TD : {
                currh = head(buckets[numBuckets - 1]);
                varNum = varNum + 1;
                currm = "t_" @ varNum;
                currl = "t_" @ varNum;
                code = code @ "    t_" @ varNum @ " = 0.0;\n";
                for i from numBuckets - 2 to 0 by -1 do {
                    varNum = varNum + 3;
                    code = code @ "    Add133(&t_" @ (varNum - 2) @ ", &t_" @ (varNum - 1) @ ", &t_" @ varNum @ ", " @ head(buckets[i]) @ ", "
                                           @ ", " @ currh @ ", " @ currm @ ", " @ currl @ ");\n";
                    currh = "t_" @ (varNum - 2);
                    currm = "t_" @ (varNum - 1);
                    currl = "t_" @ varNum;
                };
                code = code @ "    Renormalize3(res_h, res_m, res_l, " @ currh @ ", " @ currm @ ", " @ currl @ ");\n";
                };
         for i from 1 to varNum do {
             declarations = declarations @ "    double t_" @ i @ ";\n";
         };
         write(declarations,"\n") >> implementationFile;
         write(code,"\n") >> implementationFile;
         write("}\n\n") >> implementationFile;
         result.okay = true;
         result.outputFormat = outputFormat;
      };

      return result;
};

procedure tryGenerateArgumentReductionTrigonometric(c, p, Q, dom, variableFormat, target, implementationFile, functionBaseName, parametrization) {
      var result;
      var cPDom, kDom;
      var resAlphas;
      var alpha1, alpha2;
      var target1, target2, target3;
      var q;
      var resCodeK, resCodeKPiHalf;
      var resCodeQ, resCodeAddition;

      result = { .okay = false };

      /* Let k defined as

             k = nearestint(c * p(x))

         The reduced argument r will be

         r(x) = pi/2 * (c * p(x) - k(x))

         We start by determining the range of possible values
         for k, by bounding c * p(x) over dom and then deducing
         the range of k.

      */
      cPDom = boundPolynomial(c * p, dom);
      kDom = [ nearestint(inf(cPDom)), nearestint(sup(cPDom)) ];

      /* This argument reduction implementer can work only
         if k stays bounded in magnitude by 2^12 and if there
         are less than 2^11 possible values of k.
      */
      if ((abs(inf(kDom)) <= 2^12) && (abs(sup(kDom)) <= 2^12) &&
          (abs(sup(kDom) - inf(kDom)) <= 2^11)) then {
          /* We need to determine the factors alpha1 and alpha2
             the two relative errors eps1 and eps2 on the evaluation
         of pi/2 * c * p(x) and k * pi/2 will be amplified by
         in the cancellation

         pi/2 * c * p(x) - k * pi/2

         These two amplification factors are given by

         alpha1 = (c * p)/(c * p - k)

         and

         alpha2 = -k / (c * p - k)

         The determination of the two factors will be performed
         by a sub-routine.

              */
          resAlphas = tryGenerateArgumentReductionTrigonometricDetermineAlphas(c, p, dom, kDom, variableFormat);

          if (resAlphas.okay) then {
             alpha1 = resAlphas.alpha1;
         alpha2 = resAlphas.alpha2;

         /* Now determine three new target errors:

            target1 = 1/4 * 1/alpha1 * target   for the error evaluating pi/2 * c * p(x),

            target2 = 1/4 * 1/alpha2 * target   for the error evaluating pi/2 * k and

            target3 = 1/4 * target              for the error evaluating the difference.

         */
         target1 = 1/4 * 1/alpha1 * target;
         target2 = 1/4 * 1/alpha2 * target;
         target3 = 1/4 * target;

         /* Check if all quantities are non-zero real numbers */
         if (testRealNonZeroConstant(target1) &&
             testRealNonZeroConstant(target2) &&
             testRealNonZeroConstant(target3)) then {
            /* Form the polynomial q = Q = pi/2 * c * p */
            q = horner(Q);
            if (horner(p - q) == 0) then {
               q = p;
            };

            /* Try to generate the code that computes k as a double */
            resCodeK = tryGenerateArgumentReductionTrigonometricCodeForK(c, p, dom, variableFormat, functionBaseName, implementationFile, parametrization);

            if (resCodeK.okay) then {
               /* Try to generate the code that computes -k * pi/2 with accuracy target2 */
               resCodeKPiHalf = tryGenerateArgumentReductionTrigonometricCodeForKPiHalf(kDom, target2, functionBaseName, implementationFile);

               if (resCodeKPiHalf.okay) then {
                  /* Try to generate the code that computes q = pi/2 * c * p with accuracy target1 */
                  resCodeQ = tryGenerateArgumentReductionTrigonometricCodeForQ(q, dom, variableFormat, target1, functionBaseName, implementationFile, parametrization);

              if (resCodeQ.okay) then {
                 /* Try to generate the code for the addition of q and -k * pi/2 with accuracy target3 */
                 resCodeAddition = tryGenerateArgumentReductionTrigonometricCodeForAddition(resCodeQ.outputFormat, resCodeKPiHalf.outputFormat, target3, functionBaseName, implementationFile);

                 if (resCodeAddition.okay) then {
                    /* Generate the wrapper function */

                write("void ", functionBaseName, "_arg_red(int *K, ") >> implementationFile;
                match (resCodeAddition.outputFormat) with
                      D  : { write("double *res_h, ") >> implementationFile; }
                      DD : { write("double *res_h, double *res_m, ") >> implementationFile; }
                      TD : { write("double *res_h, double *res_m, double *res_l, ") >> implementationFile; };
                match (variableFormat) with
                      D  : { write("double xh") >> implementationFile; }
                      DD : { write("double xh, double xm") >> implementationFile; }
                                      TD : { write("double xh, double xm, double xl") >> implementationFile; };
                write(") {\n") >> implementationFile;
                write("    double k;\n") >> implementationFile;
                match (resCodeQ.outputFormat) with
                      D  : { write("    double qh;\n") >> implementationFile; }
                      DD : { write("    double qh, qm;\n") >> implementationFile; }
                      TD : { write("    double qh, qm, ql;\n") >> implementationFile; };
                match (resCodeKPiHalf.outputFormat) with
                      D  : { write("    double kpih;\n") >> implementationFile; }
                      DD : { write("    double kpih, kpim;\n") >> implementationFile; }
                      TD : { write("    double kpih, kpim, kpil;\n") >> implementationFile; };
                write("    ", functionBaseName, "_period_k(&k, ") >> implementationFile;
                match (variableFormat) with
                      D  : { write("xh") >> implementationFile; }
                      DD : { write("xh, xm") >> implementationFile; }
                      TD : { write("xh, xm, xl") >> implementationFile; };
                write(");\n") >> implementationFile;
                write("    *K = (int) k;\n") >> implementationFile;
                write("    ", resCodeQ.functionName, "(") >> implementationFile;
                match (resCodeQ.outputFormat) with
                      D  : { write("&qh, ") >> implementationFile; }
                      DD : { write("&qh, &qm, ") >> implementationFile; }
                      TD : { write("&qh, &qm, &ql, ") >> implementationFile; };
                match (variableFormat) with
                      D  : { write("xh") >> implementationFile; }
                      DD : { write("xh, xm") >> implementationFile; }
                      TD : { write("xh, xm, xl") >> implementationFile; };
                write(");\n") >> implementationFile;
                write("    ", functionBaseName, "_k_pi_half(") >> implementationFile;
                match (resCodeKPiHalf.outputFormat) with
                      D  : { write("&kiph, ") >> implementationFile; }
                      DD : { write("&kpih, &kpim, ") >> implementationFile; }
                      TD : { write("&kpih, &kpim, &kpil, ") >> implementationFile; };
                write("k);\n") >> implementationFile;
                write("    ", functionBaseName, "_reduc_add(") >> implementationFile;
                match (resCodeAddition.outputFormat) with
                      D  : { write("res_h, ") >> implementationFile; }
                      DD : { write("res_h, res_m, ") >> implementationFile; }
                      TD : { write("res_h, res_m, res_l, ") >> implementationFile; };
                match (resCodeQ.outputFormat) with
                      D  : { write("qh, ") >> implementationFile; }
                      DD : { write("qh, qm, ") >> implementationFile; }
                      TD : { write("qh, qm, ql, ") >> implementationFile; };
                match (resCodeKPiHalf.outputFormat) with
                      D  : { write("kiph") >> implementationFile; }
                      DD : { write("kpih, kpim") >> implementationFile; }
                      TD : { write("kpih, kpim, kpil") >> implementationFile; };
                write(");\n") >> implementationFile;
                write("}\n\n") >> implementationFile;
                result.okay = true;
                result.outputFormat = resCodeAddition.outputFormat;
                result.functionName = functionBaseName @ "_arg_red";
                 };
              };
               };
            };
         };
          };
      };

      return result;
};

procedure doWorkForTryImplementationTrigonometric(problemdef, parametrization) {
      var result, res, func, c, p, q, dom, variableFormat;
      var resArgRed;
      var rDom;
      var resSin, resCos;
      var myproblemdef, myparametrization, suffix;
      var outputFormat;
      var resEven, resOdd;
      var oP;

      result = { .okay = false };

      dom = problemdef.dom;
      variableFormat = problemdef.variableFormat;

          res = tryDetectTrigonometric(problemdef.func, dom);

      if (res.okay) then {
         /* Here, we know that the function func(x) can be written

            func(x) = f(pi/2 * c * p(x))

            where f is either sin or cos, c a constant and p is a
            non-constant unitary polynomial.

        q is equal to pi/2 * c * p

         */
         func = res.func;
         p = res.poly;
         c = res.c;
         q = res.q;

         /* Try to generate code for the argument reduction function

            r(x) = pi/2 * (c * p(x) - k)    with  k = nearestint(c * p(x))

        The argument reduction must be precise to 3/16 * eps

        where eps is the target error.

             */
         resArgRed = tryGenerateArgumentReductionTrigonometric(c, p, q, dom, variableFormat, 3/16 * (problemdef.target),
                                                               parametrization.implementationFile,
                                   parametrization.functionBasename @ "_trigo_arg_red", parametrization);

         if (resArgRed.okay) then {
            /* We could generate code for the argument reduction

           Now try to generate sin(r) and cos(r) with a target error of 3/8 * eps
           and r being represented in the format produced by the argument reduction.

           The mathematically exact domain for r is [-pi/4;pi/4]. As the actual r
           is computed with an at least 16-bit accurate approximation to c * p;
           which means that the actual domain is bounded by [-pi/4*(1+1b-15);pi/4*(1+1b-15)].

        */

        oP = prec;
        prec = max(300, prec)!;
        rDom = [-pi/4*(1+1b-15);pi/4*(1+1b-15)];
        prec = oP!;

        myproblemdef.func = (match (func) with
                                   sin(x) : (sin(x))
                       cos(x) : (-sin(x)));
                myproblemdef.dom = rDom;
                myproblemdef.target = 3/8 * (problemdef.target);
                myproblemdef.variableFormat = resArgRed.outputFormat;

                myparametrization = parametrization;
                myparametrization.functionBasename = parametrization.functionBasename @ "_sin_red";
            suffix = "_sin_red";
            myparametrization.implementationFile = parametrization.implementationFile @ suffix;
            myparametrization.gappaFile = parametrization.gappaFile @ suffix;
            myparametrization.gappaOutputFile = parametrization.gappaOutputFile @ suffix;
        myparametrization.doNotPerformTrigonometric = true;

                resSin = tryImplementation(myproblemdef, myparametrization);

            if (resSin.okay) then {
               bashexecute("cat " @ myparametrization.implementationFile @ " >> " @ parametrization.implementationFile);
               bashexecute("rm " @ myparametrization.implementationFile);

           myproblemdef.func = cos(x);
                   myproblemdef.dom = rDom;
                   myproblemdef.target = 3/8 * (problemdef.target);
                   myproblemdef.variableFormat = resArgRed.outputFormat;

                   myparametrization = parametrization;
                   myparametrization.functionBasename = parametrization.functionBasename @ "_cos_red";
               suffix = "_cos_red";
               myparametrization.implementationFile = parametrization.implementationFile @ suffix;
               myparametrization.gappaFile = parametrization.gappaFile @ suffix;
               myparametrization.gappaOutputFile = parametrization.gappaOutputFile @ suffix;
           myparametrization.doNotPerformTrigonometric = true;

                   resCos = tryImplementation(myproblemdef, myparametrization);

               if (resCos.okay) then {
                  bashexecute("cat " @ myparametrization.implementationFile @ " >> " @ parametrization.implementationFile);
                  bashexecute("rm " @ myparametrization.implementationFile);

              /* Generate the actual function */
              outputFormat = expansionLengthToFormat(max(formatToExpansionLength(resSin.outputformat),
                                                         formatToExpansionLength(resCos.outputformat)));

              write("void ", parametrization.functionBasename, "(") >> parametrization.implementationFile;
              match (outputFormat) with
                    D  : { write("double *res_h, ") >> parametrization.implementationFile; }
                DD : { write("double *res_h, double *res_m, ") >> parametrization.implementationFile; }
                    TD : { write("double *res_h, double *res_m, double *res_l, ") >> parametrization.implementationFile; };
              match (variableFormat) with
                    D  : { write("double xh") >> parametrization.implementationFile; }
                    DD : { write("double xh, double xm") >> parametrization.implementationFile; }
                            TD : { write("double xh, double xm, double xl") >> parametrization.implementationFile; };
              write(") {\n") >> parametrization.implementationFile;
              write("    int k;\n") >> parametrization.implementationFile;
              match (resArgRed.outputFormat) with
                    D  : { write("    double rh;\n") >> parametrization.implementationFile; }
                    DD : { write("    double rh, rm;\n") >> parametrization.implementationFile; }
                    TD  : { write("    double rh, rm, rl;\n") >> parametrization.implementationFile; };
              write("    double s;\n") >> parametrization.implementationFile;
              match (outputFormat) with
                    D  : { write("    double th;\n    th = 0.0;\n") >> parametrization.implementationFile; }
                    DD : { write("    double th, tm;\n    th = 0.0; tm = 0.0;\n") >> parametrization.implementationFile; }
                    TD : { write("    double th, tm, tl;\n    th = 0.0; tm = 0.0; tl = 0.0;\n") >> parametrization.implementationFile; };
                  write("    ", resArgRed.functionName,"(&k, ") >> parametrization.implementationFile;
              match (resArgRed.outputFormat) with
                    D  : { write("&rh, ") >> parametrization.implementationFile; }
                    DD : { write("&rh, &rm, ") >> parametrization.implementationFile; }
                    TD : { write("&rh, &rm, &rl, ") >> parametrization.implementationFile; };
              match (variableFormat) with
                    D  : { write("xh") >> parametrization.implementationFile; }
                    DD : { write("xh, xm") >> parametrization.implementationFile; }
                            TD : { write("xh, xm, xl") >> parametrization.implementationFile; };
              write(");\n") >> parametrization.implementationFile;
              resEven = (match (func) with
                              sin(x) : (resSin)
                      cos(x) : (resCos));
              resOdd = (match (func) with
                              sin(x) : (resCos)
                      cos(x) : (resSin));
              write("    if (k & 1) {\n") >> parametrization.implementationFile;
              write("        ", resOdd.functionname, "(") >> parametrization.implementationFile;
              match (resOdd.outputformat) with
                    D  : { write("&th, ") >> parametrization.implementationFile; }
                DD : { write("&th, &tm, ") >> parametrization.implementationFile; }
                TD : { write("&th, &tm, &tl, ") >> parametrization.implementationFile; };
              match (resArgRed.outputFormat) with
                    D  : { write("rh") >> parametrization.implementationFile; }
                    DD : { write("rh, rm") >> parametrization.implementationFile; }
                    TD : { write("rh, rm, rl") >> parametrization.implementationFile; };
              write(");\n") >> parametrization.implementationFile;
              write("    } else {\n") >> parametrization.implementationFile;
              write("        ", resEven.functionname, "(") >> parametrization.implementationFile;
              match (resEven.outputformat) with
                    D  : { write("&th, ") >> parametrization.implementationFile; }
                DD : { write("&th, &tm, ") >> parametrization.implementationFile; }
                TD : { write("&th, &tm, &tl, ") >> parametrization.implementationFile; };
              match (resArgRed.outputFormat) with
                    D  : { write("rh") >> parametrization.implementationFile; }
                    DD : { write("rh, rm") >> parametrization.implementationFile; }
                    TD : { write("rh, rm, rl") >> parametrization.implementationFile; };
              write(");\n") >> parametrization.implementationFile;
              write("    }\n") >> parametrization.implementationFile;
              write("    if (k & 2) {\n") >> parametrization.implementationFile;
              write("        s = -1.0;\n") >> parametrization.implementationFile;
              write("    } else {\n") >> parametrization.implementationFile;
              write("        s =  1.0;\n") >> parametrization.implementationFile;
              write("    }\n") >> parametrization.implementationFile;
              match (outputFormat) with
                    D  : { write("    *res_h = s * th;\n") >> parametrization.implementationFile; }
                    DD : { write("    *res_h = s * th; *res_m = s * tm;\n") >> parametrization.implementationFile; }
                    TD : { write("    *res_h = s * th; *res_m = s * tm; *res_l = s * tl;\n") >> parametrization.implementationFile; };            
              write("}\n\n") >> parametrization.implementationFile;
              result.okay = true;
              result.outputformat = outputFormat;
              result.functionname = parametrization.functionBasename;
              result.implerr = 3/8 * problemdef.target;
              result.approxerr = (5/8 * problemdef.target) / (1 + (3/8 * problemdef.target));
                   };
                };
         };
      };

      return result;
};

procedure tryImplementationTrigonometric(problemdef, parametrization) {
      var result, needArgumentReduction, res, doNotPerformTrignometric;

      result = { .okay = false };

      match ( { .problemdef = problemdef,
                    .parametrization = parametrization } ) with
                { .problemdef =      { .func = default,
                                       .dom = default,
                                       .target = default,
                                       .variableFormat = default },
                  .parametrization = { .maxDegree = default,
                                       .minWidth = default,
                                       .beta = default,
                           .implementationFile = default,
                                       .gappaFile = default,
                                       .gappaOutputFile = default,
                                       .gappaExecutable = default,
                       .functionBasename = default,
                       .tableIndexWidth = default,
                       .metaSplitMinWidth = default } } : {

                       /* Test if we may perform this type of implementation */
                       doNotPerformTrignometric = false;
                       match (parametrization) with
                             { .doNotPerformTrigonometric = true } : { doNotPerformTrignometric = true; }
                         default : { };

                       if (!doNotPerformTrignometric) then {
                           /* Start with a test if the domain actually needs
                                              argument reduction in order to stay below the maximum
                          polynomial degree
                           */
                           needArgumentReduction = true;
                           res = checkIfSufficientDegree(problemdef.func, problemdef.dom, parametrization.maxDegree, problemdef.target);

                                           if (res.okay) then {
                                           if (res.sufficientDegree) then needArgumentReduction = false;
                           } else {
                               needArgumentReduction = false;
                           };

                           if (needArgumentReduction) then {
                          result = doWorkForTryImplementationTrigonometric(problemdef, parametrization);
                           };
                         };
                     }
                default : { };

      return result;
};

procedure tryImplementation(problemdef, parametrization) {
      var result, res, tryImplementationInstance, tryImplementationChoices;
      var okay, i;
      var needArgumentReduction, argumentAlreadyReduced;
      var showMethodName;

      showMethodName = true;

      result = { .okay = false };

      write("Trying to implement ", problemdef.func, " on ", problemdef.dom, "\n");

      needArgumentReduction = true;
      res = checkIfSufficientDegree(problemdef.func, problemdef.dom, parametrization.maxDegree, problemdef.target);

          if (res.okay) then {
          if (res.sufficientDegree) then needArgumentReduction = false;
      } else {
          needArgumentReduction = true;
      };

      argumentAlreadyReduced = false;
      match (parametrization) with
        { .argumentReduced = true } : { argumentAlreadyReduced = true; }
                default : { };

      if (needArgumentReduction) then {
           if (argumentAlreadyReduced) then {
               tryImplementationChoices = [| { .method = tryImplementationThroughExpressionDecomposition, .name = "tryImplementationThroughExpressionDecomposition" },
                                                 { .method = tryImplementationConstant, .name = "tryImplementationConstant" },
                         { .method = tryImplementationTrigonometric, .name = "tryImplementationTrigonometric" },
                                             { .method = tryImplementationThroughArgumentReductionPowering, .name = "tryImplementationThroughArgumentReductionPowering" },
                                     { .method = tryImplementationThroughArgumentReductionLogarithm, .name = "tryImplementationThroughArgumentReductionLogarithm" },
                                             { .method = tryImplementationThroughArgumentReductionExponential, .name = "tryImplementationThroughArgumentReductionExponential" },
                             { .method = tryImplementationThroughArgumentReductionPeriodic, .name = "tryImplementationThroughArgumentReductionPeriodic" },
                                                 { .method = tryImplementationThroughArgumentReductionWithParamountBehavior, .name = "tryImplementationThroughArgumentReductionWithParamountBehavior" },
                             { .method = tryImplementationThroughSquaring, .name = "tryImplementationThroughSquaring" },
                                                 { .method = tryImplementationThroughDomainSplitting, .name = "tryImplementationThroughDomainSplitting" },
                                                 { .method = tryImplementationThroughSymmetryDetectionAroundZero, .name = "tryImplementationThroughSymmetryDetectionAroundZero" },
                             { .method = tryImplementationThroughMetaSplitting, .name = "tryImplementationThroughMetaSplitting" } |];
           } else {
               tryImplementationChoices = [| { .method = tryImplementationThroughExpressionDecomposition, .name = "tryImplementationThroughExpressionDecomposition" },
                                                 { .method = tryImplementationConstant, .name = "tryImplementationConstant" },
                         { .method = tryImplementationTrigonometric, .name = "tryImplementationTrigonometric" },
                                             { .method = tryImplementationThroughArgumentReductionPowering, .name = "tryImplementationThroughArgumentReductionPowering" },
                                     { .method = tryImplementationThroughArgumentReductionLogarithm, .name = "tryImplementationThroughArgumentReductionLogarithm" },
                                             { .method = tryImplementationThroughArgumentReductionExponential, .name = "tryImplementationThroughArgumentReductionExponential" },
                             { .method = tryImplementationThroughArgumentReductionPeriodic, .name = "tryImplementationThroughArgumentReductionPeriodic" },
                                                 { .method = tryImplementationThroughArgumentReductionWithParamountBehavior, .name = "tryImplementationThroughArgumentReductionWithParamountBehavior" },
                             { .method = tryImplementationThroughSquaring, .name = "tryImplementationThroughSquaring" },
                                                 { .method = tryImplementationThroughSymmetryDetectionAroundZero, .name = "tryImplementationThroughSymmetryDetectionAroundZero" },
                                                 { .method = tryImplementationThroughDomainSplitting, .name = "tryImplementationThroughDomainSplitting" },
                             { .method = tryImplementationThroughMetaSplitting, .name = "tryImplementationThroughMetaSplitting" } |];
               };
      } else {
           tryImplementationChoices = [| { .method = tryImplementationThroughDomainSplitting, .name = "tryImplementationThroughDomainSplitting" },
                                             { .method = tryImplementationThroughExpressionDecomposition, .name = "tryImplementationThroughExpressionDecomposition" },
                                             { .method = tryImplementationConstant, .name = "tryImplementationConstant" },
                         { .method = tryImplementationTrigonometric, .name = "tryImplementationTrigonometric" },
                                         { .method = tryImplementationThroughArgumentReductionPowering, .name = "tryImplementationThroughArgumentReductionPowering" },
                             { .method = tryImplementationThroughArgumentReductionLogarithm, .name = "tryImplementationThroughArgumentReductionLogarithm" },
                                         { .method = tryImplementationThroughArgumentReductionExponential, .name = "tryImplementationThroughArgumentReductionExponential" },
                         { .method = tryImplementationThroughArgumentReductionPeriodic, .name = "tryImplementationThroughArgumentReductionPeriodic" },
                                             { .method = tryImplementationThroughArgumentReductionWithParamountBehavior, .name = "tryImplementationThroughArgumentReductionWithParamountBehavior" },
                         { .method = tryImplementationThroughSquaring, .name = "tryImplementationThroughSquaring" },
                                             { .method = tryImplementationThroughSymmetryDetectionAroundZero, .name = "tryImplementationThroughSymmetryDetectionAroundZero" },
                         { .method = tryImplementationThroughMetaSplitting, .name = "tryImplementationThroughMetaSplitting" } |];
          };

      okay = false; i = 0;
      while ((!okay) && (tryImplementationChoices != [||])) do {
              tryImplementationInstance = head(tryImplementationChoices);
          tryImplementationChoices = tail(tryImplementationChoices);


          if (showMethodName) then "Starting to try out implementation method ", tryImplementationInstance.name, " on function ", problemdef.func, " and domain ", problemdef.dom;
              res = tryImplementationInstance.method(problemdef, parametrization);

          if (res.okay) then {
             if (showMethodName) then "Successfully returning from implementation method ", tryImplementationInstance.name;
             result = res;
             okay = true;
          } else {
                     if (showMethodName) then "Unsuccessfully returning from implementation method ", tryImplementationInstance.name;
          };
      };

      return result;
};

procedure initializeParametrization(param, problemdef) {
      var myparam;
      var func, funcPrime, funcSecond;
      var oldPrec, oldPoints;
      var X, muell;

      myparam = param;
      myparam.originalProblemDefinition = problemdef;
      func = problemdef.func;
      dom = problemdef.dom;
      funcPrime = diff(func);
      funcSecond = diff(funcPrime);
      oldPrec = prec;
      oldPoints = points!;
      prec = min(400, 3 * prec + 50)!;
      for X in [| inf(dom), mid(dom), sup(dom) |] do {
          muell := funcSecond(X);
          muell := funcPrime(X);
          muell := func(X);
      };
      if (0 in dom) then {
         prec = min(2048, 4 * prec + 500)!;
         muell := funcSecond(0);
         muell := funcPrime(0);
         muell := func(0);
      };
      prec = min(350, 3 * prec)!;
      points = 50!;
      write("Computing an enclosure of the function's image\n");
      myparam.estimatedRangeFunc = dirtyEvaluateImageImproved(func,dom);
      write("... done with the function's image\n");
      write("Computing an enclosure of the image of the derivative\n");
      myparam.estimatedRangeFuncPrime = dirtyEvaluateImageImproved(funcPrime,dom);
      write("... done with the image of the derivative\n");
      write("Computing an enclosure of the image of the second derivative\n");
      myparam.estimatedRangeFuncSecond = dirtyEvaluateImageImproved(funcSecond,dom);
      write("... done with the image of the second derivative\n");
      write("Computing approximations to the function's zeros\n");
      if ((0 in dom) && (inf(dom) != 0) && (sup(dom) != 0)) then {
        myparam.estimatedZerosFunc = (mydirtyfindzeros(func,[inf(dom);-1b-200])) @ (mydirtyfindzeros(func,[1b-200;sup(dom)]));
        if (0 in evaluate(func, [0])) then {
           myparam.estimatedZerosFunc = 0 .: (myparam.estimatedZerosFunc);
        };
      } else {
        myparam.estimatedZerosFunc = mydirtyfindzeros(func,dom);
      };
      write("... done with the function's zeros\n");

      prec = oldPrec!;
      points = oldPoints!;

      return myparam;
};

procedure testImplementationDoit(implementedFunc, problemdef, parametrization, variableFormat, outputFormat, numberPoints, doPlotFunc, doPlotError) {
      var res;
      var oldPrec, oldPoints, op;
      var a, b, h, X, Y, YY, eps, target, okay, maxEps, maxEpsX;
      var func;
      var RF, RFU;

      res = { .okay = false };

      oldPrec = prec;
      oldPoints = points;
      prec = 165!;
      points = max(12, numberPoints)!;
      okay = true;
      a = inf(problemdef.dom);
      b = sup(problemdef.dom);
      h = (b - a) / points;
      maxEps = 0;
      maxEpsX = a;
      target = problemdef.target;
      func = problemdef.func;
      RF = variableFormat;
      RFU = (match (RF) with
                   D    : (D(_x_))
               DD   : (DD(_x_))
               TD   : (TD(_x_)));
      X = round(a, RF, RD);
      while (okay && (X <= b)) do {
        Y = implementedFunc(X);
        YY = func(X);
        op = prec;
        prec = 12!;
        eps := ~((Y / YY) - 1);
        prec = op!;
        if (abs(eps) > abs(target)) then {
          okay = false;
        } else {
          if (abs(eps) > maxEps) then {
             maxEps = abs(eps);
             maxEpsX = X;
          };
          X = round(X + h, RF, RU);
        };
      };

      if (doPlotFunc) then {
         points = default!;
         prec = 53!;
         plot(implementedFunc(RFU(_x_)), problemdef.dom);
      };

      if (doPlotError) then {
         points = default!;
         prec = 53!;
         plot(implementedFunc(RFU(_x_))/func(RFU(_x_)) - 1, target, -target, problemdef.dom);
      };

      points = oldPoints!;
      prec = oldPrec!;

      if (okay) then {
         res.okay = true;
         res.maxEps = maxEps;
         res.maxEpsX = maxEpsX;
      };

      return res;
};

procedure bindLibraryFunction(name, code) {
      var lf;
      var bindproccode, bindproc;

      bindproccode = "proc (c) { var ff; " @ name @ " = library(c); if (isbound(" @ name @ ")) then { ff = " @ name @ "; } else { ff = error; }; return ff; }";
      bindproc = parse(bindproccode);

      lf = bindproc(code);

      return lf;
};

procedure testImplementation(problemdef, parametrization, functionName, variableFormat, outputFormat, implementationFile, compileFlags, numberPoints, doPlotFunc, doPlotError) {
      var res, r;
      var compilepath;
      var signature;
      var compiledCode;
      var compilationMessages;
      var libfname;
      var lf;

      res = { .okay = false };

      compilepath = bashevaluate("cd '" @ __implement_metalibmdir @ "' > /dev/null 2> /dev/null; pwd");
      if compilepath[length(compilepath)-1] != "/" then compilepath = compilepath @ "/";

      if (variableFormat == D) then
         signature = "D_TO_"
          else
         if (variableFormat == DD) then
        signature = "DD_TO_"
         else 
        signature = "TD_TO_";
        
          signature = signature @ (match outputFormat with 
                                         D       : ("D") 
                                         DD      : ("DD")
                                         TD      : ("TD")
                                         default : ("")); 

      libfname = "lib_f_" @ (getUniqueToken());

      compiledCode = (bashevaluate("dirname '" @ implementationFile @ "'")) @ "/" @ (bashevaluate("basename '" @ implementationFile @ "' .c")) @ "_" @ __unique_id @ (getUniqueToken()) @ ".so";

          compilationMessages = bashevaluate(compilepath@"compile.sh --libfname "@libfname@" "@compilepath@" "@implementationFile@" "@signature@" "@functionName@" "@compiledCode@" "@compileFlags);

      res.compilationMessages = compilationMessages;

      lf = bindLibraryFunction(libfname, compiledCode);
      if (isbound(lf)) then {
         if (lf == lf) then {
            if (lf != _x_) then {
           if (lf(D(mid(problemdef.dom))) == lf(D(mid(problemdef.dom)))) then {
                  res.implementedFunc = lf;
                  r = testImplementationDoit(lf, problemdef, parametrization, variableFormat, outputFormat, numberPoints, doPlotFunc, doPlotError);
                  if (r.okay) then {
                     res = r;
                 res.compilationMessages = compilationMessages;
                 res.implementedFunc = lf;
                  };
           };
        };
         };
      };

      return res;
};

procedure tryImplementationExternal(problemdef, parametrization) {
      var res;
      var myparam;
      var oldPoints;

      oldPoints = points;
      points = default!;
      if (oldPoints != points) then {
         points = oldPoints!;
      } else {
         points = 91!;
      };

      myparam = parametrization;
      myparam.implementationFile = parametrization.implementationFile @ ".tmp.c";
      myparam.functionBasename = parametrization.functionBasename @ (getUniqueToken());

      myparam = initializeParametrization(myparam, problemdef);

      res = tryImplementation(problemdef, myparam);

      write("") > parametrization.implementationFile;
      emitCopyrightStatement(parametrization.implementationFile);
          bashexecute("cat " @ myparam.implementationFile @ " >> " @ parametrization.implementationFile);
      bashexecute("rm " @ myparam.implementationFile);

      points = oldPoints!;

      return res;
};


__metalibm_unique_token_counter = 0;

procedure getUniqueToken() {
      var c, d, r, t;

      if (isbound(__metalibm_unique_token_counter)) then {
         c = __metalibm_unique_token_counter;
         __metalibm_unique_token_counter = __metalibm_unique_token_counter + 1;
      } else {
         c = 0;
         __metalibm_unique_token_counter = 1;
      };

      d = bashevaluate("date '+%s'");
      r = bashevaluate("dd if=/dev/urandom bs=512 count=1 2> /dev/null | md5sum 2> /dev/null | sed -e 's/^\\([^ ]*\\).*$/\\1/g;'");

      t = "_" @ c @ "_" @ d @ "_" @ r @ "_";
      
      return t;
};

procedure myRandom(p) {
      var res, oldPrec;

      oldPrec = prec;
      prec = 2 * p + 1!;
      res = random(p);
      prec = oldPrec!;

      return res;
};

procedure generateTestVector(func, domains, inputFormat, outputFormat, valuesPerExponent, maxNumberValues, fileName, vectorNamePrefix) {
      var xHi, xMi, xLo;
      var xxHi, xxMi, xxLo;
      var yHi, yMi, yLo;
      var myDomains, dom;
      var okay;
      var minExpo, maxExpo, expo, sign, mant, i, k, l, pk;
      var xHiRev, xMiRev, xLoRev;
      var X, Y, YE, XX;
      var yyHi, yyMi, yyLo;
      var oldPrec, opp;

      "Generating test vector...";

      oldPrec = prec;
      prec = min(53, oldPrec)!;

      okay = true;

      xHi = [||]; xMi = [||]; xLo = [||];
      yHi = [||]; yMi = [||]; yLo = [||];

      myDomains = [||];
      for dom in domains do {
          if (0 in dom) then {
             if (inf(dom) == 0) then {
            if (sup(dom) == 0) then {
               myDomains = dom .: myDomains;
            } else {
               myDomains = [0] .: ([1b-1074;sup(dom)] .: myDomains);
            };
         } else {
            if (sup(dom) == 0) then {
               myDomains = [0] .: ([inf(dom);-1b-1074] .: myDomains);
            } else {
               myDomains = [0] .: ([inf(dom);-1b-1074] .: ([1b-1074;sup(dom)] .: myDomains));
            };
         };
          } else {
             myDomains = dom .: myDomains;
          };
      };

      for dom in myDomains do {
          if (inf(dom) == sup(dom)) then {
             X := (match (inputFormat) with
                     D   : (D(inf(dom)))
                 DD  : (DD(inf(dom)))
                 TD  : (TD(inf(dom))));
             xxHi = D(X);
         xxMi = D(X - xxHi);
         xxLo = D(X - (xxHi + xxMi));
         xHi = xxHi .: xHi;
         xMi = xxMi .: xMi;
         xLo = xxLo .: xLo;
          } else {
             if (!(0 in dom)) then {
            minExpo = floor(log2(inf(abs(dom))));
            maxExpo = ceil(log2(sup(abs(dom))));
            if (sup(dom) < 0) then {
               sign = -1;
            } else {
               sign = 1;
            };
            for expo from minExpo to maxExpo do {
                for i from 1 to valuesPerExponent do {
                mant = (match (inputFormat) with
                              D   : (myRandom(53))
                      DD  : (myRandom(107))
                      TD  : (myRandom(161)));
                        X := (match (inputFormat) with
                                D   : (D(sign * 2^expo * mant))
                            DD  : (DD(sign * 2^expo * mant))
                            TD  : (TD(sign * 2^expo * mant)));
                if (X == X) then {
                    if (abs(X) < 2^1024) then {
                            if (X in dom) then {
                                    xxHi = D(X);
                                xxMi = D(X - xxHi);
                                xxLo = D(X - (xxHi + xxMi));
                                xHi = xxHi .: xHi;
                                xMi = xxMi .: xMi;
                                xLo = xxLo .: xLo;
                            };
                };
                };
            };
            };
         } else {
           okay = false;
         };
          };
      };

      if (okay &&
          (length(xHi) == length(xMi)) &&
          (length(xMi) == length(xLo))) then {
         xHiRev = revert(xHi);
         xMiRev = revert(xMi);
         xLoRev = revert(xLo);
         xHi = [||];
         xMi = [||];
         xLo = [||];
         XX = [||];
         while ((xHiRev != [||]) &&
                (xMiRev != [||]) &&
            (xLoRev != [||])) do {
           xxHi = head(xHiRev);
           xxMi = head(xMiRev);
           xxLo = head(xLoRev);
           xHiRev = tail(xHiRev);
           xMiRev = tail(xMiRev);
           xLoRev = tail(xLoRev);
           XX = (xxHi + xxMi + xxLo) .: XX;
             };
         XX = revert(sort(XX));
         while (XX != [||]) do {
               X = head(XX);
           XX = tail(XX);
               xxHi = D(X);
           xxMi = D(X - xxHi);
           xxLo = D(X - (xxHi + xxMi));
           xHi = xxHi .: xHi;
           xMi = xxMi .: xMi;
           xLo = xxLo .: xLo;
         };
      };

      if (okay &&
          (length(xHi) == length(xMi)) &&
          (length(xMi) == length(xLo))) then {
          if (length(xHi) > maxNumberValues) then {
                  xHiRev = revert(xHi);
                  xMiRev = revert(xMi);
                  xLoRev = revert(xLo);
                  xHi = [||];
              xMi = [||];
              xLo = [||];
              i = 0; k = 0; l = length(xHiRev);
                  while ((xHiRev != [||]) &&
                         (xMiRev != [||]) &&
                     (xLoRev != [||])) do {
                    xxHi = head(xHiRev);
                    xxMi = head(xMiRev);
                    xxLo = head(xLoRev);
                    xHiRev = tail(xHiRev);
                    xMiRev = tail(xMiRev);
                    xLoRev = tail(xLoRev);
                k = k + 1;
                if (i < floor((k * maxNumberValues) / l)) then {
                   xHi = xxHi .: xHi;
                   xMi = xxMi .: xMi;
                   xLo = xxLo .: xLo;
                   i = i + 1;
                };
              };
          };
      };

      if (okay &&
          (length(xHi) == length(xMi)) &&
          (length(xMi) == length(xLo))) then {
          xHiRev = revert(xHi);
          xMiRev = revert(xMi);
          xLoRev = revert(xLo);
          i = 0; l = length(xHi); pk = -17;
          while ((xHiRev != [||]) &&
                 (xMiRev != [||]) &&
             (xLoRev != [||])) do {
            xxHi = head(xHiRev);
            xxMi = head(xMiRev);
            xxLo = head(xLoRev);
            xHiRev = tail(xHiRev);
            xMiRev = tail(xMiRev);
            xLoRev = tail(xLoRev);
            X = xxHi + xxMi + xxLo;
            opp = prec;
            prec = 12!;
            YE = simplify(func(X));
            prec = opp!;
            match (outputFormat) with
                  D  : { yyHi = D(YE); Y = yyHi; }
              DD : { yyHi = D(YE); yyMi = D(YE - yyHi); Y = yyHi + yyMi; }
              TD : { yyHi = D(YE); yyMi = D(YE - yyHi); yyLo = D(YE - (yyHi + yyMi)); Y = yyHi + yyMi + yyLo; };
            yyHi = D(Y);
            yyMi = D(Y - yyHi);
            yyLo = D(Y - (yyHi + yyMi));
            yHi = yyHi .: yHi;
            yMi = yyMi .: yMi;
            yLo = yyLo .: yLo;
            i = i + 1;
            k = nearestint((i * 100) / l);
            if (k != pk) then {
               "... ", k, "% done...";
               pk = k;
            }; 
          };
      } else {
        okay = false;
      };

      prec = 161!;
      if (okay &&
          (length(xHi) == length(xMi)) &&
          (length(xMi) == length(xLo)) &&
          (length(xLo) == length(yHi)) &&
          (length(yHi) == length(yMi)) &&
          (length(yMi) == length(yLo))) then {
         write("\n") > fileName;
         write("#define ", vectorNamePrefix, "_vector_len ", length(xHi),"\n\n") >> fileName;
         write("static const double ", vectorNamePrefix, "_x_hi[", vectorNamePrefix, "_vector_len] = {\n") >> fileName;
         while (xHi != [||]) do {
               xxHi = head(xHi);
           xHi = tail(xHi);
               write("    ", ~xxHi) >> fileName;
           if (xHi != [||]) then {
              write(",") >> fileName;
           };
           write("\n") >> fileName;
         };
         write("};\n\n") >> fileName;
         if (inputFormat != D) then {
            write("static const double ", vectorNamePrefix, "_x_mi[", vectorNamePrefix, "_vector_len] = {\n") >> fileName;
            while (xMi != [||]) do {
                  xxMi = head(xMi);
              xMi = tail(xMi);
                  write("    ", ~xxMi) >> fileName;
              if (xMi != [||]) then {
                 write(",") >> fileName;
              };
              write("\n") >> fileName;
            };
            write("};\n\n") >> fileName;
         };
         if (inputFormat == TD) then {
            write("static const double ", vectorNamePrefix, "_x_lo[", vectorNamePrefix, "_vector_len] = {\n") >> fileName;
            while (xLo != [||]) do {
                  xxLo = head(xLo);
              xLo = tail(xLo);
                  write("    ", ~xxLo) >> fileName;
              if (xLo != [||]) then {
                 write(",") >> fileName;
              };
              write("\n") >> fileName;
            };
            write("};\n\n") >> fileName;
         };
         write("static const double ", vectorNamePrefix, "_y_hi[", vectorNamePrefix, "_vector_len] = {\n") >> fileName;
         while (yHi != [||]) do {
               yyHi = head(yHi);
           yHi = tail(yHi);
               write("    ", ~yyHi) >> fileName;
           if (yHi != [||]) then {
              write(",") >> fileName;
           };
           write("\n") >> fileName;
         };
         write("};\n\n") >> fileName;
         if (outputFormat != D) then {
            write("static const double ", vectorNamePrefix, "_y_mi[", vectorNamePrefix, "_vector_len] = {\n") >> fileName;
            while (yMi != [||]) do {
                  yyMi = head(yMi);
              yMi = tail(yMi);
                  write("    ", ~yyMi) >> fileName;
              if (yMi != [||]) then {
                 write(",") >> fileName;
              };
              write("\n") >> fileName;
            };
            write("};\n\n") >> fileName;
         };
         if (outputFormat == TD) then {
            write("static const double ", vectorNamePrefix, "_y_lo[", vectorNamePrefix, "_vector_len] = {\n") >> fileName;
            while (yLo != [||]) do {
                  yyLo = head(yLo);
              yLo = tail(yLo);
                  write("    ", ~yyLo) >> fileName;
              if (yLo != [||]) then {
                 write(",") >> fileName;
              };
              write("\n") >> fileName;
            };
            write("};\n\n") >> fileName;
         };
      } else {
         okay = false;
      };

      prec = oldPrec!;

      "... finished";

      return okay;
};

procedure emitCopyrightStatement(outputFile) {
          write("/* \n") >> outputFile;
          write("\n") >> outputFile;
          write("    This code was generated using non-trivial code generation commands\n") >> outputFile;
          write("    of the Metalibm software program.\n") >> outputFile;
          write("    \n") >> outputFile;
          write("    Before using, modifying and/or integrating this code into other\n") >> outputFile;
          write("    software, review the copyright and license status of this\n") >> outputFile;
          write("    generated code. In particular, see the exception below.\n") >> outputFile;
          write("\n") >> outputFile;
          write("    This generated program is partly or entirely based on a program\n") >> outputFile;
          write("    generated using non-trivial code generation commands of the Sollya\n") >> outputFile;
          write("    software program. See the copyright notice and exception text\n") >> outputFile;
          write("    referring to that Sollya-generated part of this program generated\n") >> outputFile;
          write("    with Metalibm below.\n") >> outputFile;
          write("\n") >> outputFile;
          write("    Metalibm is\n") >> outputFile;
          write(" \n") >> outputFile;
          write("    Copyright 2008-2013 by \n") >> outputFile;
          write("\n") >> outputFile;
          write("    Laboratoire de l'Informatique du ParallÃ©lisme, \n") >> outputFile;
          write("    UMR CNRS - ENS Lyon - UCB Lyon 1 - INRIA 5668\n") >> outputFile;
          write("\n") >> outputFile;
          write("    and by\n") >> outputFile;
          write("\n") >> outputFile;
          write("    Laboratoire d'Informatique de Paris 6, equipe PEQUAN,\n") >> outputFile;
          write("    UPMC Universite Paris 06 - CNRS - UMR 7606 - LIP6, Paris, France.\n") >> outputFile;
          write("\n") >> outputFile;
          write("    Contributors: Christoph Quirin Lauter \n") >> outputFile;
          write("                  (UPMC LIP6 PEQUAN formerly LIP/ENS Lyon) \n") >> outputFile;
          write("                  christoph.lauter@lip6.fr\n") >> outputFile;
          write("\n") >> outputFile;
          write("         and\n") >> outputFile;
          write("\n") >> outputFile;
          write("         Olga Kupriianova \n") >> outputFile;
          write("         (UPMC LIP6 PEQUAN)\n") >> outputFile;
          write("         olga.kupriianova@lip6.fr\n") >> outputFile;
          write("\n") >> outputFile;
          write("    Metalibm was formerly developed by the Arenaire project at Ecole\n") >> outputFile;
          write("    Normale Superieure de Lyon and is now developed by Equipe PEQUAN\n") >> outputFile;
          write("    at Universite Pierre et Marie Curie Paris 6.\n") >> outputFile;
          write("\n") >> outputFile;
          write("    The Metalibm software program is free software; you can\n") >> outputFile;
          write("    redistribute it and/or modify it under the terms of the GNU Lesser\n") >> outputFile;
          write("    General Public License as published by the Free Software\n") >> outputFile;
          write("    Foundation; either version 2 of the License, or (at your option)\n") >> outputFile;
          write("    any later version.\n") >> outputFile;
          write("\n") >> outputFile;
          write("    Metalibm is distributed in the hope that it will be useful,\n") >> outputFile;
          write("    but WITHOUT ANY WARRANTY; without even the implied warranty of\n") >> outputFile;
          write("    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n") >> outputFile;
          write("    GNU General Public License for more details.\n") >> outputFile;
          write("\n") >> outputFile;
          write("    You should have received a copy of the GNU Lesser General Public\n") >> outputFile;
          write("    License along with the Metalibm program; if not, write to the Free\n") >> outputFile;
          write("    Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA\n") >> outputFile;
          write("    02111-1307, USA.\n") >> outputFile;
          write("\n") >> outputFile;
          write("    This generated program is distributed WITHOUT ANY WARRANTY; without\n") >> outputFile;
          write("    even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n") >> outputFile;
          write("    PARTICULAR PURPOSE.\n") >> outputFile;
          write("    \n") >> outputFile;
          write("    As a special exception, you may create a larger work that contains\n") >> outputFile;
          write("    part or all of this software generated using Metalibm and\n") >> outputFile;
          write("    distribute that work under terms of your choice, so long as that\n") >> outputFile;
          write("    work isn't itself a numerical code generator using the skeleton of\n") >> outputFile;
          write("    this code or a modified version thereof as a code skeleton.\n") >> outputFile;
          write("    Alternatively, if you modify or redistribute this generated code\n") >> outputFile;
          write("    itself, or its skeleton, you may (at your option) remove this\n") >> outputFile;
          write("    special exception, which will cause this generated code and its\n") >> outputFile;
          write("    skeleton and the resulting Metalibm output files to be licensed\n") >> outputFile;
          write("    under the General Public licence (version 2) without this special\n") >> outputFile;
          write("    exception.\n") >> outputFile;
          write("    \n") >> outputFile;
          write("    This special exception was added by the Metalibm copyright holders \n") >> outputFile;
          write("    on November 20th 2013.\n") >> outputFile;
          write("    \n") >> outputFile;
          write("*/\n") >> outputFile;
          write("\n") >> outputFile;
};
